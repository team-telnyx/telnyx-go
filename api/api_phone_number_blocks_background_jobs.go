/*
Telnyx API

SIP trunking, SMS, MMS, Call Control and Telephony Data Services.

API version: 2.0.0
Contact: support@telnyx.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package telnyx

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// PhoneNumberBlocksBackgroundJobsAPIService PhoneNumberBlocksBackgroundJobsAPI service
type PhoneNumberBlocksBackgroundJobsAPIService service

type ApiCreatePhoneNumberBlockDeletionJobRequest struct {
	ctx context.Context
	ApiService *PhoneNumberBlocksBackgroundJobsAPIService
	phoneNumberBlocksJobDeletePhoneNumberBlockRequest *PhoneNumberBlocksJobDeletePhoneNumberBlockRequest
}

func (r ApiCreatePhoneNumberBlockDeletionJobRequest) PhoneNumberBlocksJobDeletePhoneNumberBlockRequest(phoneNumberBlocksJobDeletePhoneNumberBlockRequest PhoneNumberBlocksJobDeletePhoneNumberBlockRequest) ApiCreatePhoneNumberBlockDeletionJobRequest {
	r.phoneNumberBlocksJobDeletePhoneNumberBlockRequest = &phoneNumberBlocksJobDeletePhoneNumberBlockRequest
	return r
}

func (r ApiCreatePhoneNumberBlockDeletionJobRequest) Execute() (*PhoneNumberBlocksJobDeletePhoneNumberBlock, *http.Response, error) {
	return r.ApiService.CreatePhoneNumberBlockDeletionJobExecute(r)
}

/*
CreatePhoneNumberBlockDeletionJob Deletes all numbers associated with a phone number block

Creates a new background job to delete all the phone numbers associated with the given block. We will only consider the phone number block as deleted after all phone numbers associated with it are removed, so multiple executions of this job may be necessary in case some of the phone numbers present errors during the deletion process.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreatePhoneNumberBlockDeletionJobRequest
*/
func (a *PhoneNumberBlocksBackgroundJobsAPIService) CreatePhoneNumberBlockDeletionJob(ctx context.Context) ApiCreatePhoneNumberBlockDeletionJobRequest {
	return ApiCreatePhoneNumberBlockDeletionJobRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PhoneNumberBlocksJobDeletePhoneNumberBlock
func (a *PhoneNumberBlocksBackgroundJobsAPIService) CreatePhoneNumberBlockDeletionJobExecute(r ApiCreatePhoneNumberBlockDeletionJobRequest) (*PhoneNumberBlocksJobDeletePhoneNumberBlock, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PhoneNumberBlocksJobDeletePhoneNumberBlock
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PhoneNumberBlocksBackgroundJobsAPIService.CreatePhoneNumberBlockDeletionJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/phone_number_blocks/jobs/delete_phone_number_block"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.phoneNumberBlocksJobDeletePhoneNumberBlockRequest == nil {
		return localVarReturnValue, nil, reportError("phoneNumberBlocksJobDeletePhoneNumberBlockRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.phoneNumberBlocksJobDeletePhoneNumberBlockRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPhoneNumberBlocksJobRequest struct {
	ctx context.Context
	ApiService *PhoneNumberBlocksBackgroundJobsAPIService
	id string
}

func (r ApiGetPhoneNumberBlocksJobRequest) Execute() (*PhoneNumberBlocksJob, *http.Response, error) {
	return r.ApiService.GetPhoneNumberBlocksJobExecute(r)
}

/*
GetPhoneNumberBlocksJob Retrieves a phone number blocks job

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the Phone Number Blocks Job.
 @return ApiGetPhoneNumberBlocksJobRequest
*/
func (a *PhoneNumberBlocksBackgroundJobsAPIService) GetPhoneNumberBlocksJob(ctx context.Context, id string) ApiGetPhoneNumberBlocksJobRequest {
	return ApiGetPhoneNumberBlocksJobRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PhoneNumberBlocksJob
func (a *PhoneNumberBlocksBackgroundJobsAPIService) GetPhoneNumberBlocksJobExecute(r ApiGetPhoneNumberBlocksJobRequest) (*PhoneNumberBlocksJob, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PhoneNumberBlocksJob
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PhoneNumberBlocksBackgroundJobsAPIService.GetPhoneNumberBlocksJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/phone_number_blocks/jobs/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPhoneNumberBlocksJobsRequest struct {
	ctx context.Context
	ApiService *PhoneNumberBlocksBackgroundJobsAPIService
	filterType *string
	filterStatus *string
	pageNumber *int32
	pageSize *int32
	sort *string
}

// Filter the phone number blocks jobs by type.
func (r ApiListPhoneNumberBlocksJobsRequest) FilterType(filterType string) ApiListPhoneNumberBlocksJobsRequest {
	r.filterType = &filterType
	return r
}

// Filter the phone number blocks jobs by status.
func (r ApiListPhoneNumberBlocksJobsRequest) FilterStatus(filterStatus string) ApiListPhoneNumberBlocksJobsRequest {
	r.filterStatus = &filterStatus
	return r
}

// The page number to load.
func (r ApiListPhoneNumberBlocksJobsRequest) PageNumber(pageNumber int32) ApiListPhoneNumberBlocksJobsRequest {
	r.pageNumber = &pageNumber
	return r
}

// The size of the page.
func (r ApiListPhoneNumberBlocksJobsRequest) PageSize(pageSize int32) ApiListPhoneNumberBlocksJobsRequest {
	r.pageSize = &pageSize
	return r
}

// Specifies the sort order for results. If not given, results are sorted by created_at in descending order.
func (r ApiListPhoneNumberBlocksJobsRequest) Sort(sort string) ApiListPhoneNumberBlocksJobsRequest {
	r.sort = &sort
	return r
}

func (r ApiListPhoneNumberBlocksJobsRequest) Execute() (*ListPhoneNumberBlocksBackgroundJobsResponse, *http.Response, error) {
	return r.ApiService.ListPhoneNumberBlocksJobsExecute(r)
}

/*
ListPhoneNumberBlocksJobs Lists the phone number blocks jobs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListPhoneNumberBlocksJobsRequest
*/
func (a *PhoneNumberBlocksBackgroundJobsAPIService) ListPhoneNumberBlocksJobs(ctx context.Context) ApiListPhoneNumberBlocksJobsRequest {
	return ApiListPhoneNumberBlocksJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListPhoneNumberBlocksBackgroundJobsResponse
func (a *PhoneNumberBlocksBackgroundJobsAPIService) ListPhoneNumberBlocksJobsExecute(r ApiListPhoneNumberBlocksJobsRequest) (*ListPhoneNumberBlocksBackgroundJobsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListPhoneNumberBlocksBackgroundJobsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PhoneNumberBlocksBackgroundJobsAPIService.ListPhoneNumberBlocksJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/phone_number_blocks/jobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[type]", r.filterType, "form", "")
	}
	if r.filterStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[status]", r.filterStatus, "form", "")
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
