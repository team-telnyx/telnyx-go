/*
Telnyx API

SIP trunking, SMS, MMS, Call Control and Telephony Data Services.

API version: 2.0.0
Contact: support@telnyx.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package telnyx

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// MessagingHostedNumberAPIService MessagingHostedNumberAPI service
type MessagingHostedNumberAPIService service

type ApiCheckEligibilityNumbersRequest struct {
	ctx context.Context
	ApiService *MessagingHostedNumberAPIService
	phoneNumbers *string
}

// Comma-separated list of phone numbers to check eligibility
func (r ApiCheckEligibilityNumbersRequest) PhoneNumbers(phoneNumbers string) ApiCheckEligibilityNumbersRequest {
	r.phoneNumbers = &phoneNumbers
	return r
}

func (r ApiCheckEligibilityNumbersRequest) Execute() (*EligibilityNumbersResponse, *http.Response, error) {
	return r.ApiService.CheckEligibilityNumbersExecute(r)
}

/*
CheckEligibilityNumbers Check eligibility of phone numbers for hosted messaging

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCheckEligibilityNumbersRequest
*/
func (a *MessagingHostedNumberAPIService) CheckEligibilityNumbers(ctx context.Context) ApiCheckEligibilityNumbersRequest {
	return ApiCheckEligibilityNumbersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EligibilityNumbersResponse
func (a *MessagingHostedNumberAPIService) CheckEligibilityNumbersExecute(r ApiCheckEligibilityNumbersRequest) (*EligibilityNumbersResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EligibilityNumbersResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingHostedNumberAPIService.CheckEligibilityNumbers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messaging_hosted_number_orders/eligibility_numbers_check"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.phoneNumbers == nil {
		return localVarReturnValue, nil, reportError("phoneNumbers is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "phone_numbers", r.phoneNumbers, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateMessagingHostedNumberOrderRequest struct {
	ctx context.Context
	ApiService *MessagingHostedNumberAPIService
	createMessagingHostedNumberOrderRequest *CreateMessagingHostedNumberOrderRequest
}

// Message payload
func (r ApiCreateMessagingHostedNumberOrderRequest) CreateMessagingHostedNumberOrderRequest(createMessagingHostedNumberOrderRequest CreateMessagingHostedNumberOrderRequest) ApiCreateMessagingHostedNumberOrderRequest {
	r.createMessagingHostedNumberOrderRequest = &createMessagingHostedNumberOrderRequest
	return r
}

func (r ApiCreateMessagingHostedNumberOrderRequest) Execute() (*RetrieveMessagingHostedNumberOrderResponse, *http.Response, error) {
	return r.ApiService.CreateMessagingHostedNumberOrderExecute(r)
}

/*
CreateMessagingHostedNumberOrder Create a messaging hosted number order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateMessagingHostedNumberOrderRequest
*/
func (a *MessagingHostedNumberAPIService) CreateMessagingHostedNumberOrder(ctx context.Context) ApiCreateMessagingHostedNumberOrderRequest {
	return ApiCreateMessagingHostedNumberOrderRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RetrieveMessagingHostedNumberOrderResponse
func (a *MessagingHostedNumberAPIService) CreateMessagingHostedNumberOrderExecute(r ApiCreateMessagingHostedNumberOrderRequest) (*RetrieveMessagingHostedNumberOrderResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RetrieveMessagingHostedNumberOrderResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingHostedNumberAPIService.CreateMessagingHostedNumberOrder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messaging_hosted_number_orders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createMessagingHostedNumberOrderRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateVerificationCodesForMessagingHostedNumberOrderRequest struct {
	ctx context.Context
	ApiService *MessagingHostedNumberAPIService
	id string
	verificationCodesRequest *VerificationCodesRequest
}

// Message payload
func (r ApiCreateVerificationCodesForMessagingHostedNumberOrderRequest) VerificationCodesRequest(verificationCodesRequest VerificationCodesRequest) ApiCreateVerificationCodesForMessagingHostedNumberOrderRequest {
	r.verificationCodesRequest = &verificationCodesRequest
	return r
}

func (r ApiCreateVerificationCodesForMessagingHostedNumberOrderRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.CreateVerificationCodesForMessagingHostedNumberOrderExecute(r)
}

/*
CreateVerificationCodesForMessagingHostedNumberOrder Create verification codes for the hosted numbers order

Create verification codes to validate numbers of the hosted order. The verification codes will be sent to the numbers of the hosted order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Order ID to have a verification code created.
 @return ApiCreateVerificationCodesForMessagingHostedNumberOrderRequest
*/
func (a *MessagingHostedNumberAPIService) CreateVerificationCodesForMessagingHostedNumberOrder(ctx context.Context, id string) ApiCreateVerificationCodesForMessagingHostedNumberOrderRequest {
	return ApiCreateVerificationCodesForMessagingHostedNumberOrderRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return interface{}
func (a *MessagingHostedNumberAPIService) CreateVerificationCodesForMessagingHostedNumberOrderExecute(r ApiCreateVerificationCodesForMessagingHostedNumberOrderRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingHostedNumberAPIService.CreateVerificationCodesForMessagingHostedNumberOrder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messaging_hosted_number_orders/{id}/verification_codes"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.verificationCodesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteMessagingHostedNumberRequest struct {
	ctx context.Context
	ApiService *MessagingHostedNumberAPIService
	id string
}

func (r ApiDeleteMessagingHostedNumberRequest) Execute() (*RetrieveMessagingHostedNumberResponse1, *http.Response, error) {
	return r.ApiService.DeleteMessagingHostedNumberExecute(r)
}

/*
DeleteMessagingHostedNumber Delete a messaging hosted number

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the type of resource.
 @return ApiDeleteMessagingHostedNumberRequest
*/
func (a *MessagingHostedNumberAPIService) DeleteMessagingHostedNumber(ctx context.Context, id string) ApiDeleteMessagingHostedNumberRequest {
	return ApiDeleteMessagingHostedNumberRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RetrieveMessagingHostedNumberResponse1
func (a *MessagingHostedNumberAPIService) DeleteMessagingHostedNumberExecute(r ApiDeleteMessagingHostedNumberRequest) (*RetrieveMessagingHostedNumberResponse1, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RetrieveMessagingHostedNumberResponse1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingHostedNumberAPIService.DeleteMessagingHostedNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messaging_hosted_numbers/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMessagingHostedNumberOrderRequest struct {
	ctx context.Context
	ApiService *MessagingHostedNumberAPIService
	id string
}

func (r ApiGetMessagingHostedNumberOrderRequest) Execute() (*RetrieveMessagingHostedNumberOrderResponse, *http.Response, error) {
	return r.ApiService.GetMessagingHostedNumberOrderExecute(r)
}

/*
GetMessagingHostedNumberOrder Retrieve a messaging hosted number order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the type of resource.
 @return ApiGetMessagingHostedNumberOrderRequest
*/
func (a *MessagingHostedNumberAPIService) GetMessagingHostedNumberOrder(ctx context.Context, id string) ApiGetMessagingHostedNumberOrderRequest {
	return ApiGetMessagingHostedNumberOrderRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RetrieveMessagingHostedNumberOrderResponse
func (a *MessagingHostedNumberAPIService) GetMessagingHostedNumberOrderExecute(r ApiGetMessagingHostedNumberOrderRequest) (*RetrieveMessagingHostedNumberOrderResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RetrieveMessagingHostedNumberOrderResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingHostedNumberAPIService.GetMessagingHostedNumberOrder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messaging_hosted_number_orders/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListMessagingHostedNumberOrdersRequest struct {
	ctx context.Context
	ApiService *MessagingHostedNumberAPIService
	pageNumber *int32
	pageSize *int32
}

// The page number to load.
func (r ApiListMessagingHostedNumberOrdersRequest) PageNumber(pageNumber int32) ApiListMessagingHostedNumberOrdersRequest {
	r.pageNumber = &pageNumber
	return r
}

// The size of the page.
func (r ApiListMessagingHostedNumberOrdersRequest) PageSize(pageSize int32) ApiListMessagingHostedNumberOrdersRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListMessagingHostedNumberOrdersRequest) Execute() (*ListMessagingHostedNumberOrderResponse, *http.Response, error) {
	return r.ApiService.ListMessagingHostedNumberOrdersExecute(r)
}

/*
ListMessagingHostedNumberOrders List messaging hosted number orders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListMessagingHostedNumberOrdersRequest
*/
func (a *MessagingHostedNumberAPIService) ListMessagingHostedNumberOrders(ctx context.Context) ApiListMessagingHostedNumberOrdersRequest {
	return ApiListMessagingHostedNumberOrdersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListMessagingHostedNumberOrderResponse
func (a *MessagingHostedNumberAPIService) ListMessagingHostedNumberOrdersExecute(r ApiListMessagingHostedNumberOrdersRequest) (*ListMessagingHostedNumberOrderResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListMessagingHostedNumberOrderResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingHostedNumberAPIService.ListMessagingHostedNumberOrders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messaging_hosted_number_orders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUploadMessagingHostedNumberOrderFileRequest struct {
	ctx context.Context
	ApiService *MessagingHostedNumberAPIService
	id string
	loa *os.File
	bill *os.File
}

// Must be a signed LOA for the numbers in the order in PDF format.
func (r ApiUploadMessagingHostedNumberOrderFileRequest) Loa(loa *os.File) ApiUploadMessagingHostedNumberOrderFileRequest {
	r.loa = loa
	return r
}

// Must be the last month&#39;s bill with proof of ownership of all of the numbers in the order in PDF format.
func (r ApiUploadMessagingHostedNumberOrderFileRequest) Bill(bill *os.File) ApiUploadMessagingHostedNumberOrderFileRequest {
	r.bill = bill
	return r
}

func (r ApiUploadMessagingHostedNumberOrderFileRequest) Execute() (*RetrieveMessagingHostedNumberOrderResponse, *http.Response, error) {
	return r.ApiService.UploadMessagingHostedNumberOrderFileExecute(r)
}

/*
UploadMessagingHostedNumberOrderFile Upload file required for a messaging hosted number order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the type of resource.
 @return ApiUploadMessagingHostedNumberOrderFileRequest
*/
func (a *MessagingHostedNumberAPIService) UploadMessagingHostedNumberOrderFile(ctx context.Context, id string) ApiUploadMessagingHostedNumberOrderFileRequest {
	return ApiUploadMessagingHostedNumberOrderFileRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RetrieveMessagingHostedNumberOrderResponse
func (a *MessagingHostedNumberAPIService) UploadMessagingHostedNumberOrderFileExecute(r ApiUploadMessagingHostedNumberOrderFileRequest) (*RetrieveMessagingHostedNumberOrderResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RetrieveMessagingHostedNumberOrderResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingHostedNumberAPIService.UploadMessagingHostedNumberOrderFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messaging_hosted_number_orders/{id}/actions/file_upload"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var loaLocalVarFormFileName string
	var loaLocalVarFileName     string
	var loaLocalVarFileBytes    []byte

	loaLocalVarFormFileName = "loa"
	loaLocalVarFile := r.loa

	if loaLocalVarFile != nil {
		fbs, _ := io.ReadAll(loaLocalVarFile)

		loaLocalVarFileBytes = fbs
		loaLocalVarFileName = loaLocalVarFile.Name()
		loaLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: loaLocalVarFileBytes, fileName: loaLocalVarFileName, formFileName: loaLocalVarFormFileName})
	}
	var billLocalVarFormFileName string
	var billLocalVarFileName     string
	var billLocalVarFileBytes    []byte

	billLocalVarFormFileName = "bill"
	billLocalVarFile := r.bill

	if billLocalVarFile != nil {
		fbs, _ := io.ReadAll(billLocalVarFile)

		billLocalVarFileBytes = fbs
		billLocalVarFileName = billLocalVarFile.Name()
		billLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: billLocalVarFileBytes, fileName: billLocalVarFileName, formFileName: billLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidateVerificationCodesForMessagingHostedNumberOrderRequest struct {
	ctx context.Context
	ApiService *MessagingHostedNumberAPIService
	id string
	validationCodesRequest *ValidationCodesRequest
}

// Message payload
func (r ApiValidateVerificationCodesForMessagingHostedNumberOrderRequest) ValidationCodesRequest(validationCodesRequest ValidationCodesRequest) ApiValidateVerificationCodesForMessagingHostedNumberOrderRequest {
	r.validationCodesRequest = &validationCodesRequest
	return r
}

func (r ApiValidateVerificationCodesForMessagingHostedNumberOrderRequest) Execute() (*RetrieveMessagingHostedNumberResponse, *http.Response, error) {
	return r.ApiService.ValidateVerificationCodesForMessagingHostedNumberOrderExecute(r)
}

/*
ValidateVerificationCodesForMessagingHostedNumberOrder Validate the verification codes for the hosted numbers order

Validate the verification codes sent to the numbers of the hosted order. The verification codes must be created in the verification codes endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Order ID related to the validation codes.
 @return ApiValidateVerificationCodesForMessagingHostedNumberOrderRequest
*/
func (a *MessagingHostedNumberAPIService) ValidateVerificationCodesForMessagingHostedNumberOrder(ctx context.Context, id string) ApiValidateVerificationCodesForMessagingHostedNumberOrderRequest {
	return ApiValidateVerificationCodesForMessagingHostedNumberOrderRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RetrieveMessagingHostedNumberResponse
func (a *MessagingHostedNumberAPIService) ValidateVerificationCodesForMessagingHostedNumberOrderExecute(r ApiValidateVerificationCodesForMessagingHostedNumberOrderRequest) (*RetrieveMessagingHostedNumberResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RetrieveMessagingHostedNumberResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingHostedNumberAPIService.ValidateVerificationCodesForMessagingHostedNumberOrder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messaging_hosted_number_orders/{id}/validation_codes"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.validationCodesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
