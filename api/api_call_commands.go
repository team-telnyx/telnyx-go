/*
Telnyx API

SIP trunking, SMS, MMS, Call Control and Telephony Data Services.

API version: 2.0.0
Contact: support@telnyx.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package telnyx

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// CallCommandsAPIService CallCommandsAPI service
type CallCommandsAPIService service

type ApiAnswerCallRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	answerRequest *AnswerRequest
}

// Answer call request
func (r ApiAnswerCallRequest) AnswerRequest(answerRequest AnswerRequest) ApiAnswerCallRequest {
	r.answerRequest = &answerRequest
	return r
}

func (r ApiAnswerCallRequest) Execute() (*CallControlCommandResponseWithRecordingID, *http.Response, error) {
	return r.ApiService.AnswerCallExecute(r)
}

/*
AnswerCall Answer call

Answer an incoming call. You must issue this command before executing subsequent commands on an incoming call.

**Expected Webhooks (see [callback schema](https://developers.telnyx.com/api/call-control/answer-call#callbacks) below):**

- `call.answered`
- `streaming.started`, `streaming.stopped` or `streaming.failed` if `stream_url` was set

When the `record` parameter is set to `record-from-answer`, the response will include a `recording_id` field.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiAnswerCallRequest
*/
func (a *CallCommandsAPIService) AnswerCall(ctx context.Context, callControlId string) ApiAnswerCallRequest {
	return ApiAnswerCallRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponseWithRecordingID
func (a *CallCommandsAPIService) AnswerCallExecute(r ApiAnswerCallRequest) (*CallControlCommandResponseWithRecordingID, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponseWithRecordingID
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.AnswerCall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/answer"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.answerRequest == nil {
		return localVarReturnValue, nil, reportError("answerRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.answerRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBridgeCallRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	bridgeRequest *BridgeRequest
}

// Bridge call request
func (r ApiBridgeCallRequest) BridgeRequest(bridgeRequest BridgeRequest) ApiBridgeCallRequest {
	r.bridgeRequest = &bridgeRequest
	return r
}

func (r ApiBridgeCallRequest) Execute() (*CallControlCommandResponse, *http.Response, error) {
	return r.ApiService.BridgeCallExecute(r)
}

/*
BridgeCall Bridge calls

Bridge two call control calls.

**Expected Webhooks (see [callback schema](https://developers.telnyx.com/api/call-control/bridge-call#callbacks) below):**

- `call.bridged` for Leg A
- `call.bridged` for Leg B


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiBridgeCallRequest
*/
func (a *CallCommandsAPIService) BridgeCall(ctx context.Context, callControlId string) ApiBridgeCallRequest {
	return ApiBridgeCallRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponse
func (a *CallCommandsAPIService) BridgeCallExecute(r ApiBridgeCallRequest) (*CallControlCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.BridgeCall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/bridge"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bridgeRequest == nil {
		return localVarReturnValue, nil, reportError("bridgeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bridgeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallGatherUsingAIRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	gatherUsingAIRequest *GatherUsingAIRequest
}

// Gather using AI request
func (r ApiCallGatherUsingAIRequest) GatherUsingAIRequest(gatherUsingAIRequest GatherUsingAIRequest) ApiCallGatherUsingAIRequest {
	r.gatherUsingAIRequest = &gatherUsingAIRequest
	return r
}

func (r ApiCallGatherUsingAIRequest) Execute() (*CallControlCommandResponse, *http.Response, error) {
	return r.ApiService.CallGatherUsingAIExecute(r)
}

/*
CallGatherUsingAI Gather using AI

Gather parameters defined in the request payload using a voice assistant.

 You can pass parameters described as a JSON Schema object and the voice assistant will attempt to gather these informations. 

**Expected Webhooks (see [callback schema](https://developers.telnyx.com/api/call-control/call-gather-using-ai#callbacks) below):**

- `call.ai_gather.ended`
- `call.ai_gather.partial_results` (if `send_partial_results` is set to `true`)
- `call.ai_gather.message_history_updated` (if `send_message_history_updates` is set to `true`)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiCallGatherUsingAIRequest
*/
func (a *CallCommandsAPIService) CallGatherUsingAI(ctx context.Context, callControlId string) ApiCallGatherUsingAIRequest {
	return ApiCallGatherUsingAIRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponse
func (a *CallCommandsAPIService) CallGatherUsingAIExecute(r ApiCallGatherUsingAIRequest) (*CallControlCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.CallGatherUsingAI")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/gather_using_ai"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gatherUsingAIRequest == nil {
		return localVarReturnValue, nil, reportError("gatherUsingAIRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.gatherUsingAIRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallStartAIAssistantRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	aIAssistantStartRequest *AIAssistantStartRequest
}

// AI Assistant request
func (r ApiCallStartAIAssistantRequest) AIAssistantStartRequest(aIAssistantStartRequest AIAssistantStartRequest) ApiCallStartAIAssistantRequest {
	r.aIAssistantStartRequest = &aIAssistantStartRequest
	return r
}

func (r ApiCallStartAIAssistantRequest) Execute() (*CallControlCommandResponse, *http.Response, error) {
	return r.ApiService.CallStartAIAssistantExecute(r)
}

/*
CallStartAIAssistant Start AI Assistant

Start an AI assistant on the call.

**Expected Webhooks (see [callback schema](https://developers.telnyx.com/api/call-control/call-start-ai-assistant#callbacks) below):**

- `call.conversation_insights.generated`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiCallStartAIAssistantRequest
*/
func (a *CallCommandsAPIService) CallStartAIAssistant(ctx context.Context, callControlId string) ApiCallStartAIAssistantRequest {
	return ApiCallStartAIAssistantRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponse
func (a *CallCommandsAPIService) CallStartAIAssistantExecute(r ApiCallStartAIAssistantRequest) (*CallControlCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.CallStartAIAssistant")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/ai_assistant_start"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aIAssistantStartRequest == nil {
		return localVarReturnValue, nil, reportError("aIAssistantStartRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aIAssistantStartRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallStopAIAssistantRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	aIAssistantStopRequest *AIAssistantStopRequest
}

// AI Assistant request
func (r ApiCallStopAIAssistantRequest) AIAssistantStopRequest(aIAssistantStopRequest AIAssistantStopRequest) ApiCallStopAIAssistantRequest {
	r.aIAssistantStopRequest = &aIAssistantStopRequest
	return r
}

func (r ApiCallStopAIAssistantRequest) Execute() (*CallControlCommandResponse, *http.Response, error) {
	return r.ApiService.CallStopAIAssistantExecute(r)
}

/*
CallStopAIAssistant Stop AI Assistant

Stop an AI assistant on the call.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiCallStopAIAssistantRequest
*/
func (a *CallCommandsAPIService) CallStopAIAssistant(ctx context.Context, callControlId string) ApiCallStopAIAssistantRequest {
	return ApiCallStopAIAssistantRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponse
func (a *CallCommandsAPIService) CallStopAIAssistantExecute(r ApiCallStopAIAssistantRequest) (*CallControlCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.CallStopAIAssistant")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/ai_assistant_stop"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aIAssistantStopRequest == nil {
		return localVarReturnValue, nil, reportError("aIAssistantStopRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aIAssistantStopRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDialCallRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callRequest *CallRequest
}

// Call request
func (r ApiDialCallRequest) CallRequest(callRequest CallRequest) ApiDialCallRequest {
	r.callRequest = &callRequest
	return r
}

func (r ApiDialCallRequest) Execute() (*RetrieveCallStatusResponseWithRecordingID, *http.Response, error) {
	return r.ApiService.DialCallExecute(r)
}

/*
DialCall Dial

Dial a number or SIP URI from a given connection. A successful response will include a `call_leg_id` which can be used to correlate the command with subsequent webhooks.

**Expected Webhooks (see [schema](https://developers.telnyx.com/api/call-control/dial-call#callbacks) below):**

- `call.initiated`
- `call.answered` or `call.hangup`
- `call.machine.detection.ended` if `answering_machine_detection` was requested
- `call.machine.greeting.ended` if `answering_machine_detection` was requested to detect the end of machine greeting
- `call.machine.premium.detection.ended` if `answering_machine_detection=premium` was requested
- `call.machine.premium.greeting.ended` if `answering_machine_detection=premium` was requested and a beep was detected
- `streaming.started`, `streaming.stopped` or `streaming.failed` if `stream_url` was set

When the `record` parameter is set to `record-from-answer`, the response will include a `recording_id` field.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDialCallRequest
*/
func (a *CallCommandsAPIService) DialCall(ctx context.Context) ApiDialCallRequest {
	return ApiDialCallRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RetrieveCallStatusResponseWithRecordingID
func (a *CallCommandsAPIService) DialCallExecute(r ApiDialCallRequest) (*RetrieveCallStatusResponseWithRecordingID, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RetrieveCallStatusResponseWithRecordingID
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.DialCall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.callRequest == nil {
		return localVarReturnValue, nil, reportError("callRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.callRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnqueueCallRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	enqueueRequest *EnqueueRequest
}

// Enqueue call request
func (r ApiEnqueueCallRequest) EnqueueRequest(enqueueRequest EnqueueRequest) ApiEnqueueCallRequest {
	r.enqueueRequest = &enqueueRequest
	return r
}

func (r ApiEnqueueCallRequest) Execute() (*CallControlCommandResponse, *http.Response, error) {
	return r.ApiService.EnqueueCallExecute(r)
}

/*
EnqueueCall Enqueue call

Put the call in a queue.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiEnqueueCallRequest
*/
func (a *CallCommandsAPIService) EnqueueCall(ctx context.Context, callControlId string) ApiEnqueueCallRequest {
	return ApiEnqueueCallRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponse
func (a *CallCommandsAPIService) EnqueueCallExecute(r ApiEnqueueCallRequest) (*CallControlCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.EnqueueCall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/enqueue"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.enqueueRequest == nil {
		return localVarReturnValue, nil, reportError("enqueueRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.enqueueRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatherCallRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	gatherRequest *GatherRequest
}

// Gather
func (r ApiGatherCallRequest) GatherRequest(gatherRequest GatherRequest) ApiGatherCallRequest {
	r.gatherRequest = &gatherRequest
	return r
}

func (r ApiGatherCallRequest) Execute() (*CallControlCommandResponse, *http.Response, error) {
	return r.ApiService.GatherCallExecute(r)
}

/*
GatherCall Gather

Gather DTMF signals to build interactive menus.

You can pass a list of valid digits. The `Answer` command must be issued before the `gather` command.

**Expected Webhooks (see [callback schema](https://developers.telnyx.com/api/call-control/gather-call#callbacks) below):**

- `call.dtmf.received` (you may receive many of these webhooks)
- `call.gather.ended`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiGatherCallRequest
*/
func (a *CallCommandsAPIService) GatherCall(ctx context.Context, callControlId string) ApiGatherCallRequest {
	return ApiGatherCallRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponse
func (a *CallCommandsAPIService) GatherCallExecute(r ApiGatherCallRequest) (*CallControlCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.GatherCall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/gather"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gatherRequest == nil {
		return localVarReturnValue, nil, reportError("gatherRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.gatherRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatherUsingAudioRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	gatherUsingAudioRequest *GatherUsingAudioRequest
}

// Gather using audio request
func (r ApiGatherUsingAudioRequest) GatherUsingAudioRequest(gatherUsingAudioRequest GatherUsingAudioRequest) ApiGatherUsingAudioRequest {
	r.gatherUsingAudioRequest = &gatherUsingAudioRequest
	return r
}

func (r ApiGatherUsingAudioRequest) Execute() (*CallControlCommandResponse, *http.Response, error) {
	return r.ApiService.GatherUsingAudioExecute(r)
}

/*
GatherUsingAudio Gather using audio

Play an audio file on the call until the required DTMF signals are gathered to build interactive menus.

You can pass a list of valid digits along with an 'invalid_audio_url', which will be played back at the beginning of each prompt. Playback will be interrupted when a DTMF signal is received. The `Answer command must be issued before the `gather_using_audio` command.

**Expected Webhooks (see [callback schema](https://developers.telnyx.com/api/call-control/gather-using-audio#callbacks) below):**

- `call.playback.started`
- `call.playback.ended`
- `call.dtmf.received` (you may receive many of these webhooks)
- `call.gather.ended`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiGatherUsingAudioRequest
*/
func (a *CallCommandsAPIService) GatherUsingAudio(ctx context.Context, callControlId string) ApiGatherUsingAudioRequest {
	return ApiGatherUsingAudioRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponse
func (a *CallCommandsAPIService) GatherUsingAudioExecute(r ApiGatherUsingAudioRequest) (*CallControlCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.GatherUsingAudio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/gather_using_audio"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gatherUsingAudioRequest == nil {
		return localVarReturnValue, nil, reportError("gatherUsingAudioRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.gatherUsingAudioRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatherUsingSpeakRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	gatherUsingSpeakRequest *GatherUsingSpeakRequest
}

// Gather using speak request
func (r ApiGatherUsingSpeakRequest) GatherUsingSpeakRequest(gatherUsingSpeakRequest GatherUsingSpeakRequest) ApiGatherUsingSpeakRequest {
	r.gatherUsingSpeakRequest = &gatherUsingSpeakRequest
	return r
}

func (r ApiGatherUsingSpeakRequest) Execute() (*CallControlCommandResponse, *http.Response, error) {
	return r.ApiService.GatherUsingSpeakExecute(r)
}

/*
GatherUsingSpeak Gather using speak

Convert text to speech and play it on the call until the required DTMF signals are gathered to build interactive menus.

You can pass a list of valid digits along with an 'invalid_payload', which will be played back at the beginning of each prompt. Speech will be interrupted when a DTMF signal is received. The `Answer` command must be issued before the `gather_using_speak` command.

**Expected Webhooks (see [callback schema](https://developers.telnyx.com/api/call-control/gather-using-speak#callbacks) below):**

- `call.dtmf.received` (you may receive many of these webhooks)
- `call.gather.ended`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiGatherUsingSpeakRequest
*/
func (a *CallCommandsAPIService) GatherUsingSpeak(ctx context.Context, callControlId string) ApiGatherUsingSpeakRequest {
	return ApiGatherUsingSpeakRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponse
func (a *CallCommandsAPIService) GatherUsingSpeakExecute(r ApiGatherUsingSpeakRequest) (*CallControlCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.GatherUsingSpeak")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/gather_using_speak"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gatherUsingSpeakRequest == nil {
		return localVarReturnValue, nil, reportError("gatherUsingSpeakRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.gatherUsingSpeakRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHangupCallRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	hangupRequest *HangupRequest
}

// Hangup request
func (r ApiHangupCallRequest) HangupRequest(hangupRequest HangupRequest) ApiHangupCallRequest {
	r.hangupRequest = &hangupRequest
	return r
}

func (r ApiHangupCallRequest) Execute() (*CallControlCommandResponse, *http.Response, error) {
	return r.ApiService.HangupCallExecute(r)
}

/*
HangupCall Hangup call

Hang up the call.

**Expected Webhooks (see [callback schema](https://developers.telnyx.com/api/call-control/hangup-call#callbacks) below):**

- `call.hangup`
- `call.recording.saved`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiHangupCallRequest
*/
func (a *CallCommandsAPIService) HangupCall(ctx context.Context, callControlId string) ApiHangupCallRequest {
	return ApiHangupCallRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponse
func (a *CallCommandsAPIService) HangupCallExecute(r ApiHangupCallRequest) (*CallControlCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.HangupCall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/hangup"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hangupRequest == nil {
		return localVarReturnValue, nil, reportError("hangupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.hangupRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLeaveQueueRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	leaveQueueRequest *LeaveQueueRequest
}

// Removes the call from the queue, the call currently is enqueued in.
func (r ApiLeaveQueueRequest) LeaveQueueRequest(leaveQueueRequest LeaveQueueRequest) ApiLeaveQueueRequest {
	r.leaveQueueRequest = &leaveQueueRequest
	return r
}

func (r ApiLeaveQueueRequest) Execute() (*CallControlCommandResponse, *http.Response, error) {
	return r.ApiService.LeaveQueueExecute(r)
}

/*
LeaveQueue Remove call from a queue

Removes the call from a queue.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiLeaveQueueRequest
*/
func (a *CallCommandsAPIService) LeaveQueue(ctx context.Context, callControlId string) ApiLeaveQueueRequest {
	return ApiLeaveQueueRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponse
func (a *CallCommandsAPIService) LeaveQueueExecute(r ApiLeaveQueueRequest) (*CallControlCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.LeaveQueue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/leave_queue"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.leaveQueueRequest == nil {
		return localVarReturnValue, nil, reportError("leaveQueueRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.leaveQueueRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNoiseSuppressionStartRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	noiseSuppressionStart *NoiseSuppressionStart
}

// Start streaming media request
func (r ApiNoiseSuppressionStartRequest) NoiseSuppressionStart(noiseSuppressionStart NoiseSuppressionStart) ApiNoiseSuppressionStartRequest {
	r.noiseSuppressionStart = &noiseSuppressionStart
	return r
}

func (r ApiNoiseSuppressionStartRequest) Execute() (*CallControlCommandResponse, *http.Response, error) {
	return r.ApiService.NoiseSuppressionStartExecute(r)
}

/*
NoiseSuppressionStart Noise Suppression Start (BETA)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiNoiseSuppressionStartRequest
*/
func (a *CallCommandsAPIService) NoiseSuppressionStart(ctx context.Context, callControlId string) ApiNoiseSuppressionStartRequest {
	return ApiNoiseSuppressionStartRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponse
func (a *CallCommandsAPIService) NoiseSuppressionStartExecute(r ApiNoiseSuppressionStartRequest) (*CallControlCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.NoiseSuppressionStart")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/suppression_start"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noiseSuppressionStart == nil {
		return localVarReturnValue, nil, reportError("noiseSuppressionStart is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noiseSuppressionStart
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNoiseSuppressionStopRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	noiseSuppressionStop *NoiseSuppressionStop
}

// Start streaming media request
func (r ApiNoiseSuppressionStopRequest) NoiseSuppressionStop(noiseSuppressionStop NoiseSuppressionStop) ApiNoiseSuppressionStopRequest {
	r.noiseSuppressionStop = &noiseSuppressionStop
	return r
}

func (r ApiNoiseSuppressionStopRequest) Execute() (*CallControlCommandResponse, *http.Response, error) {
	return r.ApiService.NoiseSuppressionStopExecute(r)
}

/*
NoiseSuppressionStop Noise Suppression Stop (BETA)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiNoiseSuppressionStopRequest
*/
func (a *CallCommandsAPIService) NoiseSuppressionStop(ctx context.Context, callControlId string) ApiNoiseSuppressionStopRequest {
	return ApiNoiseSuppressionStopRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponse
func (a *CallCommandsAPIService) NoiseSuppressionStopExecute(r ApiNoiseSuppressionStopRequest) (*CallControlCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.NoiseSuppressionStop")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/suppression_stop"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noiseSuppressionStop == nil {
		return localVarReturnValue, nil, reportError("noiseSuppressionStop is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noiseSuppressionStop
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPauseCallRecordingRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	pauseRecordingRequest *PauseRecordingRequest
}

// Pause recording call request
func (r ApiPauseCallRecordingRequest) PauseRecordingRequest(pauseRecordingRequest PauseRecordingRequest) ApiPauseCallRecordingRequest {
	r.pauseRecordingRequest = &pauseRecordingRequest
	return r
}

func (r ApiPauseCallRecordingRequest) Execute() (*CallControlCommandResponse, *http.Response, error) {
	return r.ApiService.PauseCallRecordingExecute(r)
}

/*
PauseCallRecording Record pause

Pause recording the call. Recording can be resumed via Resume recording command.

**Expected Webhooks:**

There are no webhooks associated with this command.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiPauseCallRecordingRequest
*/
func (a *CallCommandsAPIService) PauseCallRecording(ctx context.Context, callControlId string) ApiPauseCallRecordingRequest {
	return ApiPauseCallRecordingRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponse
func (a *CallCommandsAPIService) PauseCallRecordingExecute(r ApiPauseCallRecordingRequest) (*CallControlCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.PauseCallRecording")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/record_pause"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pauseRecordingRequest == nil {
		return localVarReturnValue, nil, reportError("pauseRecordingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pauseRecordingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReferCallRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	referRequest *ReferRequest
}

// Refer request
func (r ApiReferCallRequest) ReferRequest(referRequest ReferRequest) ApiReferCallRequest {
	r.referRequest = &referRequest
	return r
}

func (r ApiReferCallRequest) Execute() (*CallControlCommandResponse, *http.Response, error) {
	return r.ApiService.ReferCallExecute(r)
}

/*
ReferCall SIP Refer a call

Initiate a SIP Refer on a Call Control call. You can initiate a SIP Refer at any point in the duration of a call.

**Expected Webhooks (see [callback schema](https://developers.telnyx.com/api/call-control/refer-call#callbacks) below):**

- `call.refer.started`
- `call.refer.completed`
- `call.refer.failed`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiReferCallRequest
*/
func (a *CallCommandsAPIService) ReferCall(ctx context.Context, callControlId string) ApiReferCallRequest {
	return ApiReferCallRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponse
func (a *CallCommandsAPIService) ReferCallExecute(r ApiReferCallRequest) (*CallControlCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.ReferCall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/refer"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.referRequest == nil {
		return localVarReturnValue, nil, reportError("referRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.referRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRejectCallRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	rejectRequest *RejectRequest
}

// Reject request
func (r ApiRejectCallRequest) RejectRequest(rejectRequest RejectRequest) ApiRejectCallRequest {
	r.rejectRequest = &rejectRequest
	return r
}

func (r ApiRejectCallRequest) Execute() (*CallControlCommandResponse, *http.Response, error) {
	return r.ApiService.RejectCallExecute(r)
}

/*
RejectCall Reject a call

Reject an incoming call.

**Expected Webhooks (see [callback schema](https://developers.telnyx.com/api/call-control/reject-call#callbacks) below):**

- `call.hangup`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiRejectCallRequest
*/
func (a *CallCommandsAPIService) RejectCall(ctx context.Context, callControlId string) ApiRejectCallRequest {
	return ApiRejectCallRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponse
func (a *CallCommandsAPIService) RejectCallExecute(r ApiRejectCallRequest) (*CallControlCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.RejectCall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/reject"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rejectRequest == nil {
		return localVarReturnValue, nil, reportError("rejectRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rejectRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResumeCallRecordingRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	resumeRecordingRequest *ResumeRecordingRequest
}

// Resume recording call request
func (r ApiResumeCallRecordingRequest) ResumeRecordingRequest(resumeRecordingRequest ResumeRecordingRequest) ApiResumeCallRecordingRequest {
	r.resumeRecordingRequest = &resumeRecordingRequest
	return r
}

func (r ApiResumeCallRecordingRequest) Execute() (*CallControlCommandResponse, *http.Response, error) {
	return r.ApiService.ResumeCallRecordingExecute(r)
}

/*
ResumeCallRecording Record resume

Resume recording the call.

**Expected Webhooks:**

There are no webhooks associated with this command.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiResumeCallRecordingRequest
*/
func (a *CallCommandsAPIService) ResumeCallRecording(ctx context.Context, callControlId string) ApiResumeCallRecordingRequest {
	return ApiResumeCallRecordingRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponse
func (a *CallCommandsAPIService) ResumeCallRecordingExecute(r ApiResumeCallRecordingRequest) (*CallControlCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.ResumeCallRecording")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/record_resume"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.resumeRecordingRequest == nil {
		return localVarReturnValue, nil, reportError("resumeRecordingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resumeRecordingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendDTMFRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	sendDTMFRequest *SendDTMFRequest
}

// Send DTMF request
func (r ApiSendDTMFRequest) SendDTMFRequest(sendDTMFRequest SendDTMFRequest) ApiSendDTMFRequest {
	r.sendDTMFRequest = &sendDTMFRequest
	return r
}

func (r ApiSendDTMFRequest) Execute() (*CallControlCommandResponse, *http.Response, error) {
	return r.ApiService.SendDTMFExecute(r)
}

/*
SendDTMF Send DTMF

Sends DTMF tones from this leg. DTMF tones will be heard by the other end of the call.

**Expected Webhooks:**

There are no webhooks associated with this command.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiSendDTMFRequest
*/
func (a *CallCommandsAPIService) SendDTMF(ctx context.Context, callControlId string) ApiSendDTMFRequest {
	return ApiSendDTMFRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponse
func (a *CallCommandsAPIService) SendDTMFExecute(r ApiSendDTMFRequest) (*CallControlCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.SendDTMF")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/send_dtmf"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sendDTMFRequest == nil {
		return localVarReturnValue, nil, reportError("sendDTMFRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sendDTMFRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendSIPInfoRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	sendSIPInfoRequest *SendSIPInfoRequest
}

// Send SIP INFO request
func (r ApiSendSIPInfoRequest) SendSIPInfoRequest(sendSIPInfoRequest SendSIPInfoRequest) ApiSendSIPInfoRequest {
	r.sendSIPInfoRequest = &sendSIPInfoRequest
	return r
}

func (r ApiSendSIPInfoRequest) Execute() (*CallControlCommandResponse, *http.Response, error) {
	return r.ApiService.SendSIPInfoExecute(r)
}

/*
SendSIPInfo Send SIP info

Sends SIP info from this leg.

**Expected Webhooks:**

- `call.sip_info.received` (to be received on the target call leg)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiSendSIPInfoRequest
*/
func (a *CallCommandsAPIService) SendSIPInfo(ctx context.Context, callControlId string) ApiSendSIPInfoRequest {
	return ApiSendSIPInfoRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponse
func (a *CallCommandsAPIService) SendSIPInfoExecute(r ApiSendSIPInfoRequest) (*CallControlCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.SendSIPInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/send_sip_info"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sendSIPInfoRequest == nil {
		return localVarReturnValue, nil, reportError("sendSIPInfoRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sendSIPInfoRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSpeakCallRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	speakRequest *SpeakRequest
}

// Speak request
func (r ApiSpeakCallRequest) SpeakRequest(speakRequest SpeakRequest) ApiSpeakCallRequest {
	r.speakRequest = &speakRequest
	return r
}

func (r ApiSpeakCallRequest) Execute() (*CallControlCommandResponse, *http.Response, error) {
	return r.ApiService.SpeakCallExecute(r)
}

/*
SpeakCall Speak text

Convert text to speech and play it back on the call. If multiple speak text commands are issued consecutively, the audio files will be placed in a queue awaiting playback.

**Expected Webhooks (see [callback schema](https://developers.telnyx.com/api/call-control/speak-call#callbacks) below):**

- `call.speak.started`
- `call.speak.ended`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiSpeakCallRequest
*/
func (a *CallCommandsAPIService) SpeakCall(ctx context.Context, callControlId string) ApiSpeakCallRequest {
	return ApiSpeakCallRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponse
func (a *CallCommandsAPIService) SpeakCallExecute(r ApiSpeakCallRequest) (*CallControlCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.SpeakCall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/speak"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.speakRequest == nil {
		return localVarReturnValue, nil, reportError("speakRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.speakRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartCallForkRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	startForkingRequest *StartForkingRequest
}

// Fork media request
func (r ApiStartCallForkRequest) StartForkingRequest(startForkingRequest StartForkingRequest) ApiStartCallForkRequest {
	r.startForkingRequest = &startForkingRequest
	return r
}

func (r ApiStartCallForkRequest) Execute() (*CallControlCommandResponse, *http.Response, error) {
	return r.ApiService.StartCallForkExecute(r)
}

/*
StartCallFork Forking start

Call forking allows you to stream the media from a call to a specific target in realtime. 
This stream can be used to enable realtime audio analysis to support a 
variety of use cases, including fraud detection, or the creation of AI-generated audio responses. 
Requests must specify either the `target` attribute or the `rx` and `tx` attributes.

**Expected Webhooks (see [callback schema](https://developers.telnyx.com/api/call-control/start-call-fork#callbacks) below):**

- `call.fork.started`
- `call.fork.stopped`



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiStartCallForkRequest
*/
func (a *CallCommandsAPIService) StartCallFork(ctx context.Context, callControlId string) ApiStartCallForkRequest {
	return ApiStartCallForkRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponse
func (a *CallCommandsAPIService) StartCallForkExecute(r ApiStartCallForkRequest) (*CallControlCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.StartCallFork")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/fork_start"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startForkingRequest == nil {
		return localVarReturnValue, nil, reportError("startForkingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.startForkingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartCallPlaybackRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	playAudioUrlRequest *PlayAudioUrlRequest
}

// Play audio URL request
func (r ApiStartCallPlaybackRequest) PlayAudioUrlRequest(playAudioUrlRequest PlayAudioUrlRequest) ApiStartCallPlaybackRequest {
	r.playAudioUrlRequest = &playAudioUrlRequest
	return r
}

func (r ApiStartCallPlaybackRequest) Execute() (*CallControlCommandResponse, *http.Response, error) {
	return r.ApiService.StartCallPlaybackExecute(r)
}

/*
StartCallPlayback Play audio URL

Play an audio file on the call. If multiple play audio commands are issued consecutively,
the audio files will be placed in a queue awaiting playback.

*Notes:*

- When `overlay` is enabled, `target_legs` is limited to `self`.
- A customer cannot Play Audio with `overlay=true` unless there is a Play Audio with `overlay=false` actively playing.

**Expected Webhooks (see [callback schema](https://developers.telnyx.com/api/call-control/start-call-playback#callbacks) below):**

- `call.playback.started`
- `call.playback.ended`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiStartCallPlaybackRequest
*/
func (a *CallCommandsAPIService) StartCallPlayback(ctx context.Context, callControlId string) ApiStartCallPlaybackRequest {
	return ApiStartCallPlaybackRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponse
func (a *CallCommandsAPIService) StartCallPlaybackExecute(r ApiStartCallPlaybackRequest) (*CallControlCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.StartCallPlayback")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/playback_start"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.playAudioUrlRequest == nil {
		return localVarReturnValue, nil, reportError("playAudioUrlRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.playAudioUrlRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartCallRecordRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	startRecordingRequest *StartRecordingRequest
}

// Start recording audio request
func (r ApiStartCallRecordRequest) StartRecordingRequest(startRecordingRequest StartRecordingRequest) ApiStartCallRecordRequest {
	r.startRecordingRequest = &startRecordingRequest
	return r
}

func (r ApiStartCallRecordRequest) Execute() (*CallControlCommandResponse, *http.Response, error) {
	return r.ApiService.StartCallRecordExecute(r)
}

/*
StartCallRecord Recording start

Start recording the call. Recording will stop on call hang-up, or can be initiated via the Stop Recording command.

**Expected Webhooks (see [callback schema](https://developers.telnyx.com/api/call-control/start-call-record#callbacks) below):**

- `call.recording.saved`
- `call.recording.transcription.saved`
- `call.recording.error`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiStartCallRecordRequest
*/
func (a *CallCommandsAPIService) StartCallRecord(ctx context.Context, callControlId string) ApiStartCallRecordRequest {
	return ApiStartCallRecordRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponse
func (a *CallCommandsAPIService) StartCallRecordExecute(r ApiStartCallRecordRequest) (*CallControlCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.StartCallRecord")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/record_start"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startRecordingRequest == nil {
		return localVarReturnValue, nil, reportError("startRecordingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.startRecordingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartCallStreamingRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	startStreamingRequest *StartStreamingRequest
}

// Start streaming media request
func (r ApiStartCallStreamingRequest) StartStreamingRequest(startStreamingRequest StartStreamingRequest) ApiStartCallStreamingRequest {
	r.startStreamingRequest = &startStreamingRequest
	return r
}

func (r ApiStartCallStreamingRequest) Execute() (*CallControlCommandResponse, *http.Response, error) {
	return r.ApiService.StartCallStreamingExecute(r)
}

/*
StartCallStreaming Streaming start

Start streaming the media from a call to a specific WebSocket address or Dialogflow connection in near-realtime. Audio will be delivered as base64-encoded RTP payload (raw audio), wrapped in JSON payloads.

Please find more details about media streaming messages specification under the [link](https://developers.telnyx.com/docs/voice/programmable-voice/media-streaming).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiStartCallStreamingRequest
*/
func (a *CallCommandsAPIService) StartCallStreaming(ctx context.Context, callControlId string) ApiStartCallStreamingRequest {
	return ApiStartCallStreamingRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponse
func (a *CallCommandsAPIService) StartCallStreamingExecute(r ApiStartCallStreamingRequest) (*CallControlCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.StartCallStreaming")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/streaming_start"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startStreamingRequest == nil {
		return localVarReturnValue, nil, reportError("startStreamingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.startStreamingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartCallTranscriptionRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	transcriptionStartRequest *TranscriptionStartRequest
}

// Transcription start request
func (r ApiStartCallTranscriptionRequest) TranscriptionStartRequest(transcriptionStartRequest TranscriptionStartRequest) ApiStartCallTranscriptionRequest {
	r.transcriptionStartRequest = &transcriptionStartRequest
	return r
}

func (r ApiStartCallTranscriptionRequest) Execute() (*CallControlCommandResponse, *http.Response, error) {
	return r.ApiService.StartCallTranscriptionExecute(r)
}

/*
StartCallTranscription Transcription start

Start real-time transcription. Transcription will stop on call hang-up, or can be initiated via the Transcription stop command.

**Expected Webhooks (see [callback schema](https://developers.telnyx.com/api/call-control/start-call-transcription#callbacks) below):**

- `call.transcription`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiStartCallTranscriptionRequest
*/
func (a *CallCommandsAPIService) StartCallTranscription(ctx context.Context, callControlId string) ApiStartCallTranscriptionRequest {
	return ApiStartCallTranscriptionRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponse
func (a *CallCommandsAPIService) StartCallTranscriptionExecute(r ApiStartCallTranscriptionRequest) (*CallControlCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.StartCallTranscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/transcription_start"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.transcriptionStartRequest == nil {
		return localVarReturnValue, nil, reportError("transcriptionStartRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.transcriptionStartRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartSiprecSessionRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	startSiprecRequest *StartSiprecRequest
}

// Start siprec session to configured in SIPREC connector SRS.
func (r ApiStartSiprecSessionRequest) StartSiprecRequest(startSiprecRequest StartSiprecRequest) ApiStartSiprecSessionRequest {
	r.startSiprecRequest = &startSiprecRequest
	return r
}

func (r ApiStartSiprecSessionRequest) Execute() (*CallControlCommandResponse, *http.Response, error) {
	return r.ApiService.StartSiprecSessionExecute(r)
}

/*
StartSiprecSession SIPREC start

Start siprec session to configured in SIPREC connector SRS. 

**Expected Webhooks:**

- `siprec.started`
- `siprec.stopped`
- `siprec.failed`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiStartSiprecSessionRequest
*/
func (a *CallCommandsAPIService) StartSiprecSession(ctx context.Context, callControlId string) ApiStartSiprecSessionRequest {
	return ApiStartSiprecSessionRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponse
func (a *CallCommandsAPIService) StartSiprecSessionExecute(r ApiStartSiprecSessionRequest) (*CallControlCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.StartSiprecSession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/siprec_start"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startSiprecRequest == nil {
		return localVarReturnValue, nil, reportError("startSiprecRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.startSiprecRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStopCallForkRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	stopForkingRequest *StopForkingRequest
}

// Stop forking media request
func (r ApiStopCallForkRequest) StopForkingRequest(stopForkingRequest StopForkingRequest) ApiStopCallForkRequest {
	r.stopForkingRequest = &stopForkingRequest
	return r
}

func (r ApiStopCallForkRequest) Execute() (*CallControlCommandResponse, *http.Response, error) {
	return r.ApiService.StopCallForkExecute(r)
}

/*
StopCallFork Forking stop

Stop forking a call.

**Expected Webhooks (see [callback schema](https://developers.telnyx.com/api/call-control/stop-call-fork#callbacks) below):**

- `call.fork.stopped`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiStopCallForkRequest
*/
func (a *CallCommandsAPIService) StopCallFork(ctx context.Context, callControlId string) ApiStopCallForkRequest {
	return ApiStopCallForkRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponse
func (a *CallCommandsAPIService) StopCallForkExecute(r ApiStopCallForkRequest) (*CallControlCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.StopCallFork")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/fork_stop"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.stopForkingRequest == nil {
		return localVarReturnValue, nil, reportError("stopForkingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.stopForkingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStopCallGatherRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	stopGatherRequest *StopGatherRequest
}

// Stop current gather
func (r ApiStopCallGatherRequest) StopGatherRequest(stopGatherRequest StopGatherRequest) ApiStopCallGatherRequest {
	r.stopGatherRequest = &stopGatherRequest
	return r
}

func (r ApiStopCallGatherRequest) Execute() (*CallControlCommandResponse, *http.Response, error) {
	return r.ApiService.StopCallGatherExecute(r)
}

/*
StopCallGather Gather stop

Stop current gather.

**Expected Webhooks (see [callback schema](https://developers.telnyx.com/api/call-control/stop-call-gather#callbacks) below):**

- `call.gather.ended`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiStopCallGatherRequest
*/
func (a *CallCommandsAPIService) StopCallGather(ctx context.Context, callControlId string) ApiStopCallGatherRequest {
	return ApiStopCallGatherRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponse
func (a *CallCommandsAPIService) StopCallGatherExecute(r ApiStopCallGatherRequest) (*CallControlCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.StopCallGather")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/gather_stop"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.stopGatherRequest == nil {
		return localVarReturnValue, nil, reportError("stopGatherRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.stopGatherRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStopCallPlaybackRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	playbackStopRequest *PlaybackStopRequest
}

// Stop audio playback request
func (r ApiStopCallPlaybackRequest) PlaybackStopRequest(playbackStopRequest PlaybackStopRequest) ApiStopCallPlaybackRequest {
	r.playbackStopRequest = &playbackStopRequest
	return r
}

func (r ApiStopCallPlaybackRequest) Execute() (*CallControlCommandResponse, *http.Response, error) {
	return r.ApiService.StopCallPlaybackExecute(r)
}

/*
StopCallPlayback Stop audio playback

Stop audio being played on the call.

**Expected Webhooks (see [callback schema](https://developers.telnyx.com/api/call-control/stop-call-playback#callbacks) below):**

- `call.playback.ended` or `call.speak.ended`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiStopCallPlaybackRequest
*/
func (a *CallCommandsAPIService) StopCallPlayback(ctx context.Context, callControlId string) ApiStopCallPlaybackRequest {
	return ApiStopCallPlaybackRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponse
func (a *CallCommandsAPIService) StopCallPlaybackExecute(r ApiStopCallPlaybackRequest) (*CallControlCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.StopCallPlayback")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/playback_stop"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.playbackStopRequest == nil {
		return localVarReturnValue, nil, reportError("playbackStopRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.playbackStopRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStopCallRecordingRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	stopRecordingRequest *StopRecordingRequest
}

// Stop recording call request
func (r ApiStopCallRecordingRequest) StopRecordingRequest(stopRecordingRequest StopRecordingRequest) ApiStopCallRecordingRequest {
	r.stopRecordingRequest = &stopRecordingRequest
	return r
}

func (r ApiStopCallRecordingRequest) Execute() (*CallControlCommandResponse, *http.Response, error) {
	return r.ApiService.StopCallRecordingExecute(r)
}

/*
StopCallRecording Recording stop

Stop recording the call.

**Expected Webhooks (see [callback schema](https://developers.telnyx.com/api/call-control/stop-call-recording#callbacks) below):**

- `call.recording.saved`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiStopCallRecordingRequest
*/
func (a *CallCommandsAPIService) StopCallRecording(ctx context.Context, callControlId string) ApiStopCallRecordingRequest {
	return ApiStopCallRecordingRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponse
func (a *CallCommandsAPIService) StopCallRecordingExecute(r ApiStopCallRecordingRequest) (*CallControlCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.StopCallRecording")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/record_stop"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.stopRecordingRequest == nil {
		return localVarReturnValue, nil, reportError("stopRecordingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.stopRecordingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStopCallStreamingRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	stopStreamingRequest *StopStreamingRequest
}

// Stop streaming media request
func (r ApiStopCallStreamingRequest) StopStreamingRequest(stopStreamingRequest StopStreamingRequest) ApiStopCallStreamingRequest {
	r.stopStreamingRequest = &stopStreamingRequest
	return r
}

func (r ApiStopCallStreamingRequest) Execute() (*CallControlCommandResponse, *http.Response, error) {
	return r.ApiService.StopCallStreamingExecute(r)
}

/*
StopCallStreaming Streaming stop

Stop streaming a call to a WebSocket.

**Expected Webhooks (see [callback schema](https://developers.telnyx.com/api/call-control/stop-call-streaming#callbacks) below):**

- `streaming.stopped`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiStopCallStreamingRequest
*/
func (a *CallCommandsAPIService) StopCallStreaming(ctx context.Context, callControlId string) ApiStopCallStreamingRequest {
	return ApiStopCallStreamingRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponse
func (a *CallCommandsAPIService) StopCallStreamingExecute(r ApiStopCallStreamingRequest) (*CallControlCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.StopCallStreaming")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/streaming_stop"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.stopStreamingRequest == nil {
		return localVarReturnValue, nil, reportError("stopStreamingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.stopStreamingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStopCallTranscriptionRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	transcriptionStopRequest *TranscriptionStopRequest
}

// Transcription stop request
func (r ApiStopCallTranscriptionRequest) TranscriptionStopRequest(transcriptionStopRequest TranscriptionStopRequest) ApiStopCallTranscriptionRequest {
	r.transcriptionStopRequest = &transcriptionStopRequest
	return r
}

func (r ApiStopCallTranscriptionRequest) Execute() (*CallControlCommandResponse, *http.Response, error) {
	return r.ApiService.StopCallTranscriptionExecute(r)
}

/*
StopCallTranscription Transcription stop

Stop real-time transcription.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiStopCallTranscriptionRequest
*/
func (a *CallCommandsAPIService) StopCallTranscription(ctx context.Context, callControlId string) ApiStopCallTranscriptionRequest {
	return ApiStopCallTranscriptionRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponse
func (a *CallCommandsAPIService) StopCallTranscriptionExecute(r ApiStopCallTranscriptionRequest) (*CallControlCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.StopCallTranscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/transcription_stop"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.transcriptionStopRequest == nil {
		return localVarReturnValue, nil, reportError("transcriptionStopRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.transcriptionStopRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStopSiprecSessionRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	stopSiprecRequest *StopSiprecRequest
}

// Stop siprec session
func (r ApiStopSiprecSessionRequest) StopSiprecRequest(stopSiprecRequest StopSiprecRequest) ApiStopSiprecSessionRequest {
	r.stopSiprecRequest = &stopSiprecRequest
	return r
}

func (r ApiStopSiprecSessionRequest) Execute() (*CallControlCommandResponse, *http.Response, error) {
	return r.ApiService.StopSiprecSessionExecute(r)
}

/*
StopSiprecSession SIPREC stop

Stop SIPREC session.

**Expected Webhooks:**

- `siprec.stopped`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiStopSiprecSessionRequest
*/
func (a *CallCommandsAPIService) StopSiprecSession(ctx context.Context, callControlId string) ApiStopSiprecSessionRequest {
	return ApiStopSiprecSessionRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponse
func (a *CallCommandsAPIService) StopSiprecSessionExecute(r ApiStopSiprecSessionRequest) (*CallControlCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.StopSiprecSession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/siprec_stop"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.stopSiprecRequest == nil {
		return localVarReturnValue, nil, reportError("stopSiprecRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.stopSiprecRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTransferCallRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	transferCallRequest *TransferCallRequest
}

// Transfer call request
func (r ApiTransferCallRequest) TransferCallRequest(transferCallRequest TransferCallRequest) ApiTransferCallRequest {
	r.transferCallRequest = &transferCallRequest
	return r
}

func (r ApiTransferCallRequest) Execute() (*CallControlCommandResponse, *http.Response, error) {
	return r.ApiService.TransferCallExecute(r)
}

/*
TransferCall Transfer call

Transfer a call to a new destination. If the transfer is unsuccessful, a `call.hangup` webhook for the other call (Leg B) will be sent indicating that the transfer could not be completed. The original call will remain active and may be issued additional commands, potentially transfering the call to an alternate destination.

**Expected Webhooks (see [callback schema](https://developers.telnyx.com/api/call-control/transfer-call#callbacks) below):**

- `call.initiated`
- `call.bridged` to Leg B
- `call.answered` or `call.hangup`
- `call.machine.detection.ended` if `answering_machine_detection` was requested
- `call.machine.greeting.ended` if `answering_machine_detection` was requested to detect the end of machine greeting
- `call.machine.premium.detection.ended` if `answering_machine_detection=premium` was requested
- `call.machine.premium.greeting.ended` if `answering_machine_detection=premium` was requested and a beep was detected


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiTransferCallRequest
*/
func (a *CallCommandsAPIService) TransferCall(ctx context.Context, callControlId string) ApiTransferCallRequest {
	return ApiTransferCallRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponse
func (a *CallCommandsAPIService) TransferCallExecute(r ApiTransferCallRequest) (*CallControlCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.TransferCall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/transfer"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.transferCallRequest == nil {
		return localVarReturnValue, nil, reportError("transferCallRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.transferCallRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateClientStateRequest struct {
	ctx context.Context
	ApiService *CallCommandsAPIService
	callControlId string
	clientStateUpdateRequest *ClientStateUpdateRequest
}

// Updates client state for every subsequent webhook
func (r ApiUpdateClientStateRequest) ClientStateUpdateRequest(clientStateUpdateRequest ClientStateUpdateRequest) ApiUpdateClientStateRequest {
	r.clientStateUpdateRequest = &clientStateUpdateRequest
	return r
}

func (r ApiUpdateClientStateRequest) Execute() (*CallControlCommandResponse, *http.Response, error) {
	return r.ApiService.UpdateClientStateExecute(r)
}

/*
UpdateClientState Update client state

Updates client state

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callControlId Unique identifier and token for controlling the call
 @return ApiUpdateClientStateRequest
*/
func (a *CallCommandsAPIService) UpdateClientState(ctx context.Context, callControlId string) ApiUpdateClientStateRequest {
	return ApiUpdateClientStateRequest{
		ApiService: a,
		ctx: ctx,
		callControlId: callControlId,
	}
}

// Execute executes the request
//  @return CallControlCommandResponse
func (a *CallCommandsAPIService) UpdateClientStateExecute(r ApiUpdateClientStateRequest) (*CallControlCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallControlCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallCommandsAPIService.UpdateClientState")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/{call_control_id}/actions/client_state_update"
	localVarPath = strings.Replace(localVarPath, "{"+"call_control_id"+"}", url.PathEscape(parameterValueToString(r.callControlId, "callControlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clientStateUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("clientStateUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.clientStateUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
