/*
Telnyx API

SIP trunking, SMS, MMS, Call Control and Telephony Data Services.

API version: 2.0.0
Contact: support@telnyx.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package telnyx

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// RoomsAPIService RoomsAPI service
type RoomsAPIService service

type ApiCreateRoomRequest struct {
	ctx context.Context
	ApiService *RoomsAPIService
	createRoomRequest *CreateRoomRequest
}

// Parameters that can be defined during room creation.
func (r ApiCreateRoomRequest) CreateRoomRequest(createRoomRequest CreateRoomRequest) ApiCreateRoomRequest {
	r.createRoomRequest = &createRoomRequest
	return r
}

func (r ApiCreateRoomRequest) Execute() (*CreateRoom201Response, *http.Response, error) {
	return r.ApiService.CreateRoomExecute(r)
}

/*
CreateRoom Create a room.

Synchronously create a Room.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateRoomRequest
*/
func (a *RoomsAPIService) CreateRoom(ctx context.Context) ApiCreateRoomRequest {
	return ApiCreateRoomRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateRoom201Response
func (a *RoomsAPIService) CreateRoomExecute(r ApiCreateRoomRequest) (*CreateRoom201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateRoom201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomsAPIService.CreateRoom")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rooms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createRoomRequest == nil {
		return localVarReturnValue, nil, reportError("createRoomRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createRoomRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteRoomRequest struct {
	ctx context.Context
	ApiService *RoomsAPIService
	roomId string
}

func (r ApiDeleteRoomRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRoomExecute(r)
}

/*
DeleteRoom Delete a room.

Synchronously delete a Room. Participants from that room will be kicked out, they won't be able to join that room anymore, and you won't be charged anymore for that room.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomId The unique identifier of a room.
 @return ApiDeleteRoomRequest
*/
func (a *RoomsAPIService) DeleteRoom(ctx context.Context, roomId string) ApiDeleteRoomRequest {
	return ApiDeleteRoomRequest{
		ApiService: a,
		ctx: ctx,
		roomId: roomId,
	}
}

// Execute executes the request
func (a *RoomsAPIService) DeleteRoomExecute(r ApiDeleteRoomRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomsAPIService.DeleteRoom")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rooms/{room_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"room_id"+"}", url.PathEscape(parameterValueToString(r.roomId, "roomId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListRoomsRequest struct {
	ctx context.Context
	ApiService *RoomsAPIService
	filterDateCreatedAtEq *string
	filterDateCreatedAtGte *string
	filterDateCreatedAtLte *string
	filterDateUpdatedAtEq *string
	filterDateUpdatedAtGte *string
	filterDateUpdatedAtLte *string
	filterUniqueName *string
	includeSessions *bool
	pageSize *int32
	pageNumber *int32
}

// ISO 8601 date for filtering rooms created on that date.
func (r ApiListRoomsRequest) FilterDateCreatedAtEq(filterDateCreatedAtEq string) ApiListRoomsRequest {
	r.filterDateCreatedAtEq = &filterDateCreatedAtEq
	return r
}

// ISO 8601 date for filtering rooms created after that date.
func (r ApiListRoomsRequest) FilterDateCreatedAtGte(filterDateCreatedAtGte string) ApiListRoomsRequest {
	r.filterDateCreatedAtGte = &filterDateCreatedAtGte
	return r
}

// ISO 8601 date for filtering rooms created before that date.
func (r ApiListRoomsRequest) FilterDateCreatedAtLte(filterDateCreatedAtLte string) ApiListRoomsRequest {
	r.filterDateCreatedAtLte = &filterDateCreatedAtLte
	return r
}

// ISO 8601 date for filtering rooms updated on that date.
func (r ApiListRoomsRequest) FilterDateUpdatedAtEq(filterDateUpdatedAtEq string) ApiListRoomsRequest {
	r.filterDateUpdatedAtEq = &filterDateUpdatedAtEq
	return r
}

// ISO 8601 date for filtering rooms updated after that date.
func (r ApiListRoomsRequest) FilterDateUpdatedAtGte(filterDateUpdatedAtGte string) ApiListRoomsRequest {
	r.filterDateUpdatedAtGte = &filterDateUpdatedAtGte
	return r
}

// ISO 8601 date for filtering rooms updated before that date.
func (r ApiListRoomsRequest) FilterDateUpdatedAtLte(filterDateUpdatedAtLte string) ApiListRoomsRequest {
	r.filterDateUpdatedAtLte = &filterDateUpdatedAtLte
	return r
}

// Unique_name for filtering rooms.
func (r ApiListRoomsRequest) FilterUniqueName(filterUniqueName string) ApiListRoomsRequest {
	r.filterUniqueName = &filterUniqueName
	return r
}

// To decide if room sessions should be included in the response.
func (r ApiListRoomsRequest) IncludeSessions(includeSessions bool) ApiListRoomsRequest {
	r.includeSessions = &includeSessions
	return r
}

// The size of the page.
func (r ApiListRoomsRequest) PageSize(pageSize int32) ApiListRoomsRequest {
	r.pageSize = &pageSize
	return r
}

// The page number to load.
func (r ApiListRoomsRequest) PageNumber(pageNumber int32) ApiListRoomsRequest {
	r.pageNumber = &pageNumber
	return r
}

func (r ApiListRoomsRequest) Execute() (*ListRooms200Response, *http.Response, error) {
	return r.ApiService.ListRoomsExecute(r)
}

/*
ListRooms View a list of rooms.



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListRoomsRequest
*/
func (a *RoomsAPIService) ListRooms(ctx context.Context) ApiListRoomsRequest {
	return ApiListRoomsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListRooms200Response
func (a *RoomsAPIService) ListRoomsExecute(r ApiListRoomsRequest) (*ListRooms200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListRooms200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomsAPIService.ListRooms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rooms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterDateCreatedAtEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date_created_at][eq]", r.filterDateCreatedAtEq, "form", "")
	}
	if r.filterDateCreatedAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date_created_at][gte]", r.filterDateCreatedAtGte, "form", "")
	}
	if r.filterDateCreatedAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date_created_at][lte]", r.filterDateCreatedAtLte, "form", "")
	}
	if r.filterDateUpdatedAtEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date_updated_at][eq]", r.filterDateUpdatedAtEq, "form", "")
	}
	if r.filterDateUpdatedAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date_updated_at][gte]", r.filterDateUpdatedAtGte, "form", "")
	}
	if r.filterDateUpdatedAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date_updated_at][lte]", r.filterDateUpdatedAtLte, "form", "")
	}
	if r.filterUniqueName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[unique_name]", r.filterUniqueName, "form", "")
	}
	if r.includeSessions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_sessions", r.includeSessions, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrieveListRoomSessionsRequest struct {
	ctx context.Context
	ApiService *RoomsAPIService
	roomId string
	filterDateCreatedAtEq *string
	filterDateCreatedAtGte *string
	filterDateCreatedAtLte *string
	filterDateUpdatedAtEq *string
	filterDateUpdatedAtGte *string
	filterDateUpdatedAtLte *string
	filterDateEndedAtEq *string
	filterDateEndedAtGte *string
	filterDateEndedAtLte *string
	filterActive *bool
	includeParticipants *bool
	pageSize *int32
	pageNumber *int32
}

// ISO 8601 date for filtering room sessions created on that date.
func (r ApiRetrieveListRoomSessionsRequest) FilterDateCreatedAtEq(filterDateCreatedAtEq string) ApiRetrieveListRoomSessionsRequest {
	r.filterDateCreatedAtEq = &filterDateCreatedAtEq
	return r
}

// ISO 8601 date for filtering room sessions created after that date.
func (r ApiRetrieveListRoomSessionsRequest) FilterDateCreatedAtGte(filterDateCreatedAtGte string) ApiRetrieveListRoomSessionsRequest {
	r.filterDateCreatedAtGte = &filterDateCreatedAtGte
	return r
}

// ISO 8601 date for filtering room sessions created before that date.
func (r ApiRetrieveListRoomSessionsRequest) FilterDateCreatedAtLte(filterDateCreatedAtLte string) ApiRetrieveListRoomSessionsRequest {
	r.filterDateCreatedAtLte = &filterDateCreatedAtLte
	return r
}

// ISO 8601 date for filtering room sessions updated on that date.
func (r ApiRetrieveListRoomSessionsRequest) FilterDateUpdatedAtEq(filterDateUpdatedAtEq string) ApiRetrieveListRoomSessionsRequest {
	r.filterDateUpdatedAtEq = &filterDateUpdatedAtEq
	return r
}

// ISO 8601 date for filtering room sessions updated after that date.
func (r ApiRetrieveListRoomSessionsRequest) FilterDateUpdatedAtGte(filterDateUpdatedAtGte string) ApiRetrieveListRoomSessionsRequest {
	r.filterDateUpdatedAtGte = &filterDateUpdatedAtGte
	return r
}

// ISO 8601 date for filtering room sessions updated before that date.
func (r ApiRetrieveListRoomSessionsRequest) FilterDateUpdatedAtLte(filterDateUpdatedAtLte string) ApiRetrieveListRoomSessionsRequest {
	r.filterDateUpdatedAtLte = &filterDateUpdatedAtLte
	return r
}

// ISO 8601 date for filtering room sessions ended on that date.
func (r ApiRetrieveListRoomSessionsRequest) FilterDateEndedAtEq(filterDateEndedAtEq string) ApiRetrieveListRoomSessionsRequest {
	r.filterDateEndedAtEq = &filterDateEndedAtEq
	return r
}

// ISO 8601 date for filtering room sessions ended after that date.
func (r ApiRetrieveListRoomSessionsRequest) FilterDateEndedAtGte(filterDateEndedAtGte string) ApiRetrieveListRoomSessionsRequest {
	r.filterDateEndedAtGte = &filterDateEndedAtGte
	return r
}

// ISO 8601 date for filtering room sessions ended before that date.
func (r ApiRetrieveListRoomSessionsRequest) FilterDateEndedAtLte(filterDateEndedAtLte string) ApiRetrieveListRoomSessionsRequest {
	r.filterDateEndedAtLte = &filterDateEndedAtLte
	return r
}

// Filter active or inactive room sessions.
func (r ApiRetrieveListRoomSessionsRequest) FilterActive(filterActive bool) ApiRetrieveListRoomSessionsRequest {
	r.filterActive = &filterActive
	return r
}

// To decide if room participants should be included in the response.
func (r ApiRetrieveListRoomSessionsRequest) IncludeParticipants(includeParticipants bool) ApiRetrieveListRoomSessionsRequest {
	r.includeParticipants = &includeParticipants
	return r
}

// The size of the page.
func (r ApiRetrieveListRoomSessionsRequest) PageSize(pageSize int32) ApiRetrieveListRoomSessionsRequest {
	r.pageSize = &pageSize
	return r
}

// The page number to load.
func (r ApiRetrieveListRoomSessionsRequest) PageNumber(pageNumber int32) ApiRetrieveListRoomSessionsRequest {
	r.pageNumber = &pageNumber
	return r
}

func (r ApiRetrieveListRoomSessionsRequest) Execute() (*ListRoomSessions200Response, *http.Response, error) {
	return r.ApiService.RetrieveListRoomSessionsExecute(r)
}

/*
RetrieveListRoomSessions View a list of room sessions.



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomId The unique identifier of a room.
 @return ApiRetrieveListRoomSessionsRequest
*/
func (a *RoomsAPIService) RetrieveListRoomSessions(ctx context.Context, roomId string) ApiRetrieveListRoomSessionsRequest {
	return ApiRetrieveListRoomSessionsRequest{
		ApiService: a,
		ctx: ctx,
		roomId: roomId,
	}
}

// Execute executes the request
//  @return ListRoomSessions200Response
func (a *RoomsAPIService) RetrieveListRoomSessionsExecute(r ApiRetrieveListRoomSessionsRequest) (*ListRoomSessions200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListRoomSessions200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomsAPIService.RetrieveListRoomSessions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rooms/{room_id}/sessions"
	localVarPath = strings.Replace(localVarPath, "{"+"room_id"+"}", url.PathEscape(parameterValueToString(r.roomId, "roomId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterDateCreatedAtEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date_created_at][eq]", r.filterDateCreatedAtEq, "form", "")
	}
	if r.filterDateCreatedAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date_created_at][gte]", r.filterDateCreatedAtGte, "form", "")
	}
	if r.filterDateCreatedAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date_created_at][lte]", r.filterDateCreatedAtLte, "form", "")
	}
	if r.filterDateUpdatedAtEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date_updated_at][eq]", r.filterDateUpdatedAtEq, "form", "")
	}
	if r.filterDateUpdatedAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date_updated_at][gte]", r.filterDateUpdatedAtGte, "form", "")
	}
	if r.filterDateUpdatedAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date_updated_at][lte]", r.filterDateUpdatedAtLte, "form", "")
	}
	if r.filterDateEndedAtEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date_ended_at][eq]", r.filterDateEndedAtEq, "form", "")
	}
	if r.filterDateEndedAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date_ended_at][gte]", r.filterDateEndedAtGte, "form", "")
	}
	if r.filterDateEndedAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date_ended_at][lte]", r.filterDateEndedAtLte, "form", "")
	}
	if r.filterActive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[active]", r.filterActive, "form", "")
	}
	if r.includeParticipants != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_participants", r.includeParticipants, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateRoomRequest struct {
	ctx context.Context
	ApiService *RoomsAPIService
	roomId string
	patchRoomRequest *PatchRoomRequest
}

// Parameters that can be defined during room update.
func (r ApiUpdateRoomRequest) PatchRoomRequest(patchRoomRequest PatchRoomRequest) ApiUpdateRoomRequest {
	r.patchRoomRequest = &patchRoomRequest
	return r
}

func (r ApiUpdateRoomRequest) Execute() (*CreateRoom201Response, *http.Response, error) {
	return r.ApiService.UpdateRoomExecute(r)
}

/*
UpdateRoom Update a room.

Synchronously update a Room.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomId The unique identifier of a room.
 @return ApiUpdateRoomRequest
*/
func (a *RoomsAPIService) UpdateRoom(ctx context.Context, roomId string) ApiUpdateRoomRequest {
	return ApiUpdateRoomRequest{
		ApiService: a,
		ctx: ctx,
		roomId: roomId,
	}
}

// Execute executes the request
//  @return CreateRoom201Response
func (a *RoomsAPIService) UpdateRoomExecute(r ApiUpdateRoomRequest) (*CreateRoom201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateRoom201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomsAPIService.UpdateRoom")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rooms/{room_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"room_id"+"}", url.PathEscape(parameterValueToString(r.roomId, "roomId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchRoomRequest == nil {
		return localVarReturnValue, nil, reportError("patchRoomRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchRoomRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiViewRoomRequest struct {
	ctx context.Context
	ApiService *RoomsAPIService
	roomId string
	includeSessions *bool
}

// To decide if room sessions should be included in the response.
func (r ApiViewRoomRequest) IncludeSessions(includeSessions bool) ApiViewRoomRequest {
	r.includeSessions = &includeSessions
	return r
}

func (r ApiViewRoomRequest) Execute() (*CreateRoom201Response, *http.Response, error) {
	return r.ApiService.ViewRoomExecute(r)
}

/*
ViewRoom View a room.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomId The unique identifier of a room.
 @return ApiViewRoomRequest
*/
func (a *RoomsAPIService) ViewRoom(ctx context.Context, roomId string) ApiViewRoomRequest {
	return ApiViewRoomRequest{
		ApiService: a,
		ctx: ctx,
		roomId: roomId,
	}
}

// Execute executes the request
//  @return CreateRoom201Response
func (a *RoomsAPIService) ViewRoomExecute(r ApiViewRoomRequest) (*CreateRoom201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateRoom201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomsAPIService.ViewRoom")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rooms/{room_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"room_id"+"}", url.PathEscape(parameterValueToString(r.roomId, "roomId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeSessions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_sessions", r.includeSessions, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
