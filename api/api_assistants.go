/*
Telnyx API

SIP trunking, SMS, MMS, Call Control and Telephony Data Services.

API version: 2.0.0
Contact: support@telnyx.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package telnyx

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)


// AssistantsAPIService AssistantsAPI service
type AssistantsAPIService service

type ApiCreateNewAssistantPublicAssistantsPostRequest struct {
	ctx context.Context
	ApiService *AssistantsAPIService
	createAssistantRequest *CreateAssistantRequest
}

func (r ApiCreateNewAssistantPublicAssistantsPostRequest) CreateAssistantRequest(createAssistantRequest CreateAssistantRequest) ApiCreateNewAssistantPublicAssistantsPostRequest {
	r.createAssistantRequest = &createAssistantRequest
	return r
}

func (r ApiCreateNewAssistantPublicAssistantsPostRequest) Execute() (*Assistant, *http.Response, error) {
	return r.ApiService.CreateNewAssistantPublicAssistantsPostExecute(r)
}

/*
CreateNewAssistantPublicAssistantsPost Create an assistant

Create a new AI Assistant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateNewAssistantPublicAssistantsPostRequest
*/
func (a *AssistantsAPIService) CreateNewAssistantPublicAssistantsPost(ctx context.Context) ApiCreateNewAssistantPublicAssistantsPostRequest {
	return ApiCreateNewAssistantPublicAssistantsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Assistant
func (a *AssistantsAPIService) CreateNewAssistantPublicAssistantsPostExecute(r ApiCreateNewAssistantPublicAssistantsPostRequest) (*Assistant, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Assistant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssistantsAPIService.CreateNewAssistantPublicAssistantsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ai/assistants"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAssistantRequest == nil {
		return localVarReturnValue, nil, reportError("createAssistantRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAssistantRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateScheduledEventRequest struct {
	ctx context.Context
	ApiService *AssistantsAPIService
	assistantId string
	createScheduledEventRequest *CreateScheduledEventRequest
}

func (r ApiCreateScheduledEventRequest) CreateScheduledEventRequest(createScheduledEventRequest CreateScheduledEventRequest) ApiCreateScheduledEventRequest {
	r.createScheduledEventRequest = &createScheduledEventRequest
	return r
}

func (r ApiCreateScheduledEventRequest) Execute() (*ScheduledEventResponse, *http.Response, error) {
	return r.ApiService.CreateScheduledEventExecute(r)
}

/*
CreateScheduledEvent Create a scheduled event

Create a scheduled event for an assistant

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param assistantId
 @return ApiCreateScheduledEventRequest
*/
func (a *AssistantsAPIService) CreateScheduledEvent(ctx context.Context, assistantId string) ApiCreateScheduledEventRequest {
	return ApiCreateScheduledEventRequest{
		ApiService: a,
		ctx: ctx,
		assistantId: assistantId,
	}
}

// Execute executes the request
//  @return ScheduledEventResponse
func (a *AssistantsAPIService) CreateScheduledEventExecute(r ApiCreateScheduledEventRequest) (*ScheduledEventResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ScheduledEventResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssistantsAPIService.CreateScheduledEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ai/assistants/{assistant_id}/scheduled_events"
	localVarPath = strings.Replace(localVarPath, "{"+"assistant_id"+"}", url.PathEscape(parameterValueToString(r.assistantId, "assistantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createScheduledEventRequest == nil {
		return localVarReturnValue, nil, reportError("createScheduledEventRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createScheduledEventRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAssistantPublicAssistantsAssistantIdDeleteRequest struct {
	ctx context.Context
	ApiService *AssistantsAPIService
	assistantId string
}

func (r ApiDeleteAssistantPublicAssistantsAssistantIdDeleteRequest) Execute() (*AssistantDeletedResponse, *http.Response, error) {
	return r.ApiService.DeleteAssistantPublicAssistantsAssistantIdDeleteExecute(r)
}

/*
DeleteAssistantPublicAssistantsAssistantIdDelete Delete an assistant

Delete an AI Assistant by `assistant_id`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param assistantId
 @return ApiDeleteAssistantPublicAssistantsAssistantIdDeleteRequest
*/
func (a *AssistantsAPIService) DeleteAssistantPublicAssistantsAssistantIdDelete(ctx context.Context, assistantId string) ApiDeleteAssistantPublicAssistantsAssistantIdDeleteRequest {
	return ApiDeleteAssistantPublicAssistantsAssistantIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		assistantId: assistantId,
	}
}

// Execute executes the request
//  @return AssistantDeletedResponse
func (a *AssistantsAPIService) DeleteAssistantPublicAssistantsAssistantIdDeleteExecute(r ApiDeleteAssistantPublicAssistantsAssistantIdDeleteRequest) (*AssistantDeletedResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssistantDeletedResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssistantsAPIService.DeleteAssistantPublicAssistantsAssistantIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ai/assistants/{assistant_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"assistant_id"+"}", url.PathEscape(parameterValueToString(r.assistantId, "assistantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteScheduledEventRequest struct {
	ctx context.Context
	ApiService *AssistantsAPIService
	assistantId string
	eventId string
}

func (r ApiDeleteScheduledEventRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.DeleteScheduledEventExecute(r)
}

/*
DeleteScheduledEvent Delete a scheduled event

If the event is pending, this will cancel the event. Otherwise, this will simply remove the record of the event.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param assistantId
 @param eventId
 @return ApiDeleteScheduledEventRequest
*/
func (a *AssistantsAPIService) DeleteScheduledEvent(ctx context.Context, assistantId string, eventId string) ApiDeleteScheduledEventRequest {
	return ApiDeleteScheduledEventRequest{
		ApiService: a,
		ctx: ctx,
		assistantId: assistantId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return interface{}
func (a *AssistantsAPIService) DeleteScheduledEventExecute(r ApiDeleteScheduledEventRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssistantsAPIService.DeleteScheduledEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ai/assistants/{assistant_id}/scheduled_events/{event_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"assistant_id"+"}", url.PathEscape(parameterValueToString(r.assistantId, "assistantId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event_id"+"}", url.PathEscape(parameterValueToString(r.eventId, "eventId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssistantPublicAssistantsAssistantIdGetRequest struct {
	ctx context.Context
	ApiService *AssistantsAPIService
	assistantId string
	fetchDynamicVariablesFromWebhook *bool
	from *string
	to *string
	callControlId *string
}

func (r ApiGetAssistantPublicAssistantsAssistantIdGetRequest) FetchDynamicVariablesFromWebhook(fetchDynamicVariablesFromWebhook bool) ApiGetAssistantPublicAssistantsAssistantIdGetRequest {
	r.fetchDynamicVariablesFromWebhook = &fetchDynamicVariablesFromWebhook
	return r
}

func (r ApiGetAssistantPublicAssistantsAssistantIdGetRequest) From(from string) ApiGetAssistantPublicAssistantsAssistantIdGetRequest {
	r.from = &from
	return r
}

func (r ApiGetAssistantPublicAssistantsAssistantIdGetRequest) To(to string) ApiGetAssistantPublicAssistantsAssistantIdGetRequest {
	r.to = &to
	return r
}

func (r ApiGetAssistantPublicAssistantsAssistantIdGetRequest) CallControlId(callControlId string) ApiGetAssistantPublicAssistantsAssistantIdGetRequest {
	r.callControlId = &callControlId
	return r
}

func (r ApiGetAssistantPublicAssistantsAssistantIdGetRequest) Execute() (*Assistant, *http.Response, error) {
	return r.ApiService.GetAssistantPublicAssistantsAssistantIdGetExecute(r)
}

/*
GetAssistantPublicAssistantsAssistantIdGet Get an assistant

Retrieve an AI Assistant configuration by `assistant_id`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param assistantId
 @return ApiGetAssistantPublicAssistantsAssistantIdGetRequest
*/
func (a *AssistantsAPIService) GetAssistantPublicAssistantsAssistantIdGet(ctx context.Context, assistantId string) ApiGetAssistantPublicAssistantsAssistantIdGetRequest {
	return ApiGetAssistantPublicAssistantsAssistantIdGetRequest{
		ApiService: a,
		ctx: ctx,
		assistantId: assistantId,
	}
}

// Execute executes the request
//  @return Assistant
func (a *AssistantsAPIService) GetAssistantPublicAssistantsAssistantIdGetExecute(r ApiGetAssistantPublicAssistantsAssistantIdGetRequest) (*Assistant, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Assistant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssistantsAPIService.GetAssistantPublicAssistantsAssistantIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ai/assistants/{assistant_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"assistant_id"+"}", url.PathEscape(parameterValueToString(r.assistantId, "assistantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchDynamicVariablesFromWebhook != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetch_dynamic_variables_from_webhook", r.fetchDynamicVariablesFromWebhook, "form", "")
	} else {
		var defaultValue bool = false
		r.fetchDynamicVariablesFromWebhook = &defaultValue
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "form", "")
	}
	if r.to != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "form", "")
	}
	if r.callControlId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "call_control_id", r.callControlId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssistantTexmlPublicAssistantsAssistantIdTexmlGetRequest struct {
	ctx context.Context
	ApiService *AssistantsAPIService
	assistantId string
}

func (r ApiGetAssistantTexmlPublicAssistantsAssistantIdTexmlGetRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetAssistantTexmlPublicAssistantsAssistantIdTexmlGetExecute(r)
}

/*
GetAssistantTexmlPublicAssistantsAssistantIdTexmlGet Get assistant texml

Get an assistant texml by `assistant_id`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param assistantId
 @return ApiGetAssistantTexmlPublicAssistantsAssistantIdTexmlGetRequest
*/
func (a *AssistantsAPIService) GetAssistantTexmlPublicAssistantsAssistantIdTexmlGet(ctx context.Context, assistantId string) ApiGetAssistantTexmlPublicAssistantsAssistantIdTexmlGetRequest {
	return ApiGetAssistantTexmlPublicAssistantsAssistantIdTexmlGetRequest{
		ApiService: a,
		ctx: ctx,
		assistantId: assistantId,
	}
}

// Execute executes the request
//  @return string
func (a *AssistantsAPIService) GetAssistantTexmlPublicAssistantsAssistantIdTexmlGetExecute(r ApiGetAssistantTexmlPublicAssistantsAssistantIdTexmlGetRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssistantsAPIService.GetAssistantTexmlPublicAssistantsAssistantIdTexmlGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ai/assistants/{assistant_id}/texml"
	localVarPath = strings.Replace(localVarPath, "{"+"assistant_id"+"}", url.PathEscape(parameterValueToString(r.assistantId, "assistantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssistantsPublicAssistantsGetRequest struct {
	ctx context.Context
	ApiService *AssistantsAPIService
}

func (r ApiGetAssistantsPublicAssistantsGetRequest) Execute() (*AssistantsListData, *http.Response, error) {
	return r.ApiService.GetAssistantsPublicAssistantsGetExecute(r)
}

/*
GetAssistantsPublicAssistantsGet List assistants

Retrieve a list of all AI Assistants configured by the user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAssistantsPublicAssistantsGetRequest
*/
func (a *AssistantsAPIService) GetAssistantsPublicAssistantsGet(ctx context.Context) ApiGetAssistantsPublicAssistantsGetRequest {
	return ApiGetAssistantsPublicAssistantsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AssistantsListData
func (a *AssistantsAPIService) GetAssistantsPublicAssistantsGetExecute(r ApiGetAssistantsPublicAssistantsGetRequest) (*AssistantsListData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssistantsListData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssistantsAPIService.GetAssistantsPublicAssistantsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ai/assistants"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetScheduledEventRequest struct {
	ctx context.Context
	ApiService *AssistantsAPIService
	assistantId string
	eventId string
}

func (r ApiGetScheduledEventRequest) Execute() (*ScheduledEventResponse, *http.Response, error) {
	return r.ApiService.GetScheduledEventExecute(r)
}

/*
GetScheduledEvent Get a scheduled event

Retrieve a scheduled event by event ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param assistantId
 @param eventId
 @return ApiGetScheduledEventRequest
*/
func (a *AssistantsAPIService) GetScheduledEvent(ctx context.Context, assistantId string, eventId string) ApiGetScheduledEventRequest {
	return ApiGetScheduledEventRequest{
		ApiService: a,
		ctx: ctx,
		assistantId: assistantId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return ScheduledEventResponse
func (a *AssistantsAPIService) GetScheduledEventExecute(r ApiGetScheduledEventRequest) (*ScheduledEventResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ScheduledEventResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssistantsAPIService.GetScheduledEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ai/assistants/{assistant_id}/scheduled_events/{event_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"assistant_id"+"}", url.PathEscape(parameterValueToString(r.assistantId, "assistantId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event_id"+"}", url.PathEscape(parameterValueToString(r.eventId, "eventId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetScheduledEventsRequest struct {
	ctx context.Context
	ApiService *AssistantsAPIService
	assistantId string
	pageSize *int32
	pageNumber *int32
	fromDate *time.Time
	toDate *time.Time
	conversationChannel *ConversationChannelType
}

func (r ApiGetScheduledEventsRequest) PageSize(pageSize int32) ApiGetScheduledEventsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetScheduledEventsRequest) PageNumber(pageNumber int32) ApiGetScheduledEventsRequest {
	r.pageNumber = &pageNumber
	return r
}

func (r ApiGetScheduledEventsRequest) FromDate(fromDate time.Time) ApiGetScheduledEventsRequest {
	r.fromDate = &fromDate
	return r
}

func (r ApiGetScheduledEventsRequest) ToDate(toDate time.Time) ApiGetScheduledEventsRequest {
	r.toDate = &toDate
	return r
}

func (r ApiGetScheduledEventsRequest) ConversationChannel(conversationChannel ConversationChannelType) ApiGetScheduledEventsRequest {
	r.conversationChannel = &conversationChannel
	return r
}

func (r ApiGetScheduledEventsRequest) Execute() (*PaginatedScheduledEventList, *http.Response, error) {
	return r.ApiService.GetScheduledEventsExecute(r)
}

/*
GetScheduledEvents List scheduled events

Get scheduled events for an assistant with pagination and filtering

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param assistantId
 @return ApiGetScheduledEventsRequest
*/
func (a *AssistantsAPIService) GetScheduledEvents(ctx context.Context, assistantId string) ApiGetScheduledEventsRequest {
	return ApiGetScheduledEventsRequest{
		ApiService: a,
		ctx: ctx,
		assistantId: assistantId,
	}
}

// Execute executes the request
//  @return PaginatedScheduledEventList
func (a *AssistantsAPIService) GetScheduledEventsExecute(r ApiGetScheduledEventsRequest) (*PaginatedScheduledEventList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedScheduledEventList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssistantsAPIService.GetScheduledEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ai/assistants/{assistant_id}/scheduled_events"
	localVarPath = strings.Replace(localVarPath, "{"+"assistant_id"+"}", url.PathEscape(parameterValueToString(r.assistantId, "assistantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.fromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_date", r.fromDate, "form", "")
	}
	if r.toDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to_date", r.toDate, "form", "")
	}
	if r.conversationChannel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conversation_channel", r.conversationChannel, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAssistantPublicAssistantsAssistantIdPostRequest struct {
	ctx context.Context
	ApiService *AssistantsAPIService
	assistantId string
	updateAssistantRequest *UpdateAssistantRequest
}

func (r ApiUpdateAssistantPublicAssistantsAssistantIdPostRequest) UpdateAssistantRequest(updateAssistantRequest UpdateAssistantRequest) ApiUpdateAssistantPublicAssistantsAssistantIdPostRequest {
	r.updateAssistantRequest = &updateAssistantRequest
	return r
}

func (r ApiUpdateAssistantPublicAssistantsAssistantIdPostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.UpdateAssistantPublicAssistantsAssistantIdPostExecute(r)
}

/*
UpdateAssistantPublicAssistantsAssistantIdPost Update an assistant

Update an AI Assistant's attributes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param assistantId
 @return ApiUpdateAssistantPublicAssistantsAssistantIdPostRequest
*/
func (a *AssistantsAPIService) UpdateAssistantPublicAssistantsAssistantIdPost(ctx context.Context, assistantId string) ApiUpdateAssistantPublicAssistantsAssistantIdPostRequest {
	return ApiUpdateAssistantPublicAssistantsAssistantIdPostRequest{
		ApiService: a,
		ctx: ctx,
		assistantId: assistantId,
	}
}

// Execute executes the request
//  @return interface{}
func (a *AssistantsAPIService) UpdateAssistantPublicAssistantsAssistantIdPostExecute(r ApiUpdateAssistantPublicAssistantsAssistantIdPostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssistantsAPIService.UpdateAssistantPublicAssistantsAssistantIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ai/assistants/{assistant_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"assistant_id"+"}", url.PathEscape(parameterValueToString(r.assistantId, "assistantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateAssistantRequest == nil {
		return localVarReturnValue, nil, reportError("updateAssistantRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateAssistantRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
