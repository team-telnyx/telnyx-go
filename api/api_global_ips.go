/*
Telnyx API

SIP trunking, SMS, MMS, Call Control and Telephony Data Services.

API version: 2.0.0
Contact: support@telnyx.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package telnyx

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)


// GlobalIPsAPIService GlobalIPsAPI service
type GlobalIPsAPIService service

type ApiCreateGlobalIpRequest struct {
	ctx context.Context
	ApiService *GlobalIPsAPIService
	globalIP *GlobalIP
}

func (r ApiCreateGlobalIpRequest) GlobalIP(globalIP GlobalIP) ApiCreateGlobalIpRequest {
	r.globalIP = &globalIP
	return r
}

func (r ApiCreateGlobalIpRequest) Execute() (*CreateGlobalIp202Response, *http.Response, error) {
	return r.ApiService.CreateGlobalIpExecute(r)
}

/*
CreateGlobalIp Create a Global IP

Create a Global IP.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateGlobalIpRequest
*/
func (a *GlobalIPsAPIService) CreateGlobalIp(ctx context.Context) ApiCreateGlobalIpRequest {
	return ApiCreateGlobalIpRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateGlobalIp202Response
func (a *GlobalIPsAPIService) CreateGlobalIpExecute(r ApiCreateGlobalIpRequest) (*CreateGlobalIp202Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateGlobalIp202Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GlobalIPsAPIService.CreateGlobalIp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/global_ips"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.globalIP == nil {
		return localVarReturnValue, nil, reportError("globalIP is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.globalIP
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateGlobalIpAssignmentRequest struct {
	ctx context.Context
	ApiService *GlobalIPsAPIService
	globalIpAssignment *GlobalIpAssignment
}

func (r ApiCreateGlobalIpAssignmentRequest) GlobalIpAssignment(globalIpAssignment GlobalIpAssignment) ApiCreateGlobalIpAssignmentRequest {
	r.globalIpAssignment = &globalIpAssignment
	return r
}

func (r ApiCreateGlobalIpAssignmentRequest) Execute() (*CreateGlobalIpAssignment202Response, *http.Response, error) {
	return r.ApiService.CreateGlobalIpAssignmentExecute(r)
}

/*
CreateGlobalIpAssignment Create a Global IP assignment

Create a Global IP assignment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateGlobalIpAssignmentRequest
*/
func (a *GlobalIPsAPIService) CreateGlobalIpAssignment(ctx context.Context) ApiCreateGlobalIpAssignmentRequest {
	return ApiCreateGlobalIpAssignmentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateGlobalIpAssignment202Response
func (a *GlobalIPsAPIService) CreateGlobalIpAssignmentExecute(r ApiCreateGlobalIpAssignmentRequest) (*CreateGlobalIpAssignment202Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateGlobalIpAssignment202Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GlobalIPsAPIService.CreateGlobalIpAssignment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/global_ip_assignments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.globalIpAssignment == nil {
		return localVarReturnValue, nil, reportError("globalIpAssignment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.globalIpAssignment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateGlobalIpHealthCheckRequest struct {
	ctx context.Context
	ApiService *GlobalIPsAPIService
	globalIPHealthCheck *GlobalIPHealthCheck
}

func (r ApiCreateGlobalIpHealthCheckRequest) GlobalIPHealthCheck(globalIPHealthCheck GlobalIPHealthCheck) ApiCreateGlobalIpHealthCheckRequest {
	r.globalIPHealthCheck = &globalIPHealthCheck
	return r
}

func (r ApiCreateGlobalIpHealthCheckRequest) Execute() (*CreateGlobalIpHealthCheck202Response, *http.Response, error) {
	return r.ApiService.CreateGlobalIpHealthCheckExecute(r)
}

/*
CreateGlobalIpHealthCheck Create a Global IP health check

Create a Global IP health check.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateGlobalIpHealthCheckRequest
*/
func (a *GlobalIPsAPIService) CreateGlobalIpHealthCheck(ctx context.Context) ApiCreateGlobalIpHealthCheckRequest {
	return ApiCreateGlobalIpHealthCheckRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateGlobalIpHealthCheck202Response
func (a *GlobalIPsAPIService) CreateGlobalIpHealthCheckExecute(r ApiCreateGlobalIpHealthCheckRequest) (*CreateGlobalIpHealthCheck202Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateGlobalIpHealthCheck202Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GlobalIPsAPIService.CreateGlobalIpHealthCheck")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/global_ip_health_checks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.globalIPHealthCheck == nil {
		return localVarReturnValue, nil, reportError("globalIPHealthCheck is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.globalIPHealthCheck
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteGlobalIpRequest struct {
	ctx context.Context
	ApiService *GlobalIPsAPIService
	id string
}

func (r ApiDeleteGlobalIpRequest) Execute() (*CreateGlobalIp202Response, *http.Response, error) {
	return r.ApiService.DeleteGlobalIpExecute(r)
}

/*
DeleteGlobalIp Delete a Global IP

Delete a Global IP.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the resource.
 @return ApiDeleteGlobalIpRequest
*/
func (a *GlobalIPsAPIService) DeleteGlobalIp(ctx context.Context, id string) ApiDeleteGlobalIpRequest {
	return ApiDeleteGlobalIpRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreateGlobalIp202Response
func (a *GlobalIPsAPIService) DeleteGlobalIpExecute(r ApiDeleteGlobalIpRequest) (*CreateGlobalIp202Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateGlobalIp202Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GlobalIPsAPIService.DeleteGlobalIp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/global_ips/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteGlobalIpAssignmentRequest struct {
	ctx context.Context
	ApiService *GlobalIPsAPIService
	id string
}

func (r ApiDeleteGlobalIpAssignmentRequest) Execute() (*CreateGlobalIpAssignment202Response, *http.Response, error) {
	return r.ApiService.DeleteGlobalIpAssignmentExecute(r)
}

/*
DeleteGlobalIpAssignment Delete a Global IP assignment

Delete a Global IP assignment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the resource.
 @return ApiDeleteGlobalIpAssignmentRequest
*/
func (a *GlobalIPsAPIService) DeleteGlobalIpAssignment(ctx context.Context, id string) ApiDeleteGlobalIpAssignmentRequest {
	return ApiDeleteGlobalIpAssignmentRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreateGlobalIpAssignment202Response
func (a *GlobalIPsAPIService) DeleteGlobalIpAssignmentExecute(r ApiDeleteGlobalIpAssignmentRequest) (*CreateGlobalIpAssignment202Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateGlobalIpAssignment202Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GlobalIPsAPIService.DeleteGlobalIpAssignment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/global_ip_assignments/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteGlobalIpHealthCheckRequest struct {
	ctx context.Context
	ApiService *GlobalIPsAPIService
	id string
}

func (r ApiDeleteGlobalIpHealthCheckRequest) Execute() (*CreateGlobalIpHealthCheck202Response, *http.Response, error) {
	return r.ApiService.DeleteGlobalIpHealthCheckExecute(r)
}

/*
DeleteGlobalIpHealthCheck Delete a Global IP health check

Delete a Global IP health check.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the resource.
 @return ApiDeleteGlobalIpHealthCheckRequest
*/
func (a *GlobalIPsAPIService) DeleteGlobalIpHealthCheck(ctx context.Context, id string) ApiDeleteGlobalIpHealthCheckRequest {
	return ApiDeleteGlobalIpHealthCheckRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreateGlobalIpHealthCheck202Response
func (a *GlobalIPsAPIService) DeleteGlobalIpHealthCheckExecute(r ApiDeleteGlobalIpHealthCheckRequest) (*CreateGlobalIpHealthCheck202Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateGlobalIpHealthCheck202Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GlobalIPsAPIService.DeleteGlobalIpHealthCheck")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/global_ip_health_checks/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGlobalIpRequest struct {
	ctx context.Context
	ApiService *GlobalIPsAPIService
	id string
}

func (r ApiGetGlobalIpRequest) Execute() (*CreateGlobalIp202Response, *http.Response, error) {
	return r.ApiService.GetGlobalIpExecute(r)
}

/*
GetGlobalIp Retrieve a Global IP

Retrieve a Global IP.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the resource.
 @return ApiGetGlobalIpRequest
*/
func (a *GlobalIPsAPIService) GetGlobalIp(ctx context.Context, id string) ApiGetGlobalIpRequest {
	return ApiGetGlobalIpRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreateGlobalIp202Response
func (a *GlobalIPsAPIService) GetGlobalIpExecute(r ApiGetGlobalIpRequest) (*CreateGlobalIp202Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateGlobalIp202Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GlobalIPsAPIService.GetGlobalIp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/global_ips/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGlobalIpAssignmentRequest struct {
	ctx context.Context
	ApiService *GlobalIPsAPIService
	id string
}

func (r ApiGetGlobalIpAssignmentRequest) Execute() (*CreateGlobalIpAssignment202Response, *http.Response, error) {
	return r.ApiService.GetGlobalIpAssignmentExecute(r)
}

/*
GetGlobalIpAssignment Retrieve a Global IP

Retrieve a Global IP assignment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the resource.
 @return ApiGetGlobalIpAssignmentRequest
*/
func (a *GlobalIPsAPIService) GetGlobalIpAssignment(ctx context.Context, id string) ApiGetGlobalIpAssignmentRequest {
	return ApiGetGlobalIpAssignmentRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreateGlobalIpAssignment202Response
func (a *GlobalIPsAPIService) GetGlobalIpAssignmentExecute(r ApiGetGlobalIpAssignmentRequest) (*CreateGlobalIpAssignment202Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateGlobalIpAssignment202Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GlobalIPsAPIService.GetGlobalIpAssignment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/global_ip_assignments/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGlobalIpAssignmentHealthRequest struct {
	ctx context.Context
	ApiService *GlobalIPsAPIService
	filterGlobalIpIdIn *string
	filterGlobalIpAssignmentIdIn *string
	filterTimestampGt *time.Time
	filterTimestampLt *time.Time
}

// Filter by Global IP ID(s) separated by commas
func (r ApiGetGlobalIpAssignmentHealthRequest) FilterGlobalIpIdIn(filterGlobalIpIdIn string) ApiGetGlobalIpAssignmentHealthRequest {
	r.filterGlobalIpIdIn = &filterGlobalIpIdIn
	return r
}

// Filter by Global IP Assignment ID(s) separated by commas
func (r ApiGetGlobalIpAssignmentHealthRequest) FilterGlobalIpAssignmentIdIn(filterGlobalIpAssignmentIdIn string) ApiGetGlobalIpAssignmentHealthRequest {
	r.filterGlobalIpAssignmentIdIn = &filterGlobalIpAssignmentIdIn
	return r
}

// Filter by timestamp greater than
func (r ApiGetGlobalIpAssignmentHealthRequest) FilterTimestampGt(filterTimestampGt time.Time) ApiGetGlobalIpAssignmentHealthRequest {
	r.filterTimestampGt = &filterTimestampGt
	return r
}

// Filter by timestamp less than
func (r ApiGetGlobalIpAssignmentHealthRequest) FilterTimestampLt(filterTimestampLt time.Time) ApiGetGlobalIpAssignmentHealthRequest {
	r.filterTimestampLt = &filterTimestampLt
	return r
}

func (r ApiGetGlobalIpAssignmentHealthRequest) Execute() (*GetGlobalIpAssignmentHealth200Response, *http.Response, error) {
	return r.ApiService.GetGlobalIpAssignmentHealthExecute(r)
}

/*
GetGlobalIpAssignmentHealth Global IP Assignment Health Check Metrics

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetGlobalIpAssignmentHealthRequest
*/
func (a *GlobalIPsAPIService) GetGlobalIpAssignmentHealth(ctx context.Context) ApiGetGlobalIpAssignmentHealthRequest {
	return ApiGetGlobalIpAssignmentHealthRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetGlobalIpAssignmentHealth200Response
func (a *GlobalIPsAPIService) GetGlobalIpAssignmentHealthExecute(r ApiGetGlobalIpAssignmentHealthRequest) (*GetGlobalIpAssignmentHealth200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetGlobalIpAssignmentHealth200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GlobalIPsAPIService.GetGlobalIpAssignmentHealth")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/global_ip_assignment_health"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterGlobalIpIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[global_ip_id][in]", r.filterGlobalIpIdIn, "form", "")
	}
	if r.filterGlobalIpAssignmentIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[global_ip_assignment_id][in]", r.filterGlobalIpAssignmentIdIn, "form", "")
	}
	if r.filterTimestampGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[timestamp][gt]", r.filterTimestampGt, "form", "")
	}
	if r.filterTimestampLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[timestamp][lt]", r.filterTimestampLt, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGlobalIpAssignmentUsageRequest struct {
	ctx context.Context
	ApiService *GlobalIPsAPIService
	filterGlobalIpAssignmentIdIn *string
	filterGlobalIpIdIn *string
	filterTimestampGt *time.Time
	filterTimestampLt *time.Time
}

// Filter by Global IP Assignment ID(s) separated by commas
func (r ApiGetGlobalIpAssignmentUsageRequest) FilterGlobalIpAssignmentIdIn(filterGlobalIpAssignmentIdIn string) ApiGetGlobalIpAssignmentUsageRequest {
	r.filterGlobalIpAssignmentIdIn = &filterGlobalIpAssignmentIdIn
	return r
}

// Filter by Global IP ID(s), separated by commas
func (r ApiGetGlobalIpAssignmentUsageRequest) FilterGlobalIpIdIn(filterGlobalIpIdIn string) ApiGetGlobalIpAssignmentUsageRequest {
	r.filterGlobalIpIdIn = &filterGlobalIpIdIn
	return r
}

// Filter by timestamp greater than
func (r ApiGetGlobalIpAssignmentUsageRequest) FilterTimestampGt(filterTimestampGt time.Time) ApiGetGlobalIpAssignmentUsageRequest {
	r.filterTimestampGt = &filterTimestampGt
	return r
}

// Filter by timestamp less than
func (r ApiGetGlobalIpAssignmentUsageRequest) FilterTimestampLt(filterTimestampLt time.Time) ApiGetGlobalIpAssignmentUsageRequest {
	r.filterTimestampLt = &filterTimestampLt
	return r
}

func (r ApiGetGlobalIpAssignmentUsageRequest) Execute() (*GetGlobalIpAssignmentUsage200Response, *http.Response, error) {
	return r.ApiService.GetGlobalIpAssignmentUsageExecute(r)
}

/*
GetGlobalIpAssignmentUsage Global IP Assignment Usage Metrics

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetGlobalIpAssignmentUsageRequest
*/
func (a *GlobalIPsAPIService) GetGlobalIpAssignmentUsage(ctx context.Context) ApiGetGlobalIpAssignmentUsageRequest {
	return ApiGetGlobalIpAssignmentUsageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetGlobalIpAssignmentUsage200Response
func (a *GlobalIPsAPIService) GetGlobalIpAssignmentUsageExecute(r ApiGetGlobalIpAssignmentUsageRequest) (*GetGlobalIpAssignmentUsage200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetGlobalIpAssignmentUsage200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GlobalIPsAPIService.GetGlobalIpAssignmentUsage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/global_ip_assignments_usage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterGlobalIpAssignmentIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[global_ip_assignment_id][in]", r.filterGlobalIpAssignmentIdIn, "form", "")
	}
	if r.filterGlobalIpIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[global_ip_id][in]", r.filterGlobalIpIdIn, "form", "")
	}
	if r.filterTimestampGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[timestamp][gt]", r.filterTimestampGt, "form", "")
	}
	if r.filterTimestampLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[timestamp][lt]", r.filterTimestampLt, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGlobalIpHealthCheckRequest struct {
	ctx context.Context
	ApiService *GlobalIPsAPIService
	id string
}

func (r ApiGetGlobalIpHealthCheckRequest) Execute() (*CreateGlobalIpHealthCheck202Response, *http.Response, error) {
	return r.ApiService.GetGlobalIpHealthCheckExecute(r)
}

/*
GetGlobalIpHealthCheck Retrieve a Global IP health check

Retrieve a Global IP health check.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the resource.
 @return ApiGetGlobalIpHealthCheckRequest
*/
func (a *GlobalIPsAPIService) GetGlobalIpHealthCheck(ctx context.Context, id string) ApiGetGlobalIpHealthCheckRequest {
	return ApiGetGlobalIpHealthCheckRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreateGlobalIpHealthCheck202Response
func (a *GlobalIPsAPIService) GetGlobalIpHealthCheckExecute(r ApiGetGlobalIpHealthCheckRequest) (*CreateGlobalIpHealthCheck202Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateGlobalIpHealthCheck202Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GlobalIPsAPIService.GetGlobalIpHealthCheck")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/global_ip_health_checks/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGlobalIpLatencyRequest struct {
	ctx context.Context
	ApiService *GlobalIPsAPIService
	filterGlobalIpIdIn *string
	filterTimestampGt *time.Time
	filterTimestampLt *time.Time
}

// Filter by Global IP ID(s) separated by commas
func (r ApiGetGlobalIpLatencyRequest) FilterGlobalIpIdIn(filterGlobalIpIdIn string) ApiGetGlobalIpLatencyRequest {
	r.filterGlobalIpIdIn = &filterGlobalIpIdIn
	return r
}

// Filter by timestamp greater than
func (r ApiGetGlobalIpLatencyRequest) FilterTimestampGt(filterTimestampGt time.Time) ApiGetGlobalIpLatencyRequest {
	r.filterTimestampGt = &filterTimestampGt
	return r
}

// Filter by timestamp less than
func (r ApiGetGlobalIpLatencyRequest) FilterTimestampLt(filterTimestampLt time.Time) ApiGetGlobalIpLatencyRequest {
	r.filterTimestampLt = &filterTimestampLt
	return r
}

func (r ApiGetGlobalIpLatencyRequest) Execute() (*GetGlobalIpLatency200Response, *http.Response, error) {
	return r.ApiService.GetGlobalIpLatencyExecute(r)
}

/*
GetGlobalIpLatency Global IP Latency Metrics

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetGlobalIpLatencyRequest
*/
func (a *GlobalIPsAPIService) GetGlobalIpLatency(ctx context.Context) ApiGetGlobalIpLatencyRequest {
	return ApiGetGlobalIpLatencyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetGlobalIpLatency200Response
func (a *GlobalIPsAPIService) GetGlobalIpLatencyExecute(r ApiGetGlobalIpLatencyRequest) (*GetGlobalIpLatency200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetGlobalIpLatency200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GlobalIPsAPIService.GetGlobalIpLatency")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/global_ip_latency"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterGlobalIpIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[global_ip_id][in]", r.filterGlobalIpIdIn, "form", "")
	}
	if r.filterTimestampGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[timestamp][gt]", r.filterTimestampGt, "form", "")
	}
	if r.filterTimestampLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[timestamp][lt]", r.filterTimestampLt, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGlobalIpUsageRequest struct {
	ctx context.Context
	ApiService *GlobalIPsAPIService
	filterGlobalIpIdIn *string
	filterTimestampGt *time.Time
	filterTimestampLt *time.Time
}

// Filter by Global IP ID(s) separated by commas
func (r ApiGetGlobalIpUsageRequest) FilterGlobalIpIdIn(filterGlobalIpIdIn string) ApiGetGlobalIpUsageRequest {
	r.filterGlobalIpIdIn = &filterGlobalIpIdIn
	return r
}

// Filter by timestamp greater than
func (r ApiGetGlobalIpUsageRequest) FilterTimestampGt(filterTimestampGt time.Time) ApiGetGlobalIpUsageRequest {
	r.filterTimestampGt = &filterTimestampGt
	return r
}

// Filter by timestamp less than
func (r ApiGetGlobalIpUsageRequest) FilterTimestampLt(filterTimestampLt time.Time) ApiGetGlobalIpUsageRequest {
	r.filterTimestampLt = &filterTimestampLt
	return r
}

func (r ApiGetGlobalIpUsageRequest) Execute() (*GetGlobalIpUsage200Response, *http.Response, error) {
	return r.ApiService.GetGlobalIpUsageExecute(r)
}

/*
GetGlobalIpUsage Global IP Usage Metrics

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetGlobalIpUsageRequest
*/
func (a *GlobalIPsAPIService) GetGlobalIpUsage(ctx context.Context) ApiGetGlobalIpUsageRequest {
	return ApiGetGlobalIpUsageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetGlobalIpUsage200Response
func (a *GlobalIPsAPIService) GetGlobalIpUsageExecute(r ApiGetGlobalIpUsageRequest) (*GetGlobalIpUsage200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetGlobalIpUsage200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GlobalIPsAPIService.GetGlobalIpUsage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/global_ip_usage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterGlobalIpIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[global_ip_id][in]", r.filterGlobalIpIdIn, "form", "")
	}
	if r.filterTimestampGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[timestamp][gt]", r.filterTimestampGt, "form", "")
	}
	if r.filterTimestampLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[timestamp][lt]", r.filterTimestampLt, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListGlobalIpAllowedPortsRequest struct {
	ctx context.Context
	ApiService *GlobalIPsAPIService
}

func (r ApiListGlobalIpAllowedPortsRequest) Execute() (*ListGlobalIpAllowedPorts200Response, *http.Response, error) {
	return r.ApiService.ListGlobalIpAllowedPortsExecute(r)
}

/*
ListGlobalIpAllowedPorts List all Global IP Allowed Ports

List all Global IP Allowed Ports

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListGlobalIpAllowedPortsRequest
*/
func (a *GlobalIPsAPIService) ListGlobalIpAllowedPorts(ctx context.Context) ApiListGlobalIpAllowedPortsRequest {
	return ApiListGlobalIpAllowedPortsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListGlobalIpAllowedPorts200Response
func (a *GlobalIPsAPIService) ListGlobalIpAllowedPortsExecute(r ApiListGlobalIpAllowedPortsRequest) (*ListGlobalIpAllowedPorts200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListGlobalIpAllowedPorts200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GlobalIPsAPIService.ListGlobalIpAllowedPorts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/global_ip_allowed_ports"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListGlobalIpAssignmentsRequest struct {
	ctx context.Context
	ApiService *GlobalIPsAPIService
	pageNumber *int32
	pageSize *int32
}

// The page number to load.
func (r ApiListGlobalIpAssignmentsRequest) PageNumber(pageNumber int32) ApiListGlobalIpAssignmentsRequest {
	r.pageNumber = &pageNumber
	return r
}

// The size of the page.
func (r ApiListGlobalIpAssignmentsRequest) PageSize(pageSize int32) ApiListGlobalIpAssignmentsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListGlobalIpAssignmentsRequest) Execute() (*ListGlobalIpAssignments200Response, *http.Response, error) {
	return r.ApiService.ListGlobalIpAssignmentsExecute(r)
}

/*
ListGlobalIpAssignments List all Global IP assignments

List all Global IP assignments.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListGlobalIpAssignmentsRequest
*/
func (a *GlobalIPsAPIService) ListGlobalIpAssignments(ctx context.Context) ApiListGlobalIpAssignmentsRequest {
	return ApiListGlobalIpAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListGlobalIpAssignments200Response
func (a *GlobalIPsAPIService) ListGlobalIpAssignmentsExecute(r ApiListGlobalIpAssignmentsRequest) (*ListGlobalIpAssignments200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListGlobalIpAssignments200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GlobalIPsAPIService.ListGlobalIpAssignments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/global_ip_assignments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListGlobalIpHealthCheckTypesRequest struct {
	ctx context.Context
	ApiService *GlobalIPsAPIService
}

func (r ApiListGlobalIpHealthCheckTypesRequest) Execute() (*ListGlobalIpHealthCheckTypes200Response, *http.Response, error) {
	return r.ApiService.ListGlobalIpHealthCheckTypesExecute(r)
}

/*
ListGlobalIpHealthCheckTypes List all Global IP Health check types

List all Global IP Health check types.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListGlobalIpHealthCheckTypesRequest
*/
func (a *GlobalIPsAPIService) ListGlobalIpHealthCheckTypes(ctx context.Context) ApiListGlobalIpHealthCheckTypesRequest {
	return ApiListGlobalIpHealthCheckTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListGlobalIpHealthCheckTypes200Response
func (a *GlobalIPsAPIService) ListGlobalIpHealthCheckTypesExecute(r ApiListGlobalIpHealthCheckTypesRequest) (*ListGlobalIpHealthCheckTypes200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListGlobalIpHealthCheckTypes200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GlobalIPsAPIService.ListGlobalIpHealthCheckTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/global_ip_health_check_types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListGlobalIpHealthChecksRequest struct {
	ctx context.Context
	ApiService *GlobalIPsAPIService
	pageNumber *int32
	pageSize *int32
}

// The page number to load.
func (r ApiListGlobalIpHealthChecksRequest) PageNumber(pageNumber int32) ApiListGlobalIpHealthChecksRequest {
	r.pageNumber = &pageNumber
	return r
}

// The size of the page.
func (r ApiListGlobalIpHealthChecksRequest) PageSize(pageSize int32) ApiListGlobalIpHealthChecksRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListGlobalIpHealthChecksRequest) Execute() (*ListGlobalIpHealthChecks200Response, *http.Response, error) {
	return r.ApiService.ListGlobalIpHealthChecksExecute(r)
}

/*
ListGlobalIpHealthChecks List all Global IP health checks

List all Global IP health checks.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListGlobalIpHealthChecksRequest
*/
func (a *GlobalIPsAPIService) ListGlobalIpHealthChecks(ctx context.Context) ApiListGlobalIpHealthChecksRequest {
	return ApiListGlobalIpHealthChecksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListGlobalIpHealthChecks200Response
func (a *GlobalIPsAPIService) ListGlobalIpHealthChecksExecute(r ApiListGlobalIpHealthChecksRequest) (*ListGlobalIpHealthChecks200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListGlobalIpHealthChecks200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GlobalIPsAPIService.ListGlobalIpHealthChecks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/global_ip_health_checks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListGlobalIpProtocolsRequest struct {
	ctx context.Context
	ApiService *GlobalIPsAPIService
}

func (r ApiListGlobalIpProtocolsRequest) Execute() (*ListGlobalIpProtocols200Response, *http.Response, error) {
	return r.ApiService.ListGlobalIpProtocolsExecute(r)
}

/*
ListGlobalIpProtocols List all Global IP Protocols

List all Global IP Protocols

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListGlobalIpProtocolsRequest
*/
func (a *GlobalIPsAPIService) ListGlobalIpProtocols(ctx context.Context) ApiListGlobalIpProtocolsRequest {
	return ApiListGlobalIpProtocolsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListGlobalIpProtocols200Response
func (a *GlobalIPsAPIService) ListGlobalIpProtocolsExecute(r ApiListGlobalIpProtocolsRequest) (*ListGlobalIpProtocols200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListGlobalIpProtocols200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GlobalIPsAPIService.ListGlobalIpProtocols")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/global_ip_protocols"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListGlobalIpsRequest struct {
	ctx context.Context
	ApiService *GlobalIPsAPIService
	pageNumber *int32
	pageSize *int32
}

// The page number to load.
func (r ApiListGlobalIpsRequest) PageNumber(pageNumber int32) ApiListGlobalIpsRequest {
	r.pageNumber = &pageNumber
	return r
}

// The size of the page.
func (r ApiListGlobalIpsRequest) PageSize(pageSize int32) ApiListGlobalIpsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListGlobalIpsRequest) Execute() (*ListGlobalIps200Response, *http.Response, error) {
	return r.ApiService.ListGlobalIpsExecute(r)
}

/*
ListGlobalIps List all Global IPs

List all Global IPs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListGlobalIpsRequest
*/
func (a *GlobalIPsAPIService) ListGlobalIps(ctx context.Context) ApiListGlobalIpsRequest {
	return ApiListGlobalIpsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListGlobalIps200Response
func (a *GlobalIPsAPIService) ListGlobalIpsExecute(r ApiListGlobalIpsRequest) (*ListGlobalIps200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListGlobalIps200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GlobalIPsAPIService.ListGlobalIps")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/global_ips"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateGlobalIpAssignmentRequest struct {
	ctx context.Context
	ApiService *GlobalIPsAPIService
	id string
	globalIpAssignmentUpdate *GlobalIpAssignmentUpdate
}

func (r ApiUpdateGlobalIpAssignmentRequest) GlobalIpAssignmentUpdate(globalIpAssignmentUpdate GlobalIpAssignmentUpdate) ApiUpdateGlobalIpAssignmentRequest {
	r.globalIpAssignmentUpdate = &globalIpAssignmentUpdate
	return r
}

func (r ApiUpdateGlobalIpAssignmentRequest) Execute() (*CreateGlobalIpAssignment202Response, *http.Response, error) {
	return r.ApiService.UpdateGlobalIpAssignmentExecute(r)
}

/*
UpdateGlobalIpAssignment Update a Global IP assignment

Update a Global IP assignment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the resource.
 @return ApiUpdateGlobalIpAssignmentRequest
*/
func (a *GlobalIPsAPIService) UpdateGlobalIpAssignment(ctx context.Context, id string) ApiUpdateGlobalIpAssignmentRequest {
	return ApiUpdateGlobalIpAssignmentRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreateGlobalIpAssignment202Response
func (a *GlobalIPsAPIService) UpdateGlobalIpAssignmentExecute(r ApiUpdateGlobalIpAssignmentRequest) (*CreateGlobalIpAssignment202Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateGlobalIpAssignment202Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GlobalIPsAPIService.UpdateGlobalIpAssignment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/global_ip_assignments/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.globalIpAssignmentUpdate == nil {
		return localVarReturnValue, nil, reportError("globalIpAssignmentUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.globalIpAssignmentUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
