/*
Telnyx API

SIP trunking, SMS, MMS, Call Control and Telephony Data Services.

API version: 2.0.0
Contact: support@telnyx.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package telnyx

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// VirtualCrossConnectsAPIService VirtualCrossConnectsAPI service
type VirtualCrossConnectsAPIService service

type ApiCreateVirtualCrossConnectRequest struct {
	ctx context.Context
	ApiService *VirtualCrossConnectsAPIService
	virtualCrossConnectCreate *VirtualCrossConnectCreate
}

func (r ApiCreateVirtualCrossConnectRequest) VirtualCrossConnectCreate(virtualCrossConnectCreate VirtualCrossConnectCreate) ApiCreateVirtualCrossConnectRequest {
	r.virtualCrossConnectCreate = &virtualCrossConnectCreate
	return r
}

func (r ApiCreateVirtualCrossConnectRequest) Execute() (*CreateVirtualCrossConnect200Response, *http.Response, error) {
	return r.ApiService.CreateVirtualCrossConnectExecute(r)
}

/*
CreateVirtualCrossConnect Create a Virtual Cross Connect

Create a new Virtual Cross Connect.<br /><br />For AWS and GCE, you have the option of creating the primary connection first and the secondary connection later. You also have the option of disabling the primary and/or secondary connections at any time and later re-enabling them. With Azure, you do not have this option. Azure requires both the primary and secondary connections to be created at the same time and they can not be independantly disabled.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateVirtualCrossConnectRequest
*/
func (a *VirtualCrossConnectsAPIService) CreateVirtualCrossConnect(ctx context.Context) ApiCreateVirtualCrossConnectRequest {
	return ApiCreateVirtualCrossConnectRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateVirtualCrossConnect200Response
func (a *VirtualCrossConnectsAPIService) CreateVirtualCrossConnectExecute(r ApiCreateVirtualCrossConnectRequest) (*CreateVirtualCrossConnect200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVirtualCrossConnect200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualCrossConnectsAPIService.CreateVirtualCrossConnect")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtual_cross_connects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.virtualCrossConnectCreate == nil {
		return localVarReturnValue, nil, reportError("virtualCrossConnectCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.virtualCrossConnectCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteVirtualCrossConnectRequest struct {
	ctx context.Context
	ApiService *VirtualCrossConnectsAPIService
	id string
}

func (r ApiDeleteVirtualCrossConnectRequest) Execute() (*CreateVirtualCrossConnect200Response, *http.Response, error) {
	return r.ApiService.DeleteVirtualCrossConnectExecute(r)
}

/*
DeleteVirtualCrossConnect Delete a Virtual Cross Connect

Delete a Virtual Cross Connect.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the resource.
 @return ApiDeleteVirtualCrossConnectRequest
*/
func (a *VirtualCrossConnectsAPIService) DeleteVirtualCrossConnect(ctx context.Context, id string) ApiDeleteVirtualCrossConnectRequest {
	return ApiDeleteVirtualCrossConnectRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreateVirtualCrossConnect200Response
func (a *VirtualCrossConnectsAPIService) DeleteVirtualCrossConnectExecute(r ApiDeleteVirtualCrossConnectRequest) (*CreateVirtualCrossConnect200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVirtualCrossConnect200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualCrossConnectsAPIService.DeleteVirtualCrossConnect")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtual_cross_connects/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVirtualCrossConnectRequest struct {
	ctx context.Context
	ApiService *VirtualCrossConnectsAPIService
	id string
}

func (r ApiGetVirtualCrossConnectRequest) Execute() (*CreateVirtualCrossConnect200Response, *http.Response, error) {
	return r.ApiService.GetVirtualCrossConnectExecute(r)
}

/*
GetVirtualCrossConnect Retrieve a Virtual Cross Connect

Retrieve a Virtual Cross Connect.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the resource.
 @return ApiGetVirtualCrossConnectRequest
*/
func (a *VirtualCrossConnectsAPIService) GetVirtualCrossConnect(ctx context.Context, id string) ApiGetVirtualCrossConnectRequest {
	return ApiGetVirtualCrossConnectRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreateVirtualCrossConnect200Response
func (a *VirtualCrossConnectsAPIService) GetVirtualCrossConnectExecute(r ApiGetVirtualCrossConnectRequest) (*CreateVirtualCrossConnect200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVirtualCrossConnect200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualCrossConnectsAPIService.GetVirtualCrossConnect")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtual_cross_connects/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListVirtualCrossConnectCoverageRequest struct {
	ctx context.Context
	ApiService *VirtualCrossConnectsAPIService
	pageNumber *int32
	pageSize *int32
	filtersAvailableBandwidthContains *int32
	filterCloudProvider *string
	filterCloudProviderRegion *string
	filterLocationRegion *string
	filterLocationSite *string
	filterLocationPop *string
	filterLocationCode *string
}

// The page number to load.
func (r ApiListVirtualCrossConnectCoverageRequest) PageNumber(pageNumber int32) ApiListVirtualCrossConnectCoverageRequest {
	r.pageNumber = &pageNumber
	return r
}

// The size of the page.
func (r ApiListVirtualCrossConnectCoverageRequest) PageSize(pageSize int32) ApiListVirtualCrossConnectCoverageRequest {
	r.pageSize = &pageSize
	return r
}

// The available bandwidth to filter on.
func (r ApiListVirtualCrossConnectCoverageRequest) FiltersAvailableBandwidthContains(filtersAvailableBandwidthContains int32) ApiListVirtualCrossConnectCoverageRequest {
	r.filtersAvailableBandwidthContains = &filtersAvailableBandwidthContains
	return r
}

// The Telnyx region code
func (r ApiListVirtualCrossConnectCoverageRequest) FilterCloudProvider(filterCloudProvider string) ApiListVirtualCrossConnectCoverageRequest {
	r.filterCloudProvider = &filterCloudProvider
	return r
}

// The cloud provider region code to filter on
func (r ApiListVirtualCrossConnectCoverageRequest) FilterCloudProviderRegion(filterCloudProviderRegion string) ApiListVirtualCrossConnectCoverageRequest {
	r.filterCloudProviderRegion = &filterCloudProviderRegion
	return r
}

// The region of associated location to filter on.
func (r ApiListVirtualCrossConnectCoverageRequest) FilterLocationRegion(filterLocationRegion string) ApiListVirtualCrossConnectCoverageRequest {
	r.filterLocationRegion = &filterLocationRegion
	return r
}

// The site of associated location to filter on.
func (r ApiListVirtualCrossConnectCoverageRequest) FilterLocationSite(filterLocationSite string) ApiListVirtualCrossConnectCoverageRequest {
	r.filterLocationSite = &filterLocationSite
	return r
}

// The POP of associated location to filter on.
func (r ApiListVirtualCrossConnectCoverageRequest) FilterLocationPop(filterLocationPop string) ApiListVirtualCrossConnectCoverageRequest {
	r.filterLocationPop = &filterLocationPop
	return r
}

// The code of associated location to filter on.
func (r ApiListVirtualCrossConnectCoverageRequest) FilterLocationCode(filterLocationCode string) ApiListVirtualCrossConnectCoverageRequest {
	r.filterLocationCode = &filterLocationCode
	return r
}

func (r ApiListVirtualCrossConnectCoverageRequest) Execute() (*ListVirtualCrossConnectCoverage200Response, *http.Response, error) {
	return r.ApiService.ListVirtualCrossConnectCoverageExecute(r)
}

/*
ListVirtualCrossConnectCoverage List Virtual Cross Connect Cloud Coverage

List Virtual Cross Connects Cloud Coverage.<br /><br />This endpoint shows which cloud regions are available for the `location_code` your Virtual Cross Connect will be provisioned in.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListVirtualCrossConnectCoverageRequest
*/
func (a *VirtualCrossConnectsAPIService) ListVirtualCrossConnectCoverage(ctx context.Context) ApiListVirtualCrossConnectCoverageRequest {
	return ApiListVirtualCrossConnectCoverageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListVirtualCrossConnectCoverage200Response
func (a *VirtualCrossConnectsAPIService) ListVirtualCrossConnectCoverageExecute(r ApiListVirtualCrossConnectCoverageRequest) (*ListVirtualCrossConnectCoverage200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListVirtualCrossConnectCoverage200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualCrossConnectsAPIService.ListVirtualCrossConnectCoverage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtual_cross_connects_coverage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.filtersAvailableBandwidthContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters[available_bandwidth][contains]", r.filtersAvailableBandwidthContains, "form", "")
	}
	if r.filterCloudProvider != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[cloud_provider]", r.filterCloudProvider, "form", "")
	}
	if r.filterCloudProviderRegion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[cloud_provider_region]", r.filterCloudProviderRegion, "form", "")
	}
	if r.filterLocationRegion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[location.region]", r.filterLocationRegion, "form", "")
	}
	if r.filterLocationSite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[location.site]", r.filterLocationSite, "form", "")
	}
	if r.filterLocationPop != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[location.pop]", r.filterLocationPop, "form", "")
	}
	if r.filterLocationCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[location.code]", r.filterLocationCode, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListVirtualCrossConnectsRequest struct {
	ctx context.Context
	ApiService *VirtualCrossConnectsAPIService
	pageNumber *int32
	pageSize *int32
	filterNetworkId *string
}

// The page number to load.
func (r ApiListVirtualCrossConnectsRequest) PageNumber(pageNumber int32) ApiListVirtualCrossConnectsRequest {
	r.pageNumber = &pageNumber
	return r
}

// The size of the page.
func (r ApiListVirtualCrossConnectsRequest) PageSize(pageSize int32) ApiListVirtualCrossConnectsRequest {
	r.pageSize = &pageSize
	return r
}

// The associated network id to filter on.
func (r ApiListVirtualCrossConnectsRequest) FilterNetworkId(filterNetworkId string) ApiListVirtualCrossConnectsRequest {
	r.filterNetworkId = &filterNetworkId
	return r
}

func (r ApiListVirtualCrossConnectsRequest) Execute() (*ListVirtualCrossConnects200Response, *http.Response, error) {
	return r.ApiService.ListVirtualCrossConnectsExecute(r)
}

/*
ListVirtualCrossConnects List all Virtual Cross Connects

List all Virtual Cross Connects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListVirtualCrossConnectsRequest
*/
func (a *VirtualCrossConnectsAPIService) ListVirtualCrossConnects(ctx context.Context) ApiListVirtualCrossConnectsRequest {
	return ApiListVirtualCrossConnectsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListVirtualCrossConnects200Response
func (a *VirtualCrossConnectsAPIService) ListVirtualCrossConnectsExecute(r ApiListVirtualCrossConnectsRequest) (*ListVirtualCrossConnects200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListVirtualCrossConnects200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualCrossConnectsAPIService.ListVirtualCrossConnects")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtual_cross_connects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.filterNetworkId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[network_id]", r.filterNetworkId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateVirtualCrossConnectRequest struct {
	ctx context.Context
	ApiService *VirtualCrossConnectsAPIService
	id string
	virtualCrossConnectPatch *VirtualCrossConnectPatch
}

func (r ApiUpdateVirtualCrossConnectRequest) VirtualCrossConnectPatch(virtualCrossConnectPatch VirtualCrossConnectPatch) ApiUpdateVirtualCrossConnectRequest {
	r.virtualCrossConnectPatch = &virtualCrossConnectPatch
	return r
}

func (r ApiUpdateVirtualCrossConnectRequest) Execute() (*CreateVirtualCrossConnect200Response, *http.Response, error) {
	return r.ApiService.UpdateVirtualCrossConnectExecute(r)
}

/*
UpdateVirtualCrossConnect Update the Virtual Cross Connect

Update the Virtual Cross Connect.<br /><br />Cloud IPs can only be patched during the `created` state, as GCE will only inform you of your generated IP once the pending connection requested has been accepted. Once the Virtual Cross Connect has moved to `provisioning`, the IPs can no longer be patched.<br /><br />Once the Virtual Cross Connect has moved to `provisioned` and you are ready to enable routing, you can toggle the routing announcements to `true`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the resource.
 @return ApiUpdateVirtualCrossConnectRequest
*/
func (a *VirtualCrossConnectsAPIService) UpdateVirtualCrossConnect(ctx context.Context, id string) ApiUpdateVirtualCrossConnectRequest {
	return ApiUpdateVirtualCrossConnectRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreateVirtualCrossConnect200Response
func (a *VirtualCrossConnectsAPIService) UpdateVirtualCrossConnectExecute(r ApiUpdateVirtualCrossConnectRequest) (*CreateVirtualCrossConnect200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVirtualCrossConnect200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualCrossConnectsAPIService.UpdateVirtualCrossConnect")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtual_cross_connects/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.virtualCrossConnectPatch == nil {
		return localVarReturnValue, nil, reportError("virtualCrossConnectPatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.virtualCrossConnectPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
