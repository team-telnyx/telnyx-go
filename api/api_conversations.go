/*
Telnyx API

SIP trunking, SMS, MMS, Call Control and Telephony Data Services.

API version: 2.0.0
Contact: support@telnyx.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package telnyx

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ConversationsAPIService ConversationsAPI service
type ConversationsAPIService service

type ApiCreateNewConversationPublicConversationsPostRequest struct {
	ctx context.Context
	ApiService *ConversationsAPIService
	createConversationRequest *CreateConversationRequest
}

func (r ApiCreateNewConversationPublicConversationsPostRequest) CreateConversationRequest(createConversationRequest CreateConversationRequest) ApiCreateNewConversationPublicConversationsPostRequest {
	r.createConversationRequest = &createConversationRequest
	return r
}

func (r ApiCreateNewConversationPublicConversationsPostRequest) Execute() (*Conversation, *http.Response, error) {
	return r.ApiService.CreateNewConversationPublicConversationsPostExecute(r)
}

/*
CreateNewConversationPublicConversationsPost Create a conversation

Create a new AI Conversation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateNewConversationPublicConversationsPostRequest
*/
func (a *ConversationsAPIService) CreateNewConversationPublicConversationsPost(ctx context.Context) ApiCreateNewConversationPublicConversationsPostRequest {
	return ApiCreateNewConversationPublicConversationsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Conversation
func (a *ConversationsAPIService) CreateNewConversationPublicConversationsPostExecute(r ApiCreateNewConversationPublicConversationsPostRequest) (*Conversation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Conversation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsAPIService.CreateNewConversationPublicConversationsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ai/conversations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createConversationRequest == nil {
		return localVarReturnValue, nil, reportError("createConversationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createConversationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteConversationByIdPublicConversationsDeleteRequest struct {
	ctx context.Context
	ApiService *ConversationsAPIService
	conversationId string
}

func (r ApiDeleteConversationByIdPublicConversationsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteConversationByIdPublicConversationsDeleteExecute(r)
}

/*
DeleteConversationByIdPublicConversationsDelete Delete a conversation

Delete a specific conversation by its ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param conversationId The ID of the conversation to delete
 @return ApiDeleteConversationByIdPublicConversationsDeleteRequest
*/
func (a *ConversationsAPIService) DeleteConversationByIdPublicConversationsDelete(ctx context.Context, conversationId string) ApiDeleteConversationByIdPublicConversationsDeleteRequest {
	return ApiDeleteConversationByIdPublicConversationsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		conversationId: conversationId,
	}
}

// Execute executes the request
func (a *ConversationsAPIService) DeleteConversationByIdPublicConversationsDeleteExecute(r ApiDeleteConversationByIdPublicConversationsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsAPIService.DeleteConversationByIdPublicConversationsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ai/conversations/{conversation_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"conversation_id"+"}", url.PathEscape(parameterValueToString(r.conversationId, "conversationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetConversationByIdPublicConversationsGetRequest struct {
	ctx context.Context
	ApiService *ConversationsAPIService
	conversationId string
}

func (r ApiGetConversationByIdPublicConversationsGetRequest) Execute() (*GetConversationByIdPublicConversationsGet200Response, *http.Response, error) {
	return r.ApiService.GetConversationByIdPublicConversationsGetExecute(r)
}

/*
GetConversationByIdPublicConversationsGet Get a conversation

Retrieve a specific AI conversation by its ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param conversationId The ID of the conversation to retrieve
 @return ApiGetConversationByIdPublicConversationsGetRequest
*/
func (a *ConversationsAPIService) GetConversationByIdPublicConversationsGet(ctx context.Context, conversationId string) ApiGetConversationByIdPublicConversationsGetRequest {
	return ApiGetConversationByIdPublicConversationsGetRequest{
		ApiService: a,
		ctx: ctx,
		conversationId: conversationId,
	}
}

// Execute executes the request
//  @return GetConversationByIdPublicConversationsGet200Response
func (a *ConversationsAPIService) GetConversationByIdPublicConversationsGetExecute(r ApiGetConversationByIdPublicConversationsGetRequest) (*GetConversationByIdPublicConversationsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetConversationByIdPublicConversationsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsAPIService.GetConversationByIdPublicConversationsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ai/conversations/{conversation_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"conversation_id"+"}", url.PathEscape(parameterValueToString(r.conversationId, "conversationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConversationsPublicConversationIdInsightsGetRequest struct {
	ctx context.Context
	ApiService *ConversationsAPIService
	conversationId string
}

func (r ApiGetConversationsPublicConversationIdInsightsGetRequest) Execute() (*ConversationInsightListData, *http.Response, error) {
	return r.ApiService.GetConversationsPublicConversationIdInsightsGetExecute(r)
}

/*
GetConversationsPublicConversationIdInsightsGet Get insights for a conversation

Retrieve insights for a specific conversation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param conversationId
 @return ApiGetConversationsPublicConversationIdInsightsGetRequest
*/
func (a *ConversationsAPIService) GetConversationsPublicConversationIdInsightsGet(ctx context.Context, conversationId string) ApiGetConversationsPublicConversationIdInsightsGetRequest {
	return ApiGetConversationsPublicConversationIdInsightsGetRequest{
		ApiService: a,
		ctx: ctx,
		conversationId: conversationId,
	}
}

// Execute executes the request
//  @return ConversationInsightListData
func (a *ConversationsAPIService) GetConversationsPublicConversationIdInsightsGetExecute(r ApiGetConversationsPublicConversationIdInsightsGetRequest) (*ConversationInsightListData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConversationInsightListData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsAPIService.GetConversationsPublicConversationIdInsightsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ai/conversations/{conversation_id}/conversations-insights"
	localVarPath = strings.Replace(localVarPath, "{"+"conversation_id"+"}", url.PathEscape(parameterValueToString(r.conversationId, "conversationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConversationsPublicConversationIdMessagesGetRequest struct {
	ctx context.Context
	ApiService *ConversationsAPIService
	conversationId string
}

func (r ApiGetConversationsPublicConversationIdMessagesGetRequest) Execute() (*ConversationMessageListData, *http.Response, error) {
	return r.ApiService.GetConversationsPublicConversationIdMessagesGetExecute(r)
}

/*
GetConversationsPublicConversationIdMessagesGet Get conversation messages

Retrieve messages for a specific conversation, including tool calls made by the assistant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param conversationId
 @return ApiGetConversationsPublicConversationIdMessagesGetRequest
*/
func (a *ConversationsAPIService) GetConversationsPublicConversationIdMessagesGet(ctx context.Context, conversationId string) ApiGetConversationsPublicConversationIdMessagesGetRequest {
	return ApiGetConversationsPublicConversationIdMessagesGetRequest{
		ApiService: a,
		ctx: ctx,
		conversationId: conversationId,
	}
}

// Execute executes the request
//  @return ConversationMessageListData
func (a *ConversationsAPIService) GetConversationsPublicConversationIdMessagesGetExecute(r ApiGetConversationsPublicConversationIdMessagesGetRequest) (*ConversationMessageListData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConversationMessageListData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsAPIService.GetConversationsPublicConversationIdMessagesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ai/conversations/{conversation_id}/messages"
	localVarPath = strings.Replace(localVarPath, "{"+"conversation_id"+"}", url.PathEscape(parameterValueToString(r.conversationId, "conversationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConversationsPublicConversationsGetRequest struct {
	ctx context.Context
	ApiService *ConversationsAPIService
	id *string
	name *string
	createdAt *string
	lastMessageAt *string
	metadataAssistantId *string
	metadataCallControlId *string
	metadataTelnyxAgentTarget *string
	metadataTelnyxEndUserTarget *string
	metadataTelnyxConversationChannel *string
	limit *int32
	order *string
	or *string
}

// Filter by conversation ID (e.g. id&#x3D;eq.123)
func (r ApiGetConversationsPublicConversationsGetRequest) Id(id string) ApiGetConversationsPublicConversationsGetRequest {
	r.id = &id
	return r
}

// Filter by conversation Name (e.g. &#x60;name&#x3D;like.Voice%&#x60;)
func (r ApiGetConversationsPublicConversationsGetRequest) Name(name string) ApiGetConversationsPublicConversationsGetRequest {
	r.name = &name
	return r
}

// Filter by creation datetime (e.g., &#x60;created_at&#x3D;gte.2025-01-01&#x60;)
func (r ApiGetConversationsPublicConversationsGetRequest) CreatedAt(createdAt string) ApiGetConversationsPublicConversationsGetRequest {
	r.createdAt = &createdAt
	return r
}

// Filter by last message datetime (e.g., &#x60;last_message_at&#x3D;lte.2025-06-01&#x60;)
func (r ApiGetConversationsPublicConversationsGetRequest) LastMessageAt(lastMessageAt string) ApiGetConversationsPublicConversationsGetRequest {
	r.lastMessageAt = &lastMessageAt
	return r
}

// Filter by assistant ID (e.g., &#x60;metadata-&gt;assistant_id&#x3D;eq.assistant-123&#x60;)
func (r ApiGetConversationsPublicConversationsGetRequest) MetadataAssistantId(metadataAssistantId string) ApiGetConversationsPublicConversationsGetRequest {
	r.metadataAssistantId = &metadataAssistantId
	return r
}

// Filter by call control ID (e.g., &#x60;metadata-&gt;call_control_id&#x3D;eq.v3:123&#x60;)
func (r ApiGetConversationsPublicConversationsGetRequest) MetadataCallControlId(metadataCallControlId string) ApiGetConversationsPublicConversationsGetRequest {
	r.metadataCallControlId = &metadataCallControlId
	return r
}

// Filter by the phone number, SIP URI, or other identifier for the agent (e.g., &#x60;metadata-&gt;telnyx_agent_target&#x3D;eq.+13128675309&#x60;)
func (r ApiGetConversationsPublicConversationsGetRequest) MetadataTelnyxAgentTarget(metadataTelnyxAgentTarget string) ApiGetConversationsPublicConversationsGetRequest {
	r.metadataTelnyxAgentTarget = &metadataTelnyxAgentTarget
	return r
}

// Filter by the phone number, SIP URI, or other identifier for the end user (e.g., &#x60;metadata-&gt;telnyx_end_user_target&#x3D;eq.+13128675309&#x60;)
func (r ApiGetConversationsPublicConversationsGetRequest) MetadataTelnyxEndUserTarget(metadataTelnyxEndUserTarget string) ApiGetConversationsPublicConversationsGetRequest {
	r.metadataTelnyxEndUserTarget = &metadataTelnyxEndUserTarget
	return r
}

// Filter by conversation channel (e.g., &#x60;metadata-&gt;telnyx_conversation_channel&#x3D;eq.phone_call&#x60;)
func (r ApiGetConversationsPublicConversationsGetRequest) MetadataTelnyxConversationChannel(metadataTelnyxConversationChannel string) ApiGetConversationsPublicConversationsGetRequest {
	r.metadataTelnyxConversationChannel = &metadataTelnyxConversationChannel
	return r
}

// Limit the number of returned conversations (e.g., &#x60;limit&#x3D;10&#x60;)
func (r ApiGetConversationsPublicConversationsGetRequest) Limit(limit int32) ApiGetConversationsPublicConversationsGetRequest {
	r.limit = &limit
	return r
}

// Order the results by specific fields (e.g., &#x60;order&#x3D;created_at.desc&#x60; or &#x60;order&#x3D;last_message_at.asc&#x60;)
func (r ApiGetConversationsPublicConversationsGetRequest) Order(order string) ApiGetConversationsPublicConversationsGetRequest {
	r.order = &order
	return r
}

// Apply OR conditions using PostgREST syntax (e.g., &#x60;or&#x3D;(created_at.gte.2025-04-01,last_message_at.gte.2025-04-01)&#x60;)
func (r ApiGetConversationsPublicConversationsGetRequest) Or(or string) ApiGetConversationsPublicConversationsGetRequest {
	r.or = &or
	return r
}

func (r ApiGetConversationsPublicConversationsGetRequest) Execute() (*ConversationsListData, *http.Response, error) {
	return r.ApiService.GetConversationsPublicConversationsGetExecute(r)
}

/*
GetConversationsPublicConversationsGet List conversations

Retrieve a list of all AI conversations configured by the user. Supports [PostgREST-style query parameters](https://postgrest.org/en/stable/api.html#horizontal-filtering-rows) for filtering. Examples are included for the standard metadata fields, but you can filter on any field in the metadata JSON object. For example, to filter by a custom field `metadata->custom_field`, use `metadata->custom_field=eq.value`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetConversationsPublicConversationsGetRequest
*/
func (a *ConversationsAPIService) GetConversationsPublicConversationsGet(ctx context.Context) ApiGetConversationsPublicConversationsGetRequest {
	return ApiGetConversationsPublicConversationsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConversationsListData
func (a *ConversationsAPIService) GetConversationsPublicConversationsGetExecute(r ApiGetConversationsPublicConversationsGetRequest) (*ConversationsListData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConversationsListData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsAPIService.GetConversationsPublicConversationsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ai/conversations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.createdAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at", r.createdAt, "form", "")
	}
	if r.lastMessageAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_message_at", r.lastMessageAt, "form", "")
	}
	if r.metadataAssistantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadata->assistant_id", r.metadataAssistantId, "form", "")
	}
	if r.metadataCallControlId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadata->call_control_id", r.metadataCallControlId, "form", "")
	}
	if r.metadataTelnyxAgentTarget != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadata->telnyx_agent_target", r.metadataTelnyxAgentTarget, "form", "")
	}
	if r.metadataTelnyxEndUserTarget != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadata->telnyx_end_user_target", r.metadataTelnyxEndUserTarget, "form", "")
	}
	if r.metadataTelnyxConversationChannel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadata->telnyx_conversation_channel", r.metadataTelnyxConversationChannel, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	}
	if r.or != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "or", r.or, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateConversationByIdPublicConversationsPutRequest struct {
	ctx context.Context
	ApiService *ConversationsAPIService
	conversationId string
	updateConversationRequest *UpdateConversationRequest
}

func (r ApiUpdateConversationByIdPublicConversationsPutRequest) UpdateConversationRequest(updateConversationRequest UpdateConversationRequest) ApiUpdateConversationByIdPublicConversationsPutRequest {
	r.updateConversationRequest = &updateConversationRequest
	return r
}

func (r ApiUpdateConversationByIdPublicConversationsPutRequest) Execute() (*GetConversationByIdPublicConversationsGet200Response, *http.Response, error) {
	return r.ApiService.UpdateConversationByIdPublicConversationsPutExecute(r)
}

/*
UpdateConversationByIdPublicConversationsPut Update conversation metadata

Update metadata for a specific conversation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param conversationId The ID of the conversation to update
 @return ApiUpdateConversationByIdPublicConversationsPutRequest
*/
func (a *ConversationsAPIService) UpdateConversationByIdPublicConversationsPut(ctx context.Context, conversationId string) ApiUpdateConversationByIdPublicConversationsPutRequest {
	return ApiUpdateConversationByIdPublicConversationsPutRequest{
		ApiService: a,
		ctx: ctx,
		conversationId: conversationId,
	}
}

// Execute executes the request
//  @return GetConversationByIdPublicConversationsGet200Response
func (a *ConversationsAPIService) UpdateConversationByIdPublicConversationsPutExecute(r ApiUpdateConversationByIdPublicConversationsPutRequest) (*GetConversationByIdPublicConversationsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetConversationByIdPublicConversationsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsAPIService.UpdateConversationByIdPublicConversationsPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ai/conversations/{conversation_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"conversation_id"+"}", url.PathEscape(parameterValueToString(r.conversationId, "conversationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateConversationRequest == nil {
		return localVarReturnValue, nil, reportError("updateConversationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateConversationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
