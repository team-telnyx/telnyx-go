/*
Telnyx API

SIP trunking, SMS, MMS, Call Control and Telephony Data Services.

API version: 2.0.0
Contact: support@telnyx.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package telnyx

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ConferenceCommandsAPIService ConferenceCommandsAPI service
type ConferenceCommandsAPIService service

type ApiCreateConferenceRequest struct {
	ctx context.Context
	ApiService *ConferenceCommandsAPIService
	createConferenceRequest *CreateConferenceRequest
}

// Create a conference
func (r ApiCreateConferenceRequest) CreateConferenceRequest(createConferenceRequest CreateConferenceRequest) ApiCreateConferenceRequest {
	r.createConferenceRequest = &createConferenceRequest
	return r
}

func (r ApiCreateConferenceRequest) Execute() (*ConferenceResponse, *http.Response, error) {
	return r.ApiService.CreateConferenceExecute(r)
}

/*
CreateConference Create conference

Create a conference from an existing call leg using a `call_control_id` and a conference name. Upon creating the conference, the call will be automatically bridged to the conference. Conferences will expire after all participants have left the conference or after 4 hours regardless of the number of active participants.

**Expected Webhooks (see [callback schema](https://developers.telnyx.com/api/call-control/create-conference#callbacks) below):**

- `conference.created`
- `conference.participant.joined`
- `conference.participant.left`
- `conference.ended`
- `conference.recording.saved`
- `conference.floor.changed`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateConferenceRequest
*/
func (a *ConferenceCommandsAPIService) CreateConference(ctx context.Context) ApiCreateConferenceRequest {
	return ApiCreateConferenceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConferenceResponse
func (a *ConferenceCommandsAPIService) CreateConferenceExecute(r ApiCreateConferenceRequest) (*ConferenceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConferenceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConferenceCommandsAPIService.CreateConference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conferences"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createConferenceRequest == nil {
		return localVarReturnValue, nil, reportError("createConferenceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createConferenceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHoldConferenceParticipantsRequest struct {
	ctx context.Context
	ApiService *ConferenceCommandsAPIService
	id string
	conferenceHoldRequest *ConferenceHoldRequest
}

func (r ApiHoldConferenceParticipantsRequest) ConferenceHoldRequest(conferenceHoldRequest ConferenceHoldRequest) ApiHoldConferenceParticipantsRequest {
	r.conferenceHoldRequest = &conferenceHoldRequest
	return r
}

func (r ApiHoldConferenceParticipantsRequest) Execute() (*ConferenceCommandResponse, *http.Response, error) {
	return r.ApiService.HoldConferenceParticipantsExecute(r)
}

/*
HoldConferenceParticipants Hold conference participants

Hold a list of participants in a conference call

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Uniquely identifies the conference by id or name
 @return ApiHoldConferenceParticipantsRequest
*/
func (a *ConferenceCommandsAPIService) HoldConferenceParticipants(ctx context.Context, id string) ApiHoldConferenceParticipantsRequest {
	return ApiHoldConferenceParticipantsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConferenceCommandResponse
func (a *ConferenceCommandsAPIService) HoldConferenceParticipantsExecute(r ApiHoldConferenceParticipantsRequest) (*ConferenceCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConferenceCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConferenceCommandsAPIService.HoldConferenceParticipants")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conferences/{id}/actions/hold"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conferenceHoldRequest == nil {
		return localVarReturnValue, nil, reportError("conferenceHoldRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.conferenceHoldRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJoinConferenceRequest struct {
	ctx context.Context
	ApiService *ConferenceCommandsAPIService
	id string
	joinConferenceRequest *JoinConferenceRequest
}

// Join Conference request object
func (r ApiJoinConferenceRequest) JoinConferenceRequest(joinConferenceRequest JoinConferenceRequest) ApiJoinConferenceRequest {
	r.joinConferenceRequest = &joinConferenceRequest
	return r
}

func (r ApiJoinConferenceRequest) Execute() (*ConferenceCommandResponse, *http.Response, error) {
	return r.ApiService.JoinConferenceExecute(r)
}

/*
JoinConference Join a conference

Join an existing call leg to a conference. Issue the Join Conference command with the conference ID in the path and the `call_control_id` of the leg you wish to join to the conference as an attribute. The conference can have up to a certain amount of active participants, as set by the `max_participants` parameter in conference creation request. 

**Expected Webhooks (see [callback schema](https://developers.telnyx.com/api/call-control/join-conference#callbacks) below):**

- `conference.participant.joined`
- `conference.participant.left`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Uniquely identifies the conference by id or name
 @return ApiJoinConferenceRequest
*/
func (a *ConferenceCommandsAPIService) JoinConference(ctx context.Context, id string) ApiJoinConferenceRequest {
	return ApiJoinConferenceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConferenceCommandResponse
func (a *ConferenceCommandsAPIService) JoinConferenceExecute(r ApiJoinConferenceRequest) (*ConferenceCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConferenceCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConferenceCommandsAPIService.JoinConference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conferences/{id}/actions/join"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.joinConferenceRequest == nil {
		return localVarReturnValue, nil, reportError("joinConferenceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.joinConferenceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLeaveConferenceRequest struct {
	ctx context.Context
	ApiService *ConferenceCommandsAPIService
	id string
	leaveConferenceRequest *LeaveConferenceRequest
}

// Leave Conference request object
func (r ApiLeaveConferenceRequest) LeaveConferenceRequest(leaveConferenceRequest LeaveConferenceRequest) ApiLeaveConferenceRequest {
	r.leaveConferenceRequest = &leaveConferenceRequest
	return r
}

func (r ApiLeaveConferenceRequest) Execute() (*ConferenceCommandResponse, *http.Response, error) {
	return r.ApiService.LeaveConferenceExecute(r)
}

/*
LeaveConference Leave a conference

Removes a call leg from a conference and moves it back to parked state. 

**Expected Webhooks (see [callback schema](https://developers.telnyx.com/api/call-control/leave-conference#callbacks) below):**

- `conference.participant.left`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Uniquely identifies the conference by id or name
 @return ApiLeaveConferenceRequest
*/
func (a *ConferenceCommandsAPIService) LeaveConference(ctx context.Context, id string) ApiLeaveConferenceRequest {
	return ApiLeaveConferenceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConferenceCommandResponse
func (a *ConferenceCommandsAPIService) LeaveConferenceExecute(r ApiLeaveConferenceRequest) (*ConferenceCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConferenceCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConferenceCommandsAPIService.LeaveConference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conferences/{id}/actions/leave"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.leaveConferenceRequest == nil {
		return localVarReturnValue, nil, reportError("leaveConferenceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.leaveConferenceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListConferenceParticipantsRequest struct {
	ctx context.Context
	ApiService *ConferenceCommandsAPIService
	conferenceId string
	filterMuted *bool
	filterOnHold *bool
	filterWhispering *bool
	pageNumber *int32
	pageSize *int32
}

// If present, participants will be filtered to those who are/are not muted
func (r ApiListConferenceParticipantsRequest) FilterMuted(filterMuted bool) ApiListConferenceParticipantsRequest {
	r.filterMuted = &filterMuted
	return r
}

// If present, participants will be filtered to those who are/are not put on hold
func (r ApiListConferenceParticipantsRequest) FilterOnHold(filterOnHold bool) ApiListConferenceParticipantsRequest {
	r.filterOnHold = &filterOnHold
	return r
}

// If present, participants will be filtered to those who are whispering or are not
func (r ApiListConferenceParticipantsRequest) FilterWhispering(filterWhispering bool) ApiListConferenceParticipantsRequest {
	r.filterWhispering = &filterWhispering
	return r
}

// The page number to load.
func (r ApiListConferenceParticipantsRequest) PageNumber(pageNumber int32) ApiListConferenceParticipantsRequest {
	r.pageNumber = &pageNumber
	return r
}

// The size of the page.
func (r ApiListConferenceParticipantsRequest) PageSize(pageSize int32) ApiListConferenceParticipantsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListConferenceParticipantsRequest) Execute() (*ListParticipantsResponse, *http.Response, error) {
	return r.ApiService.ListConferenceParticipantsExecute(r)
}

/*
ListConferenceParticipants List conference participants

Lists conference participants

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param conferenceId Uniquely identifies the conference by id
 @return ApiListConferenceParticipantsRequest
*/
func (a *ConferenceCommandsAPIService) ListConferenceParticipants(ctx context.Context, conferenceId string) ApiListConferenceParticipantsRequest {
	return ApiListConferenceParticipantsRequest{
		ApiService: a,
		ctx: ctx,
		conferenceId: conferenceId,
	}
}

// Execute executes the request
//  @return ListParticipantsResponse
func (a *ConferenceCommandsAPIService) ListConferenceParticipantsExecute(r ApiListConferenceParticipantsRequest) (*ListParticipantsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListParticipantsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConferenceCommandsAPIService.ListConferenceParticipants")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conferences/{conference_id}/participants"
	localVarPath = strings.Replace(localVarPath, "{"+"conference_id"+"}", url.PathEscape(parameterValueToString(r.conferenceId, "conferenceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterMuted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[muted]", r.filterMuted, "form", "")
	}
	if r.filterOnHold != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[on_hold]", r.filterOnHold, "form", "")
	}
	if r.filterWhispering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[whispering]", r.filterWhispering, "form", "")
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListConferencesRequest struct {
	ctx context.Context
	ApiService *ConferenceCommandsAPIService
	filterName *string
	filterStatus *string
	pageNumber *int32
	pageSize *int32
}

// If present, conferences will be filtered to those with a matching &#x60;name&#x60; attribute. Matching is case-sensitive
func (r ApiListConferencesRequest) FilterName(filterName string) ApiListConferencesRequest {
	r.filterName = &filterName
	return r
}

// If present, conferences will be filtered by status.
func (r ApiListConferencesRequest) FilterStatus(filterStatus string) ApiListConferencesRequest {
	r.filterStatus = &filterStatus
	return r
}

// The page number to load.
func (r ApiListConferencesRequest) PageNumber(pageNumber int32) ApiListConferencesRequest {
	r.pageNumber = &pageNumber
	return r
}

// The size of the page.
func (r ApiListConferencesRequest) PageSize(pageSize int32) ApiListConferencesRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListConferencesRequest) Execute() (*ListConferencesResponse, *http.Response, error) {
	return r.ApiService.ListConferencesExecute(r)
}

/*
ListConferences List conferences

Lists conferences. Conferences are created on demand, and will expire after all participants have left the conference or after 4 hours regardless of the number of active participants. Conferences are listed in descending order by `expires_at`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListConferencesRequest
*/
func (a *ConferenceCommandsAPIService) ListConferences(ctx context.Context) ApiListConferencesRequest {
	return ApiListConferencesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListConferencesResponse
func (a *ConferenceCommandsAPIService) ListConferencesExecute(r ApiListConferencesRequest) (*ListConferencesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListConferencesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConferenceCommandsAPIService.ListConferences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conferences"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[name]", r.filterName, "form", "")
	}
	if r.filterStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[status]", r.filterStatus, "form", "")
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMuteConferenceParticipantsRequest struct {
	ctx context.Context
	ApiService *ConferenceCommandsAPIService
	id string
	conferenceMuteRequest *ConferenceMuteRequest
}

func (r ApiMuteConferenceParticipantsRequest) ConferenceMuteRequest(conferenceMuteRequest ConferenceMuteRequest) ApiMuteConferenceParticipantsRequest {
	r.conferenceMuteRequest = &conferenceMuteRequest
	return r
}

func (r ApiMuteConferenceParticipantsRequest) Execute() (*ConferenceCommandResponse, *http.Response, error) {
	return r.ApiService.MuteConferenceParticipantsExecute(r)
}

/*
MuteConferenceParticipants Mute conference participants

Mute a list of participants in a conference call

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Uniquely identifies the conference by id or name
 @return ApiMuteConferenceParticipantsRequest
*/
func (a *ConferenceCommandsAPIService) MuteConferenceParticipants(ctx context.Context, id string) ApiMuteConferenceParticipantsRequest {
	return ApiMuteConferenceParticipantsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConferenceCommandResponse
func (a *ConferenceCommandsAPIService) MuteConferenceParticipantsExecute(r ApiMuteConferenceParticipantsRequest) (*ConferenceCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConferenceCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConferenceCommandsAPIService.MuteConferenceParticipants")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conferences/{id}/actions/mute"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conferenceMuteRequest == nil {
		return localVarReturnValue, nil, reportError("conferenceMuteRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.conferenceMuteRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPauseConferenceRecordingRequest struct {
	ctx context.Context
	ApiService *ConferenceCommandsAPIService
	id string
	pauseConferenceRecordingRequest *PauseConferenceRecordingRequest
}

func (r ApiPauseConferenceRecordingRequest) PauseConferenceRecordingRequest(pauseConferenceRecordingRequest PauseConferenceRecordingRequest) ApiPauseConferenceRecordingRequest {
	r.pauseConferenceRecordingRequest = &pauseConferenceRecordingRequest
	return r
}

func (r ApiPauseConferenceRecordingRequest) Execute() (*ConferenceCommandResponse, *http.Response, error) {
	return r.ApiService.PauseConferenceRecordingExecute(r)
}

/*
PauseConferenceRecording Conference recording pause

Pause conference recording.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies the conference by id or name
 @return ApiPauseConferenceRecordingRequest
*/
func (a *ConferenceCommandsAPIService) PauseConferenceRecording(ctx context.Context, id string) ApiPauseConferenceRecordingRequest {
	return ApiPauseConferenceRecordingRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConferenceCommandResponse
func (a *ConferenceCommandsAPIService) PauseConferenceRecordingExecute(r ApiPauseConferenceRecordingRequest) (*ConferenceCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConferenceCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConferenceCommandsAPIService.PauseConferenceRecording")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conferences/{id}/actions/record_pause"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pauseConferenceRecordingRequest == nil {
		return localVarReturnValue, nil, reportError("pauseConferenceRecordingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pauseConferenceRecordingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlayConferenceAudioRequest struct {
	ctx context.Context
	ApiService *ConferenceCommandsAPIService
	id string
	conferencePlayRequest *ConferencePlayRequest
}

func (r ApiPlayConferenceAudioRequest) ConferencePlayRequest(conferencePlayRequest ConferencePlayRequest) ApiPlayConferenceAudioRequest {
	r.conferencePlayRequest = &conferencePlayRequest
	return r
}

func (r ApiPlayConferenceAudioRequest) Execute() (*ConferenceCommandResponse, *http.Response, error) {
	return r.ApiService.PlayConferenceAudioExecute(r)
}

/*
PlayConferenceAudio Play audio to conference participants

Play audio to all or some participants on a conference call.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Uniquely identifies the conference by id or name
 @return ApiPlayConferenceAudioRequest
*/
func (a *ConferenceCommandsAPIService) PlayConferenceAudio(ctx context.Context, id string) ApiPlayConferenceAudioRequest {
	return ApiPlayConferenceAudioRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConferenceCommandResponse
func (a *ConferenceCommandsAPIService) PlayConferenceAudioExecute(r ApiPlayConferenceAudioRequest) (*ConferenceCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConferenceCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConferenceCommandsAPIService.PlayConferenceAudio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conferences/{id}/actions/play"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conferencePlayRequest == nil {
		return localVarReturnValue, nil, reportError("conferencePlayRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.conferencePlayRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResumeConferenceRecordingRequest struct {
	ctx context.Context
	ApiService *ConferenceCommandsAPIService
	id string
	resumeConferenceRecordingRequest *ResumeConferenceRecordingRequest
}

func (r ApiResumeConferenceRecordingRequest) ResumeConferenceRecordingRequest(resumeConferenceRecordingRequest ResumeConferenceRecordingRequest) ApiResumeConferenceRecordingRequest {
	r.resumeConferenceRecordingRequest = &resumeConferenceRecordingRequest
	return r
}

func (r ApiResumeConferenceRecordingRequest) Execute() (*ConferenceCommandResponse, *http.Response, error) {
	return r.ApiService.ResumeConferenceRecordingExecute(r)
}

/*
ResumeConferenceRecording Conference recording resume

Resume conference recording.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies the conference by id or name
 @return ApiResumeConferenceRecordingRequest
*/
func (a *ConferenceCommandsAPIService) ResumeConferenceRecording(ctx context.Context, id string) ApiResumeConferenceRecordingRequest {
	return ApiResumeConferenceRecordingRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConferenceCommandResponse
func (a *ConferenceCommandsAPIService) ResumeConferenceRecordingExecute(r ApiResumeConferenceRecordingRequest) (*ConferenceCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConferenceCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConferenceCommandsAPIService.ResumeConferenceRecording")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conferences/{id}/actions/record_resume"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.resumeConferenceRecordingRequest == nil {
		return localVarReturnValue, nil, reportError("resumeConferenceRecordingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resumeConferenceRecordingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrieveConferenceRequest struct {
	ctx context.Context
	ApiService *ConferenceCommandsAPIService
	id string
}

func (r ApiRetrieveConferenceRequest) Execute() (*ConferenceResponse, *http.Response, error) {
	return r.ApiService.RetrieveConferenceExecute(r)
}

/*
RetrieveConference Retrieve a conference

Retrieve an existing conference

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Uniquely identifies the conference by id
 @return ApiRetrieveConferenceRequest
*/
func (a *ConferenceCommandsAPIService) RetrieveConference(ctx context.Context, id string) ApiRetrieveConferenceRequest {
	return ApiRetrieveConferenceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConferenceResponse
func (a *ConferenceCommandsAPIService) RetrieveConferenceExecute(r ApiRetrieveConferenceRequest) (*ConferenceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConferenceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConferenceCommandsAPIService.RetrieveConference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conferences/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSpeakTextToConferenceRequest struct {
	ctx context.Context
	ApiService *ConferenceCommandsAPIService
	id string
	conferenceSpeakRequest *ConferenceSpeakRequest
}

func (r ApiSpeakTextToConferenceRequest) ConferenceSpeakRequest(conferenceSpeakRequest ConferenceSpeakRequest) ApiSpeakTextToConferenceRequest {
	r.conferenceSpeakRequest = &conferenceSpeakRequest
	return r
}

func (r ApiSpeakTextToConferenceRequest) Execute() (*ConferenceCommandResponse, *http.Response, error) {
	return r.ApiService.SpeakTextToConferenceExecute(r)
}

/*
SpeakTextToConference Speak text to conference participants

Convert text to speech and play it to all or some participants.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies the conference by id or name
 @return ApiSpeakTextToConferenceRequest
*/
func (a *ConferenceCommandsAPIService) SpeakTextToConference(ctx context.Context, id string) ApiSpeakTextToConferenceRequest {
	return ApiSpeakTextToConferenceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConferenceCommandResponse
func (a *ConferenceCommandsAPIService) SpeakTextToConferenceExecute(r ApiSpeakTextToConferenceRequest) (*ConferenceCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConferenceCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConferenceCommandsAPIService.SpeakTextToConference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conferences/{id}/actions/speak"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conferenceSpeakRequest == nil {
		return localVarReturnValue, nil, reportError("conferenceSpeakRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.conferenceSpeakRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartConferenceRecordingRequest struct {
	ctx context.Context
	ApiService *ConferenceCommandsAPIService
	id string
	startConferenceRecordingRequest *StartConferenceRecordingRequest
}

func (r ApiStartConferenceRecordingRequest) StartConferenceRecordingRequest(startConferenceRecordingRequest StartConferenceRecordingRequest) ApiStartConferenceRecordingRequest {
	r.startConferenceRecordingRequest = &startConferenceRecordingRequest
	return r
}

func (r ApiStartConferenceRecordingRequest) Execute() (*ConferenceCommandResponse, *http.Response, error) {
	return r.ApiService.StartConferenceRecordingExecute(r)
}

/*
StartConferenceRecording Conference recording start

Start recording the conference. Recording will stop on conference end, or via the Stop Recording command.

**Expected Webhooks (see [callback schema](https://developers.telnyx.com/api/call-control/start-conference-recording#callbacks) below):**

- `conference.recording.saved`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies the conference to record by id or name
 @return ApiStartConferenceRecordingRequest
*/
func (a *ConferenceCommandsAPIService) StartConferenceRecording(ctx context.Context, id string) ApiStartConferenceRecordingRequest {
	return ApiStartConferenceRecordingRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConferenceCommandResponse
func (a *ConferenceCommandsAPIService) StartConferenceRecordingExecute(r ApiStartConferenceRecordingRequest) (*ConferenceCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConferenceCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConferenceCommandsAPIService.StartConferenceRecording")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conferences/{id}/actions/record_start"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startConferenceRecordingRequest == nil {
		return localVarReturnValue, nil, reportError("startConferenceRecordingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.startConferenceRecordingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStopConferenceAudioRequest struct {
	ctx context.Context
	ApiService *ConferenceCommandsAPIService
	id string
	conferenceStopRequest *ConferenceStopRequest
}

func (r ApiStopConferenceAudioRequest) ConferenceStopRequest(conferenceStopRequest ConferenceStopRequest) ApiStopConferenceAudioRequest {
	r.conferenceStopRequest = &conferenceStopRequest
	return r
}

func (r ApiStopConferenceAudioRequest) Execute() (*ConferenceCommandResponse, *http.Response, error) {
	return r.ApiService.StopConferenceAudioExecute(r)
}

/*
StopConferenceAudio Stop audio being played on the conference

Stop audio being played to all or some participants on a conference call.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Uniquely identifies the conference by id or name
 @return ApiStopConferenceAudioRequest
*/
func (a *ConferenceCommandsAPIService) StopConferenceAudio(ctx context.Context, id string) ApiStopConferenceAudioRequest {
	return ApiStopConferenceAudioRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConferenceCommandResponse
func (a *ConferenceCommandsAPIService) StopConferenceAudioExecute(r ApiStopConferenceAudioRequest) (*ConferenceCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConferenceCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConferenceCommandsAPIService.StopConferenceAudio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conferences/{id}/actions/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conferenceStopRequest == nil {
		return localVarReturnValue, nil, reportError("conferenceStopRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.conferenceStopRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStopConferenceRecordingRequest struct {
	ctx context.Context
	ApiService *ConferenceCommandsAPIService
	id string
	stopRecordingRequest *StopRecordingRequest
}

// Stop recording conference request
func (r ApiStopConferenceRecordingRequest) StopRecordingRequest(stopRecordingRequest StopRecordingRequest) ApiStopConferenceRecordingRequest {
	r.stopRecordingRequest = &stopRecordingRequest
	return r
}

func (r ApiStopConferenceRecordingRequest) Execute() (*ConferenceCommandResponse, *http.Response, error) {
	return r.ApiService.StopConferenceRecordingExecute(r)
}

/*
StopConferenceRecording Conference recording stop

Stop recording the conference.

**Expected Webhooks (see [callback schema](https://developers.telnyx.com/api/call-control/stop-conference-recording#callbacks) below):**

- `conference.recording.saved`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies the conference to stop the recording for by id or name
 @return ApiStopConferenceRecordingRequest
*/
func (a *ConferenceCommandsAPIService) StopConferenceRecording(ctx context.Context, id string) ApiStopConferenceRecordingRequest {
	return ApiStopConferenceRecordingRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConferenceCommandResponse
func (a *ConferenceCommandsAPIService) StopConferenceRecordingExecute(r ApiStopConferenceRecordingRequest) (*ConferenceCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConferenceCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConferenceCommandsAPIService.StopConferenceRecording")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conferences/{id}/actions/record_stop"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.stopRecordingRequest == nil {
		return localVarReturnValue, nil, reportError("stopRecordingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.stopRecordingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnholdConferenceParticipantsRequest struct {
	ctx context.Context
	ApiService *ConferenceCommandsAPIService
	id string
	conferenceUnholdRequest *ConferenceUnholdRequest
}

func (r ApiUnholdConferenceParticipantsRequest) ConferenceUnholdRequest(conferenceUnholdRequest ConferenceUnholdRequest) ApiUnholdConferenceParticipantsRequest {
	r.conferenceUnholdRequest = &conferenceUnholdRequest
	return r
}

func (r ApiUnholdConferenceParticipantsRequest) Execute() (*ConferenceCommandResponse, *http.Response, error) {
	return r.ApiService.UnholdConferenceParticipantsExecute(r)
}

/*
UnholdConferenceParticipants Unhold conference participants

Unhold a list of participants in a conference call

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Uniquely identifies the conference by id or name
 @return ApiUnholdConferenceParticipantsRequest
*/
func (a *ConferenceCommandsAPIService) UnholdConferenceParticipants(ctx context.Context, id string) ApiUnholdConferenceParticipantsRequest {
	return ApiUnholdConferenceParticipantsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConferenceCommandResponse
func (a *ConferenceCommandsAPIService) UnholdConferenceParticipantsExecute(r ApiUnholdConferenceParticipantsRequest) (*ConferenceCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConferenceCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConferenceCommandsAPIService.UnholdConferenceParticipants")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conferences/{id}/actions/unhold"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conferenceUnholdRequest == nil {
		return localVarReturnValue, nil, reportError("conferenceUnholdRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.conferenceUnholdRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnmuteConferenceParticipantsRequest struct {
	ctx context.Context
	ApiService *ConferenceCommandsAPIService
	id string
	conferenceUnmuteRequest *ConferenceUnmuteRequest
}

func (r ApiUnmuteConferenceParticipantsRequest) ConferenceUnmuteRequest(conferenceUnmuteRequest ConferenceUnmuteRequest) ApiUnmuteConferenceParticipantsRequest {
	r.conferenceUnmuteRequest = &conferenceUnmuteRequest
	return r
}

func (r ApiUnmuteConferenceParticipantsRequest) Execute() (*ConferenceCommandResponse, *http.Response, error) {
	return r.ApiService.UnmuteConferenceParticipantsExecute(r)
}

/*
UnmuteConferenceParticipants Unmute conference participants

Unmute a list of participants in a conference call

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Uniquely identifies the conference by id or name
 @return ApiUnmuteConferenceParticipantsRequest
*/
func (a *ConferenceCommandsAPIService) UnmuteConferenceParticipants(ctx context.Context, id string) ApiUnmuteConferenceParticipantsRequest {
	return ApiUnmuteConferenceParticipantsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConferenceCommandResponse
func (a *ConferenceCommandsAPIService) UnmuteConferenceParticipantsExecute(r ApiUnmuteConferenceParticipantsRequest) (*ConferenceCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConferenceCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConferenceCommandsAPIService.UnmuteConferenceParticipants")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conferences/{id}/actions/unmute"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conferenceUnmuteRequest == nil {
		return localVarReturnValue, nil, reportError("conferenceUnmuteRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.conferenceUnmuteRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateConferenceRequest struct {
	ctx context.Context
	ApiService *ConferenceCommandsAPIService
	id string
	updateConferenceRequest *UpdateConferenceRequest
}

// Update Conference request object
func (r ApiUpdateConferenceRequest) UpdateConferenceRequest(updateConferenceRequest UpdateConferenceRequest) ApiUpdateConferenceRequest {
	r.updateConferenceRequest = &updateConferenceRequest
	return r
}

func (r ApiUpdateConferenceRequest) Execute() (*ConferenceCommandResponse, *http.Response, error) {
	return r.ApiService.UpdateConferenceExecute(r)
}

/*
UpdateConference Update conference participant

Update conference participant supervisor_role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Uniquely identifies the conference by id or name
 @return ApiUpdateConferenceRequest
*/
func (a *ConferenceCommandsAPIService) UpdateConference(ctx context.Context, id string) ApiUpdateConferenceRequest {
	return ApiUpdateConferenceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConferenceCommandResponse
func (a *ConferenceCommandsAPIService) UpdateConferenceExecute(r ApiUpdateConferenceRequest) (*ConferenceCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConferenceCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConferenceCommandsAPIService.UpdateConference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conferences/{id}/actions/update"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateConferenceRequest == nil {
		return localVarReturnValue, nil, reportError("updateConferenceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateConferenceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
