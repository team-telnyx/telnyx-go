/*
Telnyx API

SIP trunking, SMS, MMS, Call Control and Telephony Data Services.

API version: 2.0.0
Contact: support@telnyx.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package telnyx

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
	"reflect"
	"time"
)


// PortingOrdersAPIService PortingOrdersAPI service
type PortingOrdersAPIService service

type ApiActivatePortingOrderRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	id string
}

func (r ApiActivatePortingOrderRequest) Execute() (*ActivatePortingOrder202Response, *http.Response, error) {
	return r.ApiService.ActivatePortingOrderExecute(r)
}

/*
ActivatePortingOrder Activate every number in a porting order asynchronously.

Activate each number in a porting order asynchronously. This operation is limited to US FastPort orders only.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Porting Order id
 @return ApiActivatePortingOrderRequest
*/
func (a *PortingOrdersAPIService) ActivatePortingOrder(ctx context.Context, id string) ApiActivatePortingOrderRequest {
	return ApiActivatePortingOrderRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ActivatePortingOrder202Response
func (a *PortingOrdersAPIService) ActivatePortingOrderExecute(r ApiActivatePortingOrderRequest) (*ActivatePortingOrder202Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActivatePortingOrder202Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.ActivatePortingOrder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting_orders/{id}/actions/activate"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCancelPortingOrderRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	id string
}

func (r ApiCancelPortingOrderRequest) Execute() (*CancelPortingOrder200Response, *http.Response, error) {
	return r.ApiService.CancelPortingOrderExecute(r)
}

/*
CancelPortingOrder Cancel a porting order

Cancel a porting order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Porting Order id
 @return ApiCancelPortingOrderRequest
*/
func (a *PortingOrdersAPIService) CancelPortingOrder(ctx context.Context, id string) ApiCancelPortingOrderRequest {
	return ApiCancelPortingOrderRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CancelPortingOrder200Response
func (a *PortingOrdersAPIService) CancelPortingOrderExecute(r ApiCancelPortingOrderRequest) (*CancelPortingOrder200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CancelPortingOrder200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.CancelPortingOrder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting_orders/{id}/actions/cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConfirmPortingOrderRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	id string
}

func (r ApiConfirmPortingOrderRequest) Execute() (*ConfirmPortingOrder200Response, *http.Response, error) {
	return r.ApiService.ConfirmPortingOrderExecute(r)
}

/*
ConfirmPortingOrder Submit a porting order.

Confirm and submit your porting order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Porting Order id
 @return ApiConfirmPortingOrderRequest
*/
func (a *PortingOrdersAPIService) ConfirmPortingOrder(ctx context.Context, id string) ApiConfirmPortingOrderRequest {
	return ApiConfirmPortingOrderRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConfirmPortingOrder200Response
func (a *PortingOrdersAPIService) ConfirmPortingOrderExecute(r ApiConfirmPortingOrderRequest) (*ConfirmPortingOrder200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConfirmPortingOrder200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.ConfirmPortingOrder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting_orders/{id}/actions/confirm"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAdditionalDocumentsRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	id string
	createAdditionalDocumentsRequest *CreateAdditionalDocumentsRequest
}

// A list of additional document parameters
func (r ApiCreateAdditionalDocumentsRequest) CreateAdditionalDocumentsRequest(createAdditionalDocumentsRequest CreateAdditionalDocumentsRequest) ApiCreateAdditionalDocumentsRequest {
	r.createAdditionalDocumentsRequest = &createAdditionalDocumentsRequest
	return r
}

func (r ApiCreateAdditionalDocumentsRequest) Execute() (*CreateAdditionalDocuments201Response, *http.Response, error) {
	return r.ApiService.CreateAdditionalDocumentsExecute(r)
}

/*
CreateAdditionalDocuments Create a list of additional documents

Creates a list of additional documents for a porting order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Porting Order id
 @return ApiCreateAdditionalDocumentsRequest
*/
func (a *PortingOrdersAPIService) CreateAdditionalDocuments(ctx context.Context, id string) ApiCreateAdditionalDocumentsRequest {
	return ApiCreateAdditionalDocumentsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreateAdditionalDocuments201Response
func (a *PortingOrdersAPIService) CreateAdditionalDocumentsExecute(r ApiCreateAdditionalDocumentsRequest) (*CreateAdditionalDocuments201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAdditionalDocuments201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.CreateAdditionalDocuments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting_orders/{id}/additional_documents"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAdditionalDocumentsRequest == nil {
		return localVarReturnValue, nil, reportError("createAdditionalDocumentsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAdditionalDocumentsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateLoaConfigurationRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	previewLoaConfigurationParamsRequest *PreviewLoaConfigurationParamsRequest
}

func (r ApiCreateLoaConfigurationRequest) PreviewLoaConfigurationParamsRequest(previewLoaConfigurationParamsRequest PreviewLoaConfigurationParamsRequest) ApiCreateLoaConfigurationRequest {
	r.previewLoaConfigurationParamsRequest = &previewLoaConfigurationParamsRequest
	return r
}

func (r ApiCreateLoaConfigurationRequest) Execute() (*CreateLoaConfiguration201Response, *http.Response, error) {
	return r.ApiService.CreateLoaConfigurationExecute(r)
}

/*
CreateLoaConfiguration Create a LOA configuration

Create a LOA configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateLoaConfigurationRequest
*/
func (a *PortingOrdersAPIService) CreateLoaConfiguration(ctx context.Context) ApiCreateLoaConfigurationRequest {
	return ApiCreateLoaConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateLoaConfiguration201Response
func (a *PortingOrdersAPIService) CreateLoaConfigurationExecute(r ApiCreateLoaConfigurationRequest) (*CreateLoaConfiguration201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLoaConfiguration201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.CreateLoaConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting/loa_configurations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.previewLoaConfigurationParamsRequest == nil {
		return localVarReturnValue, nil, reportError("previewLoaConfigurationParamsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.previewLoaConfigurationParamsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePhoneNumberConfigurationsRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	createPhoneNumberConfigurationsRequest *CreatePhoneNumberConfigurationsRequest
}

// A list of phone number configuration parameters
func (r ApiCreatePhoneNumberConfigurationsRequest) CreatePhoneNumberConfigurationsRequest(createPhoneNumberConfigurationsRequest CreatePhoneNumberConfigurationsRequest) ApiCreatePhoneNumberConfigurationsRequest {
	r.createPhoneNumberConfigurationsRequest = &createPhoneNumberConfigurationsRequest
	return r
}

func (r ApiCreatePhoneNumberConfigurationsRequest) Execute() (*CreatePhoneNumberConfigurations201Response, *http.Response, error) {
	return r.ApiService.CreatePhoneNumberConfigurationsExecute(r)
}

/*
CreatePhoneNumberConfigurations Create a list of phone number configurations

Creates a list of phone number configurations.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreatePhoneNumberConfigurationsRequest
*/
func (a *PortingOrdersAPIService) CreatePhoneNumberConfigurations(ctx context.Context) ApiCreatePhoneNumberConfigurationsRequest {
	return ApiCreatePhoneNumberConfigurationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreatePhoneNumberConfigurations201Response
func (a *PortingOrdersAPIService) CreatePhoneNumberConfigurationsExecute(r ApiCreatePhoneNumberConfigurationsRequest) (*CreatePhoneNumberConfigurations201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreatePhoneNumberConfigurations201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.CreatePhoneNumberConfigurations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting_orders/phone_number_configurations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createPhoneNumberConfigurationsRequest == nil {
		return localVarReturnValue, nil, reportError("createPhoneNumberConfigurationsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createPhoneNumberConfigurationsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePortingOrderRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	createPortingOrder *CreatePortingOrder
}

func (r ApiCreatePortingOrderRequest) CreatePortingOrder(createPortingOrder CreatePortingOrder) ApiCreatePortingOrderRequest {
	r.createPortingOrder = &createPortingOrder
	return r
}

func (r ApiCreatePortingOrderRequest) Execute() (*CreatePortingOrder201Response, *http.Response, error) {
	return r.ApiService.CreatePortingOrderExecute(r)
}

/*
CreatePortingOrder Create a porting order

Creates a new porting order object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreatePortingOrderRequest
*/
func (a *PortingOrdersAPIService) CreatePortingOrder(ctx context.Context) ApiCreatePortingOrderRequest {
	return ApiCreatePortingOrderRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreatePortingOrder201Response
func (a *PortingOrdersAPIService) CreatePortingOrderExecute(r ApiCreatePortingOrderRequest) (*CreatePortingOrder201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreatePortingOrder201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.CreatePortingOrder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting_orders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createPortingOrder == nil {
		return localVarReturnValue, nil, reportError("createPortingOrder is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createPortingOrder
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePortingOrderCommentRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	id string
	createPortingOrderComment *CreatePortingOrderComment
}

func (r ApiCreatePortingOrderCommentRequest) CreatePortingOrderComment(createPortingOrderComment CreatePortingOrderComment) ApiCreatePortingOrderCommentRequest {
	r.createPortingOrderComment = &createPortingOrderComment
	return r
}

func (r ApiCreatePortingOrderCommentRequest) Execute() (*CreatePortingOrderComment201Response, *http.Response, error) {
	return r.ApiService.CreatePortingOrderCommentExecute(r)
}

/*
CreatePortingOrderComment Create a comment for a porting order

Creates a new comment for a porting order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Porting Order id
 @return ApiCreatePortingOrderCommentRequest
*/
func (a *PortingOrdersAPIService) CreatePortingOrderComment(ctx context.Context, id string) ApiCreatePortingOrderCommentRequest {
	return ApiCreatePortingOrderCommentRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreatePortingOrderComment201Response
func (a *PortingOrdersAPIService) CreatePortingOrderCommentExecute(r ApiCreatePortingOrderCommentRequest) (*CreatePortingOrderComment201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreatePortingOrderComment201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.CreatePortingOrderComment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting_orders/{id}/comments"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createPortingOrderComment == nil {
		return localVarReturnValue, nil, reportError("createPortingOrderComment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createPortingOrderComment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePortingPhoneNumberBlockRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	portingOrderId string
	createPortingPhoneNumberBlockRequest *CreatePortingPhoneNumberBlockRequest
}

func (r ApiCreatePortingPhoneNumberBlockRequest) CreatePortingPhoneNumberBlockRequest(createPortingPhoneNumberBlockRequest CreatePortingPhoneNumberBlockRequest) ApiCreatePortingPhoneNumberBlockRequest {
	r.createPortingPhoneNumberBlockRequest = &createPortingPhoneNumberBlockRequest
	return r
}

func (r ApiCreatePortingPhoneNumberBlockRequest) Execute() (*CreatePortingPhoneNumberBlock201Response, *http.Response, error) {
	return r.ApiService.CreatePortingPhoneNumberBlockExecute(r)
}

/*
CreatePortingPhoneNumberBlock Create a phone number block

Creates a new phone number block.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portingOrderId Identifies the Porting Order associated with the phone number block
 @return ApiCreatePortingPhoneNumberBlockRequest
*/
func (a *PortingOrdersAPIService) CreatePortingPhoneNumberBlock(ctx context.Context, portingOrderId string) ApiCreatePortingPhoneNumberBlockRequest {
	return ApiCreatePortingPhoneNumberBlockRequest{
		ApiService: a,
		ctx: ctx,
		portingOrderId: portingOrderId,
	}
}

// Execute executes the request
//  @return CreatePortingPhoneNumberBlock201Response
func (a *PortingOrdersAPIService) CreatePortingPhoneNumberBlockExecute(r ApiCreatePortingPhoneNumberBlockRequest) (*CreatePortingPhoneNumberBlock201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreatePortingPhoneNumberBlock201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.CreatePortingPhoneNumberBlock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting_orders/{porting_order_id}/phone_number_blocks"
	localVarPath = strings.Replace(localVarPath, "{"+"porting_order_id"+"}", url.PathEscape(parameterValueToString(r.portingOrderId, "portingOrderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createPortingPhoneNumberBlockRequest == nil {
		return localVarReturnValue, nil, reportError("createPortingPhoneNumberBlockRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createPortingPhoneNumberBlockRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePortingPhoneNumberExtensionRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	portingOrderId string
	createPortingPhoneNumberExtensionRequest *CreatePortingPhoneNumberExtensionRequest
}

func (r ApiCreatePortingPhoneNumberExtensionRequest) CreatePortingPhoneNumberExtensionRequest(createPortingPhoneNumberExtensionRequest CreatePortingPhoneNumberExtensionRequest) ApiCreatePortingPhoneNumberExtensionRequest {
	r.createPortingPhoneNumberExtensionRequest = &createPortingPhoneNumberExtensionRequest
	return r
}

func (r ApiCreatePortingPhoneNumberExtensionRequest) Execute() (*CreatePortingPhoneNumberExtension201Response, *http.Response, error) {
	return r.ApiService.CreatePortingPhoneNumberExtensionExecute(r)
}

/*
CreatePortingPhoneNumberExtension Create a phone number extension

Creates a new phone number extension.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portingOrderId Identifies the Porting Order associated with the phone number extension
 @return ApiCreatePortingPhoneNumberExtensionRequest
*/
func (a *PortingOrdersAPIService) CreatePortingPhoneNumberExtension(ctx context.Context, portingOrderId string) ApiCreatePortingPhoneNumberExtensionRequest {
	return ApiCreatePortingPhoneNumberExtensionRequest{
		ApiService: a,
		ctx: ctx,
		portingOrderId: portingOrderId,
	}
}

// Execute executes the request
//  @return CreatePortingPhoneNumberExtension201Response
func (a *PortingOrdersAPIService) CreatePortingPhoneNumberExtensionExecute(r ApiCreatePortingPhoneNumberExtensionRequest) (*CreatePortingPhoneNumberExtension201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreatePortingPhoneNumberExtension201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.CreatePortingPhoneNumberExtension")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting_orders/{porting_order_id}/phone_number_extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"porting_order_id"+"}", url.PathEscape(parameterValueToString(r.portingOrderId, "portingOrderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createPortingPhoneNumberExtensionRequest == nil {
		return localVarReturnValue, nil, reportError("createPortingPhoneNumberExtensionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createPortingPhoneNumberExtensionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePortingReportRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	createPortingReportRequest *CreatePortingReportRequest
}

func (r ApiCreatePortingReportRequest) CreatePortingReportRequest(createPortingReportRequest CreatePortingReportRequest) ApiCreatePortingReportRequest {
	r.createPortingReportRequest = &createPortingReportRequest
	return r
}

func (r ApiCreatePortingReportRequest) Execute() (*CreatePortingReport201Response, *http.Response, error) {
	return r.ApiService.CreatePortingReportExecute(r)
}

/*
CreatePortingReport Create a porting related report

Generate reports about porting operations.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreatePortingReportRequest
*/
func (a *PortingOrdersAPIService) CreatePortingReport(ctx context.Context) ApiCreatePortingReportRequest {
	return ApiCreatePortingReportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreatePortingReport201Response
func (a *PortingOrdersAPIService) CreatePortingReportExecute(r ApiCreatePortingReportRequest) (*CreatePortingReport201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreatePortingReport201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.CreatePortingReport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting/reports"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createPortingReportRequest == nil {
		return localVarReturnValue, nil, reportError("createPortingReportRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createPortingReportRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAdditionalDocumentRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	id string
	additionalDocumentId string
}

func (r ApiDeleteAdditionalDocumentRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAdditionalDocumentExecute(r)
}

/*
DeleteAdditionalDocument Delete an additional document

Deletes an additional document for a porting order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Porting Order id
 @param additionalDocumentId Additional document identification.
 @return ApiDeleteAdditionalDocumentRequest
*/
func (a *PortingOrdersAPIService) DeleteAdditionalDocument(ctx context.Context, id string, additionalDocumentId string) ApiDeleteAdditionalDocumentRequest {
	return ApiDeleteAdditionalDocumentRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		additionalDocumentId: additionalDocumentId,
	}
}

// Execute executes the request
func (a *PortingOrdersAPIService) DeleteAdditionalDocumentExecute(r ApiDeleteAdditionalDocumentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.DeleteAdditionalDocument")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting_orders/{id}/additional_documents/{additional_document_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"additional_document_id"+"}", url.PathEscape(parameterValueToString(r.additionalDocumentId, "additionalDocumentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteLoaConfigurationRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	id string
}

func (r ApiDeleteLoaConfigurationRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLoaConfigurationExecute(r)
}

/*
DeleteLoaConfiguration Delete a LOA configuration

Delete a specific LOA configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies a LOA configuration.
 @return ApiDeleteLoaConfigurationRequest
*/
func (a *PortingOrdersAPIService) DeleteLoaConfiguration(ctx context.Context, id string) ApiDeleteLoaConfigurationRequest {
	return ApiDeleteLoaConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *PortingOrdersAPIService) DeleteLoaConfigurationExecute(r ApiDeleteLoaConfigurationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.DeleteLoaConfiguration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting/loa_configurations/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeletePortingOrderRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	id string
}

func (r ApiDeletePortingOrderRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePortingOrderExecute(r)
}

/*
DeletePortingOrder Delete a porting order

Deletes an existing porting order. This operation is restrict to porting orders in draft state.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Porting Order id
 @return ApiDeletePortingOrderRequest
*/
func (a *PortingOrdersAPIService) DeletePortingOrder(ctx context.Context, id string) ApiDeletePortingOrderRequest {
	return ApiDeletePortingOrderRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *PortingOrdersAPIService) DeletePortingOrderExecute(r ApiDeletePortingOrderRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.DeletePortingOrder")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting_orders/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeletePortingPhoneNumberBlockRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	portingOrderId string
	id string
}

func (r ApiDeletePortingPhoneNumberBlockRequest) Execute() (*CreatePortingPhoneNumberBlock201Response, *http.Response, error) {
	return r.ApiService.DeletePortingPhoneNumberBlockExecute(r)
}

/*
DeletePortingPhoneNumberBlock Delete a phone number block

Deletes a phone number block.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portingOrderId Identifies the Porting Order associated with the phone number block
 @param id Identifies the phone number block to be deleted
 @return ApiDeletePortingPhoneNumberBlockRequest
*/
func (a *PortingOrdersAPIService) DeletePortingPhoneNumberBlock(ctx context.Context, portingOrderId string, id string) ApiDeletePortingPhoneNumberBlockRequest {
	return ApiDeletePortingPhoneNumberBlockRequest{
		ApiService: a,
		ctx: ctx,
		portingOrderId: portingOrderId,
		id: id,
	}
}

// Execute executes the request
//  @return CreatePortingPhoneNumberBlock201Response
func (a *PortingOrdersAPIService) DeletePortingPhoneNumberBlockExecute(r ApiDeletePortingPhoneNumberBlockRequest) (*CreatePortingPhoneNumberBlock201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreatePortingPhoneNumberBlock201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.DeletePortingPhoneNumberBlock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting_orders/{porting_order_id}/phone_number_blocks/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"porting_order_id"+"}", url.PathEscape(parameterValueToString(r.portingOrderId, "portingOrderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeletePortingPhoneNumberExtensionRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	portingOrderId string
	id string
}

func (r ApiDeletePortingPhoneNumberExtensionRequest) Execute() (*CreatePortingPhoneNumberExtension201Response, *http.Response, error) {
	return r.ApiService.DeletePortingPhoneNumberExtensionExecute(r)
}

/*
DeletePortingPhoneNumberExtension Delete a phone number extension

Deletes a phone number extension.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portingOrderId Identifies the Porting Order associated with the phone number extension
 @param id Identifies the phone number extension to be deleted
 @return ApiDeletePortingPhoneNumberExtensionRequest
*/
func (a *PortingOrdersAPIService) DeletePortingPhoneNumberExtension(ctx context.Context, portingOrderId string, id string) ApiDeletePortingPhoneNumberExtensionRequest {
	return ApiDeletePortingPhoneNumberExtensionRequest{
		ApiService: a,
		ctx: ctx,
		portingOrderId: portingOrderId,
		id: id,
	}
}

// Execute executes the request
//  @return CreatePortingPhoneNumberExtension201Response
func (a *PortingOrdersAPIService) DeletePortingPhoneNumberExtensionExecute(r ApiDeletePortingPhoneNumberExtensionRequest) (*CreatePortingPhoneNumberExtension201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreatePortingPhoneNumberExtension201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.DeletePortingPhoneNumberExtension")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting_orders/{porting_order_id}/phone_number_extensions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"porting_order_id"+"}", url.PathEscape(parameterValueToString(r.portingOrderId, "portingOrderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLoaConfigurationRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	id string
}

func (r ApiGetLoaConfigurationRequest) Execute() (*CreateLoaConfiguration201Response, *http.Response, error) {
	return r.ApiService.GetLoaConfigurationExecute(r)
}

/*
GetLoaConfiguration Retrieve a LOA configuration

Retrieve a specific LOA configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies a LOA configuration.
 @return ApiGetLoaConfigurationRequest
*/
func (a *PortingOrdersAPIService) GetLoaConfiguration(ctx context.Context, id string) ApiGetLoaConfigurationRequest {
	return ApiGetLoaConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreateLoaConfiguration201Response
func (a *PortingOrdersAPIService) GetLoaConfigurationExecute(r ApiGetLoaConfigurationRequest) (*CreateLoaConfiguration201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLoaConfiguration201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.GetLoaConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting/loa_configurations/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPortingOrderRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	id string
	includePhoneNumbers *bool
}

// Include the first 50 phone number objects in the results
func (r ApiGetPortingOrderRequest) IncludePhoneNumbers(includePhoneNumbers bool) ApiGetPortingOrderRequest {
	r.includePhoneNumbers = &includePhoneNumbers
	return r
}

func (r ApiGetPortingOrderRequest) Execute() (*GetPortingOrder200Response, *http.Response, error) {
	return r.ApiService.GetPortingOrderExecute(r)
}

/*
GetPortingOrder Retrieve a porting order

Retrieves the details of an existing porting order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Porting Order id
 @return ApiGetPortingOrderRequest
*/
func (a *PortingOrdersAPIService) GetPortingOrder(ctx context.Context, id string) ApiGetPortingOrderRequest {
	return ApiGetPortingOrderRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetPortingOrder200Response
func (a *PortingOrdersAPIService) GetPortingOrderExecute(r ApiGetPortingOrderRequest) (*GetPortingOrder200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPortingOrder200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.GetPortingOrder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting_orders/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includePhoneNumbers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_phone_numbers", r.includePhoneNumbers, "form", "")
	} else {
		var defaultValue bool = true
		r.includePhoneNumbers = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPortingOrderLoaTemplateRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	id string
	loaConfigurationId *string
}

// The identifier of the LOA configuration to use for the template. If not provided, the default LOA configuration will be used.
func (r ApiGetPortingOrderLoaTemplateRequest) LoaConfigurationId(loaConfigurationId string) ApiGetPortingOrderLoaTemplateRequest {
	r.loaConfigurationId = &loaConfigurationId
	return r
}

func (r ApiGetPortingOrderLoaTemplateRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetPortingOrderLoaTemplateExecute(r)
}

/*
GetPortingOrderLoaTemplate Download a porting order loa template

Download a porting order loa template

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Porting Order id
 @return ApiGetPortingOrderLoaTemplateRequest
*/
func (a *PortingOrdersAPIService) GetPortingOrderLoaTemplate(ctx context.Context, id string) ApiGetPortingOrderLoaTemplateRequest {
	return ApiGetPortingOrderLoaTemplateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return *os.File
func (a *PortingOrdersAPIService) GetPortingOrderLoaTemplateExecute(r ApiGetPortingOrderLoaTemplateRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.GetPortingOrderLoaTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting_orders/{id}/loa_template"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.loaConfigurationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "loa_configuration_id", r.loaConfigurationId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/pdf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPortingOrderSubRequestRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	id string
}

func (r ApiGetPortingOrderSubRequestRequest) Execute() (*GetPortingOrderSubRequest200Response, *http.Response, error) {
	return r.ApiService.GetPortingOrderSubRequestExecute(r)
}

/*
GetPortingOrderSubRequest Retrieve the associated V1 sub_request_id and port_request_id

Retrieve the associated V1 sub_request_id and port_request_id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Porting Order id
 @return ApiGetPortingOrderSubRequestRequest
*/
func (a *PortingOrdersAPIService) GetPortingOrderSubRequest(ctx context.Context, id string) ApiGetPortingOrderSubRequestRequest {
	return ApiGetPortingOrderSubRequestRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetPortingOrderSubRequest200Response
func (a *PortingOrdersAPIService) GetPortingOrderSubRequestExecute(r ApiGetPortingOrderSubRequestRequest) (*GetPortingOrderSubRequest200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPortingOrderSubRequest200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.GetPortingOrderSubRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting_orders/{id}/sub_request"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPortingOrdersActivationJobRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	id string
	activationJobId string
}

func (r ApiGetPortingOrdersActivationJobRequest) Execute() (*ActivatePortingOrder202Response, *http.Response, error) {
	return r.ApiService.GetPortingOrdersActivationJobExecute(r)
}

/*
GetPortingOrdersActivationJob Retrieve a porting activation job

Returns a porting activation job.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Porting Order id
 @param activationJobId Activation Job Identifier
 @return ApiGetPortingOrdersActivationJobRequest
*/
func (a *PortingOrdersAPIService) GetPortingOrdersActivationJob(ctx context.Context, id string, activationJobId string) ApiGetPortingOrdersActivationJobRequest {
	return ApiGetPortingOrdersActivationJobRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		activationJobId: activationJobId,
	}
}

// Execute executes the request
//  @return ActivatePortingOrder202Response
func (a *PortingOrdersAPIService) GetPortingOrdersActivationJobExecute(r ApiGetPortingOrdersActivationJobRequest) (*ActivatePortingOrder202Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActivatePortingOrder202Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.GetPortingOrdersActivationJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting_orders/{id}/activation_jobs/{activationJobId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"activationJobId"+"}", url.PathEscape(parameterValueToString(r.activationJobId, "activationJobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPortingReportRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	id string
}

func (r ApiGetPortingReportRequest) Execute() (*CreatePortingReport201Response, *http.Response, error) {
	return r.ApiService.GetPortingReportExecute(r)
}

/*
GetPortingReport Retrieve a report

Retrieve a specific report generated.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies a report.
 @return ApiGetPortingReportRequest
*/
func (a *PortingOrdersAPIService) GetPortingReport(ctx context.Context, id string) ApiGetPortingReportRequest {
	return ApiGetPortingReportRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreatePortingReport201Response
func (a *PortingOrdersAPIService) GetPortingReportExecute(r ApiGetPortingReportRequest) (*CreatePortingReport201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreatePortingReport201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.GetPortingReport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting/reports/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAdditionalDocumentsRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	id string
	pageNumber *int32
	pageSize *int32
	filterDocumentType *string
	filterDocumentTypeIn *[]string
	sort *string
}

// The page number to load.
func (r ApiListAdditionalDocumentsRequest) PageNumber(pageNumber int32) ApiListAdditionalDocumentsRequest {
	r.pageNumber = &pageNumber
	return r
}

// The size of the page.
func (r ApiListAdditionalDocumentsRequest) PageSize(pageSize int32) ApiListAdditionalDocumentsRequest {
	r.pageSize = &pageSize
	return r
}

// Filter additional documents of a specific document type
func (r ApiListAdditionalDocumentsRequest) FilterDocumentType(filterDocumentType string) ApiListAdditionalDocumentsRequest {
	r.filterDocumentType = &filterDocumentType
	return r
}

// Filter additional documents by a list of document types
func (r ApiListAdditionalDocumentsRequest) FilterDocumentTypeIn(filterDocumentTypeIn []string) ApiListAdditionalDocumentsRequest {
	r.filterDocumentTypeIn = &filterDocumentTypeIn
	return r
}

// Specifies the sort order for results. If not given, results are sorted by created_at in descending order.
func (r ApiListAdditionalDocumentsRequest) Sort(sort string) ApiListAdditionalDocumentsRequest {
	r.sort = &sort
	return r
}

func (r ApiListAdditionalDocumentsRequest) Execute() (*ListAdditionalDocuments200Response, *http.Response, error) {
	return r.ApiService.ListAdditionalDocumentsExecute(r)
}

/*
ListAdditionalDocuments List additional documents

Returns a list of additional documents for a porting order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Porting Order id
 @return ApiListAdditionalDocumentsRequest
*/
func (a *PortingOrdersAPIService) ListAdditionalDocuments(ctx context.Context, id string) ApiListAdditionalDocumentsRequest {
	return ApiListAdditionalDocumentsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ListAdditionalDocuments200Response
func (a *PortingOrdersAPIService) ListAdditionalDocumentsExecute(r ApiListAdditionalDocumentsRequest) (*ListAdditionalDocuments200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAdditionalDocuments200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.ListAdditionalDocuments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting_orders/{id}/additional_documents"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.filterDocumentType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[document_type]", r.filterDocumentType, "form", "")
	}
	if r.filterDocumentTypeIn != nil {
		t := *r.filterDocumentTypeIn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[document_type][in][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[document_type][in][]", t, "form", "multi")
		}
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort[]", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAllowedFocWindowsRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	id string
}

func (r ApiListAllowedFocWindowsRequest) Execute() (*ListAllowedFocWindows200Response, *http.Response, error) {
	return r.ApiService.ListAllowedFocWindowsExecute(r)
}

/*
ListAllowedFocWindows List allowed FOC dates

Returns a list of allowed FOC dates for a porting order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Porting Order id
 @return ApiListAllowedFocWindowsRequest
*/
func (a *PortingOrdersAPIService) ListAllowedFocWindows(ctx context.Context, id string) ApiListAllowedFocWindowsRequest {
	return ApiListAllowedFocWindowsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ListAllowedFocWindows200Response
func (a *PortingOrdersAPIService) ListAllowedFocWindowsExecute(r ApiListAllowedFocWindowsRequest) (*ListAllowedFocWindows200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAllowedFocWindows200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.ListAllowedFocWindows")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting_orders/{id}/allowed_foc_windows"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListExceptionTypesRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
}

func (r ApiListExceptionTypesRequest) Execute() (*ListExceptionTypes200Response, *http.Response, error) {
	return r.ApiService.ListExceptionTypesExecute(r)
}

/*
ListExceptionTypes List all exception types

Returns a list of all possible exception types for a porting order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListExceptionTypesRequest
*/
func (a *PortingOrdersAPIService) ListExceptionTypes(ctx context.Context) ApiListExceptionTypesRequest {
	return ApiListExceptionTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListExceptionTypes200Response
func (a *PortingOrdersAPIService) ListExceptionTypesExecute(r ApiListExceptionTypesRequest) (*ListExceptionTypes200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListExceptionTypes200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.ListExceptionTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting_orders/exception_types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListLoaConfigurationsRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	pageNumber *int32
	pageSize *int32
}

// The page number to load.
func (r ApiListLoaConfigurationsRequest) PageNumber(pageNumber int32) ApiListLoaConfigurationsRequest {
	r.pageNumber = &pageNumber
	return r
}

// The size of the page.
func (r ApiListLoaConfigurationsRequest) PageSize(pageSize int32) ApiListLoaConfigurationsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListLoaConfigurationsRequest) Execute() (*ListLoaConfigurations200Response, *http.Response, error) {
	return r.ApiService.ListLoaConfigurationsExecute(r)
}

/*
ListLoaConfigurations List LOA configurations

List the LOA configurations.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListLoaConfigurationsRequest
*/
func (a *PortingOrdersAPIService) ListLoaConfigurations(ctx context.Context) ApiListLoaConfigurationsRequest {
	return ApiListLoaConfigurationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListLoaConfigurations200Response
func (a *PortingOrdersAPIService) ListLoaConfigurationsExecute(r ApiListLoaConfigurationsRequest) (*ListLoaConfigurations200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListLoaConfigurations200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.ListLoaConfigurations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting/loa_configurations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPhoneNumberConfigurationsRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	pageNumber *int32
	pageSize *int32
	filterPortingOrderId *string
	filterPortingOrderIdIn *[]string
	filterPortingOrderStatus *string
	filterPortingOrderStatusIn *[]string
	filterPortingPhoneNumber *string
	filterPortingPhoneNumberIn *[]string
	filterUserBundleId *string
	filterUserBundleIdIn *[]string
	sort *string
}

// The page number to load.
func (r ApiListPhoneNumberConfigurationsRequest) PageNumber(pageNumber int32) ApiListPhoneNumberConfigurationsRequest {
	r.pageNumber = &pageNumber
	return r
}

// The size of the page.
func (r ApiListPhoneNumberConfigurationsRequest) PageSize(pageSize int32) ApiListPhoneNumberConfigurationsRequest {
	r.pageSize = &pageSize
	return r
}

// Filter results by porting order id
func (r ApiListPhoneNumberConfigurationsRequest) FilterPortingOrderId(filterPortingOrderId string) ApiListPhoneNumberConfigurationsRequest {
	r.filterPortingOrderId = &filterPortingOrderId
	return r
}

// Filter results by a list of porting order ids
func (r ApiListPhoneNumberConfigurationsRequest) FilterPortingOrderIdIn(filterPortingOrderIdIn []string) ApiListPhoneNumberConfigurationsRequest {
	r.filterPortingOrderIdIn = &filterPortingOrderIdIn
	return r
}

// Filter results by a specific porting order status
func (r ApiListPhoneNumberConfigurationsRequest) FilterPortingOrderStatus(filterPortingOrderStatus string) ApiListPhoneNumberConfigurationsRequest {
	r.filterPortingOrderStatus = &filterPortingOrderStatus
	return r
}

// Filter results by specific porting order statuses
func (r ApiListPhoneNumberConfigurationsRequest) FilterPortingOrderStatusIn(filterPortingOrderStatusIn []string) ApiListPhoneNumberConfigurationsRequest {
	r.filterPortingOrderStatusIn = &filterPortingOrderStatusIn
	return r
}

// Filter results by a specific porting phone number ID
func (r ApiListPhoneNumberConfigurationsRequest) FilterPortingPhoneNumber(filterPortingPhoneNumber string) ApiListPhoneNumberConfigurationsRequest {
	r.filterPortingPhoneNumber = &filterPortingPhoneNumber
	return r
}

// Filter results by a list of porting phone number IDs
func (r ApiListPhoneNumberConfigurationsRequest) FilterPortingPhoneNumberIn(filterPortingPhoneNumberIn []string) ApiListPhoneNumberConfigurationsRequest {
	r.filterPortingPhoneNumberIn = &filterPortingPhoneNumberIn
	return r
}

// Filter results by a specific user bundle ID
func (r ApiListPhoneNumberConfigurationsRequest) FilterUserBundleId(filterUserBundleId string) ApiListPhoneNumberConfigurationsRequest {
	r.filterUserBundleId = &filterUserBundleId
	return r
}

// Filter results by a list of user bundle IDs
func (r ApiListPhoneNumberConfigurationsRequest) FilterUserBundleIdIn(filterUserBundleIdIn []string) ApiListPhoneNumberConfigurationsRequest {
	r.filterUserBundleIdIn = &filterUserBundleIdIn
	return r
}

// Specifies the sort order for results. If not given, results are sorted by created_at in descending order.
func (r ApiListPhoneNumberConfigurationsRequest) Sort(sort string) ApiListPhoneNumberConfigurationsRequest {
	r.sort = &sort
	return r
}

func (r ApiListPhoneNumberConfigurationsRequest) Execute() (*ListPhoneNumberConfigurations200Response, *http.Response, error) {
	return r.ApiService.ListPhoneNumberConfigurationsExecute(r)
}

/*
ListPhoneNumberConfigurations List all phone number configurations

Returns a list of phone number configurations paginated.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListPhoneNumberConfigurationsRequest
*/
func (a *PortingOrdersAPIService) ListPhoneNumberConfigurations(ctx context.Context) ApiListPhoneNumberConfigurationsRequest {
	return ApiListPhoneNumberConfigurationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListPhoneNumberConfigurations200Response
func (a *PortingOrdersAPIService) ListPhoneNumberConfigurationsExecute(r ApiListPhoneNumberConfigurationsRequest) (*ListPhoneNumberConfigurations200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListPhoneNumberConfigurations200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.ListPhoneNumberConfigurations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting_orders/phone_number_configurations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.filterPortingOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[porting_order_id]", r.filterPortingOrderId, "form", "")
	}
	if r.filterPortingOrderIdIn != nil {
		t := *r.filterPortingOrderIdIn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[porting_order_id][in][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[porting_order_id][in][]", t, "form", "multi")
		}
	}
	if r.filterPortingOrderStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[porting_order.status]", r.filterPortingOrderStatus, "form", "")
	}
	if r.filterPortingOrderStatusIn != nil {
		t := *r.filterPortingOrderStatusIn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[porting_order.status][in][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[porting_order.status][in][]", t, "form", "multi")
		}
	}
	if r.filterPortingPhoneNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[porting_phone_number]", r.filterPortingPhoneNumber, "form", "")
	}
	if r.filterPortingPhoneNumberIn != nil {
		t := *r.filterPortingPhoneNumberIn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[porting_phone_number][in][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[porting_phone_number][in][]", t, "form", "multi")
		}
	}
	if r.filterUserBundleId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[user_bundle_id]", r.filterUserBundleId, "form", "")
	}
	if r.filterUserBundleIdIn != nil {
		t := *r.filterUserBundleIdIn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[user_bundle_id][in][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[user_bundle_id][in][]", t, "form", "multi")
		}
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort[]", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPortingEventsRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	pageNumber *int32
	pageSize *int32
	filterType *string
	filterPortingOrderId *string
	filterCreatedAtGte *time.Time
	filterCreatedAtLte *time.Time
}

// The page number to load.
func (r ApiListPortingEventsRequest) PageNumber(pageNumber int32) ApiListPortingEventsRequest {
	r.pageNumber = &pageNumber
	return r
}

// The size of the page.
func (r ApiListPortingEventsRequest) PageSize(pageSize int32) ApiListPortingEventsRequest {
	r.pageSize = &pageSize
	return r
}

// Filter by event type.
func (r ApiListPortingEventsRequest) FilterType(filterType string) ApiListPortingEventsRequest {
	r.filterType = &filterType
	return r
}

// Filter by porting order ID.
func (r ApiListPortingEventsRequest) FilterPortingOrderId(filterPortingOrderId string) ApiListPortingEventsRequest {
	r.filterPortingOrderId = &filterPortingOrderId
	return r
}

// Filter by created at greater than or equal to.
func (r ApiListPortingEventsRequest) FilterCreatedAtGte(filterCreatedAtGte time.Time) ApiListPortingEventsRequest {
	r.filterCreatedAtGte = &filterCreatedAtGte
	return r
}

// Filter by created at less than or equal to.
func (r ApiListPortingEventsRequest) FilterCreatedAtLte(filterCreatedAtLte time.Time) ApiListPortingEventsRequest {
	r.filterCreatedAtLte = &filterCreatedAtLte
	return r
}

func (r ApiListPortingEventsRequest) Execute() (*ListPortingEvents200Response, *http.Response, error) {
	return r.ApiService.ListPortingEventsExecute(r)
}

/*
ListPortingEvents List all porting events

Returns a list of all porting events.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListPortingEventsRequest
*/
func (a *PortingOrdersAPIService) ListPortingEvents(ctx context.Context) ApiListPortingEventsRequest {
	return ApiListPortingEventsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListPortingEvents200Response
func (a *PortingOrdersAPIService) ListPortingEventsExecute(r ApiListPortingEventsRequest) (*ListPortingEvents200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListPortingEvents200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.ListPortingEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting/events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.filterType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[type]", r.filterType, "form", "")
	}
	if r.filterPortingOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[porting_order_id]", r.filterPortingOrderId, "form", "")
	}
	if r.filterCreatedAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[created_at][gte]", r.filterCreatedAtGte, "form", "")
	}
	if r.filterCreatedAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[created_at][lte]", r.filterCreatedAtLte, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPortingOrderActivationJobsRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	id string
	pageNumber *int32
	pageSize *int32
}

// The page number to load.
func (r ApiListPortingOrderActivationJobsRequest) PageNumber(pageNumber int32) ApiListPortingOrderActivationJobsRequest {
	r.pageNumber = &pageNumber
	return r
}

// The size of the page.
func (r ApiListPortingOrderActivationJobsRequest) PageSize(pageSize int32) ApiListPortingOrderActivationJobsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListPortingOrderActivationJobsRequest) Execute() (*ListPortingOrderActivationJobs200Response, *http.Response, error) {
	return r.ApiService.ListPortingOrderActivationJobsExecute(r)
}

/*
ListPortingOrderActivationJobs List all porting activation jobs

Returns a list of your porting activation jobs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Porting Order id
 @return ApiListPortingOrderActivationJobsRequest
*/
func (a *PortingOrdersAPIService) ListPortingOrderActivationJobs(ctx context.Context, id string) ApiListPortingOrderActivationJobsRequest {
	return ApiListPortingOrderActivationJobsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ListPortingOrderActivationJobs200Response
func (a *PortingOrdersAPIService) ListPortingOrderActivationJobsExecute(r ApiListPortingOrderActivationJobsRequest) (*ListPortingOrderActivationJobs200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListPortingOrderActivationJobs200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.ListPortingOrderActivationJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting_orders/{id}/activation_jobs"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPortingOrderCommentsRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	id string
	pageNumber *int32
	pageSize *int32
}

// The page number to load.
func (r ApiListPortingOrderCommentsRequest) PageNumber(pageNumber int32) ApiListPortingOrderCommentsRequest {
	r.pageNumber = &pageNumber
	return r
}

// The size of the page.
func (r ApiListPortingOrderCommentsRequest) PageSize(pageSize int32) ApiListPortingOrderCommentsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListPortingOrderCommentsRequest) Execute() (*ListPortingOrderComments200Response, *http.Response, error) {
	return r.ApiService.ListPortingOrderCommentsExecute(r)
}

/*
ListPortingOrderComments List all comments of a porting order

Returns a list of all comments of a porting order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Porting Order id
 @return ApiListPortingOrderCommentsRequest
*/
func (a *PortingOrdersAPIService) ListPortingOrderComments(ctx context.Context, id string) ApiListPortingOrderCommentsRequest {
	return ApiListPortingOrderCommentsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ListPortingOrderComments200Response
func (a *PortingOrdersAPIService) ListPortingOrderCommentsExecute(r ApiListPortingOrderCommentsRequest) (*ListPortingOrderComments200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListPortingOrderComments200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.ListPortingOrderComments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting_orders/{id}/comments"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPortingOrderRequirementsRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	id string
	pageNumber *int32
	pageSize *int32
}

// The page number to load.
func (r ApiListPortingOrderRequirementsRequest) PageNumber(pageNumber int32) ApiListPortingOrderRequirementsRequest {
	r.pageNumber = &pageNumber
	return r
}

// The size of the page.
func (r ApiListPortingOrderRequirementsRequest) PageSize(pageSize int32) ApiListPortingOrderRequirementsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListPortingOrderRequirementsRequest) Execute() (*ListPortingOrderRequirements200Response, *http.Response, error) {
	return r.ApiService.ListPortingOrderRequirementsExecute(r)
}

/*
ListPortingOrderRequirements List porting order requirements

Returns a list of all requirements based on country/number type for this porting order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Porting Order id
 @return ApiListPortingOrderRequirementsRequest
*/
func (a *PortingOrdersAPIService) ListPortingOrderRequirements(ctx context.Context, id string) ApiListPortingOrderRequirementsRequest {
	return ApiListPortingOrderRequirementsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ListPortingOrderRequirements200Response
func (a *PortingOrdersAPIService) ListPortingOrderRequirementsExecute(r ApiListPortingOrderRequirementsRequest) (*ListPortingOrderRequirements200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListPortingOrderRequirements200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.ListPortingOrderRequirements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting_orders/{id}/requirements"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPortingOrdersRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	pageNumber *int32
	pageSize *int32
	includePhoneNumbers *bool
	filterStatus *string
	filterStatusIn *string
	filterCustomerReference *string
	filterParentSupportKey *string
	filterPhoneNumbersCountryCode *string
	filterPhoneNumbersCarrierName *string
	filterMiscType *PortingOrderType
	filterEndUserAdminEntityName *string
	filterEndUserAdminAuthPersonName *string
	filterActivationSettingsFastPortEligible *bool
	filterActivationSettingsFocDatetimeRequestedGt *string
	filterActivationSettingsFocDatetimeRequestedLt *string
	filterPhoneNumbersPhoneNumberContains *string
	sort *string
}

// The page number to load.
func (r ApiListPortingOrdersRequest) PageNumber(pageNumber int32) ApiListPortingOrdersRequest {
	r.pageNumber = &pageNumber
	return r
}

// The size of the page.
func (r ApiListPortingOrdersRequest) PageSize(pageSize int32) ApiListPortingOrdersRequest {
	r.pageSize = &pageSize
	return r
}

// Include the first 50 phone number objects in the results
func (r ApiListPortingOrdersRequest) IncludePhoneNumbers(includePhoneNumbers bool) ApiListPortingOrdersRequest {
	r.includePhoneNumbers = &includePhoneNumbers
	return r
}

// Filter results by status
func (r ApiListPortingOrdersRequest) FilterStatus(filterStatus string) ApiListPortingOrdersRequest {
	r.filterStatus = &filterStatus
	return r
}

// Filter porting orders by multiple statuses
func (r ApiListPortingOrdersRequest) FilterStatusIn(filterStatusIn string) ApiListPortingOrdersRequest {
	r.filterStatusIn = &filterStatusIn
	return r
}

// Filter results by customer_reference
func (r ApiListPortingOrdersRequest) FilterCustomerReference(filterCustomerReference string) ApiListPortingOrdersRequest {
	r.filterCustomerReference = &filterCustomerReference
	return r
}

// Filter results by parent_support_key
func (r ApiListPortingOrdersRequest) FilterParentSupportKey(filterParentSupportKey string) ApiListPortingOrdersRequest {
	r.filterParentSupportKey = &filterParentSupportKey
	return r
}

// Filter results by country ISO 3166-1 alpha-2 code
func (r ApiListPortingOrdersRequest) FilterPhoneNumbersCountryCode(filterPhoneNumbersCountryCode string) ApiListPortingOrdersRequest {
	r.filterPhoneNumbersCountryCode = &filterPhoneNumbersCountryCode
	return r
}

// Filter results by old service provider
func (r ApiListPortingOrdersRequest) FilterPhoneNumbersCarrierName(filterPhoneNumbersCarrierName string) ApiListPortingOrdersRequest {
	r.filterPhoneNumbersCarrierName = &filterPhoneNumbersCarrierName
	return r
}

// Filter results by porting order type
func (r ApiListPortingOrdersRequest) FilterMiscType(filterMiscType PortingOrderType) ApiListPortingOrdersRequest {
	r.filterMiscType = &filterMiscType
	return r
}

// Filter results by person or company name
func (r ApiListPortingOrdersRequest) FilterEndUserAdminEntityName(filterEndUserAdminEntityName string) ApiListPortingOrdersRequest {
	r.filterEndUserAdminEntityName = &filterEndUserAdminEntityName
	return r
}

// Filter results by authorized person
func (r ApiListPortingOrdersRequest) FilterEndUserAdminAuthPersonName(filterEndUserAdminAuthPersonName string) ApiListPortingOrdersRequest {
	r.filterEndUserAdminAuthPersonName = &filterEndUserAdminAuthPersonName
	return r
}

// Filter results by fast port eligible
func (r ApiListPortingOrdersRequest) FilterActivationSettingsFastPortEligible(filterActivationSettingsFastPortEligible bool) ApiListPortingOrdersRequest {
	r.filterActivationSettingsFastPortEligible = &filterActivationSettingsFastPortEligible
	return r
}

// Filter results by foc date later than this value
func (r ApiListPortingOrdersRequest) FilterActivationSettingsFocDatetimeRequestedGt(filterActivationSettingsFocDatetimeRequestedGt string) ApiListPortingOrdersRequest {
	r.filterActivationSettingsFocDatetimeRequestedGt = &filterActivationSettingsFocDatetimeRequestedGt
	return r
}

// Filter results by foc date earlier than this value
func (r ApiListPortingOrdersRequest) FilterActivationSettingsFocDatetimeRequestedLt(filterActivationSettingsFocDatetimeRequestedLt string) ApiListPortingOrdersRequest {
	r.filterActivationSettingsFocDatetimeRequestedLt = &filterActivationSettingsFocDatetimeRequestedLt
	return r
}

// Filter results by full or partial phone_number
func (r ApiListPortingOrdersRequest) FilterPhoneNumbersPhoneNumberContains(filterPhoneNumbersPhoneNumberContains string) ApiListPortingOrdersRequest {
	r.filterPhoneNumbersPhoneNumberContains = &filterPhoneNumbersPhoneNumberContains
	return r
}

// Specifies the sort order for results. If not given, results are sorted by created_at in descending order.
func (r ApiListPortingOrdersRequest) Sort(sort string) ApiListPortingOrdersRequest {
	r.sort = &sort
	return r
}

func (r ApiListPortingOrdersRequest) Execute() (*ListPortingOrders200Response, *http.Response, error) {
	return r.ApiService.ListPortingOrdersExecute(r)
}

/*
ListPortingOrders List all porting orders

Returns a list of your porting order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListPortingOrdersRequest
*/
func (a *PortingOrdersAPIService) ListPortingOrders(ctx context.Context) ApiListPortingOrdersRequest {
	return ApiListPortingOrdersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListPortingOrders200Response
func (a *PortingOrdersAPIService) ListPortingOrdersExecute(r ApiListPortingOrdersRequest) (*ListPortingOrders200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListPortingOrders200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.ListPortingOrders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting_orders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.includePhoneNumbers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_phone_numbers", r.includePhoneNumbers, "form", "")
	} else {
		var defaultValue bool = true
		r.includePhoneNumbers = &defaultValue
	}
	if r.filterStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[status]", r.filterStatus, "form", "")
	}
	if r.filterStatusIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[status][in][]", r.filterStatusIn, "form", "")
	}
	if r.filterCustomerReference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[customer_reference]", r.filterCustomerReference, "form", "")
	}
	if r.filterParentSupportKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[parent_support_key]", r.filterParentSupportKey, "form", "")
	}
	if r.filterPhoneNumbersCountryCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[phone_numbers.country_code]", r.filterPhoneNumbersCountryCode, "form", "")
	}
	if r.filterPhoneNumbersCarrierName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[phone_numbers.carrier_name]", r.filterPhoneNumbersCarrierName, "form", "")
	}
	if r.filterMiscType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[misc.type]", r.filterMiscType, "form", "")
	}
	if r.filterEndUserAdminEntityName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[end_user.admin.entity_name]", r.filterEndUserAdminEntityName, "form", "")
	}
	if r.filterEndUserAdminAuthPersonName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[end_user.admin.auth_person_name]", r.filterEndUserAdminAuthPersonName, "form", "")
	}
	if r.filterActivationSettingsFastPortEligible != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[activation_settings.fast_port_eligible]", r.filterActivationSettingsFastPortEligible, "form", "")
	}
	if r.filterActivationSettingsFocDatetimeRequestedGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[activation_settings.foc_datetime_requested][gt]", r.filterActivationSettingsFocDatetimeRequestedGt, "form", "")
	}
	if r.filterActivationSettingsFocDatetimeRequestedLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[activation_settings.foc_datetime_requested][lt]", r.filterActivationSettingsFocDatetimeRequestedLt, "form", "")
	}
	if r.filterPhoneNumbersPhoneNumberContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[phone_numbers.phone_number][contains]", r.filterPhoneNumbersPhoneNumberContains, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort[]", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPortingPhoneNumberBlocksRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	portingOrderId string
	filterPhoneNumber *string
	filterPhoneNumberIn *[]string
	sort *string
	pageNumber *int32
	pageSize *int32
}

// Filter results by phone number
func (r ApiListPortingPhoneNumberBlocksRequest) FilterPhoneNumber(filterPhoneNumber string) ApiListPortingPhoneNumberBlocksRequest {
	r.filterPhoneNumber = &filterPhoneNumber
	return r
}

// Filter results by a list of phone numbers
func (r ApiListPortingPhoneNumberBlocksRequest) FilterPhoneNumberIn(filterPhoneNumberIn []string) ApiListPortingPhoneNumberBlocksRequest {
	r.filterPhoneNumberIn = &filterPhoneNumberIn
	return r
}

// Specifies the sort order for results. If not given, results are sorted by created_at in descending order
func (r ApiListPortingPhoneNumberBlocksRequest) Sort(sort string) ApiListPortingPhoneNumberBlocksRequest {
	r.sort = &sort
	return r
}

// The page number to load.
func (r ApiListPortingPhoneNumberBlocksRequest) PageNumber(pageNumber int32) ApiListPortingPhoneNumberBlocksRequest {
	r.pageNumber = &pageNumber
	return r
}

// The size of the page.
func (r ApiListPortingPhoneNumberBlocksRequest) PageSize(pageSize int32) ApiListPortingPhoneNumberBlocksRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListPortingPhoneNumberBlocksRequest) Execute() (*ListPortingPhoneNumberBlocks200Response, *http.Response, error) {
	return r.ApiService.ListPortingPhoneNumberBlocksExecute(r)
}

/*
ListPortingPhoneNumberBlocks List all phone number blocks

Returns a list of all phone number blocks of a porting order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portingOrderId Identifies the Porting Order associated with the phone number blocks
 @return ApiListPortingPhoneNumberBlocksRequest
*/
func (a *PortingOrdersAPIService) ListPortingPhoneNumberBlocks(ctx context.Context, portingOrderId string) ApiListPortingPhoneNumberBlocksRequest {
	return ApiListPortingPhoneNumberBlocksRequest{
		ApiService: a,
		ctx: ctx,
		portingOrderId: portingOrderId,
	}
}

// Execute executes the request
//  @return ListPortingPhoneNumberBlocks200Response
func (a *PortingOrdersAPIService) ListPortingPhoneNumberBlocksExecute(r ApiListPortingPhoneNumberBlocksRequest) (*ListPortingPhoneNumberBlocks200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListPortingPhoneNumberBlocks200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.ListPortingPhoneNumberBlocks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting_orders/{porting_order_id}/phone_number_blocks"
	localVarPath = strings.Replace(localVarPath, "{"+"porting_order_id"+"}", url.PathEscape(parameterValueToString(r.portingOrderId, "portingOrderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPhoneNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[phone_number]", r.filterPhoneNumber, "form", "")
	}
	if r.filterPhoneNumberIn != nil {
		t := *r.filterPhoneNumberIn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[phone_number][in][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[phone_number][in][]", t, "form", "multi")
		}
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort[]", r.sort, "form", "")
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPortingPhoneNumberExtensionsRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	portingOrderId string
	filterPhoneNumber *string
	filterPhoneNumberIn *[]string
	filterPortingPhoneNumberId *string
	filterPortingPhoneNumberIdIn *string
	sort *string
	pageNumber *int32
	pageSize *int32
}

// Filter results by phone number
func (r ApiListPortingPhoneNumberExtensionsRequest) FilterPhoneNumber(filterPhoneNumber string) ApiListPortingPhoneNumberExtensionsRequest {
	r.filterPhoneNumber = &filterPhoneNumber
	return r
}

// Filter results by a list of phone numbers
func (r ApiListPortingPhoneNumberExtensionsRequest) FilterPhoneNumberIn(filterPhoneNumberIn []string) ApiListPortingPhoneNumberExtensionsRequest {
	r.filterPhoneNumberIn = &filterPhoneNumberIn
	return r
}

// Filter results by porting phone number id
func (r ApiListPortingPhoneNumberExtensionsRequest) FilterPortingPhoneNumberId(filterPortingPhoneNumberId string) ApiListPortingPhoneNumberExtensionsRequest {
	r.filterPortingPhoneNumberId = &filterPortingPhoneNumberId
	return r
}

// Filter results by a list of porting phone number ids
func (r ApiListPortingPhoneNumberExtensionsRequest) FilterPortingPhoneNumberIdIn(filterPortingPhoneNumberIdIn string) ApiListPortingPhoneNumberExtensionsRequest {
	r.filterPortingPhoneNumberIdIn = &filterPortingPhoneNumberIdIn
	return r
}

// Specifies the sort order for results. If not given, results are sorted by created_at in descending order
func (r ApiListPortingPhoneNumberExtensionsRequest) Sort(sort string) ApiListPortingPhoneNumberExtensionsRequest {
	r.sort = &sort
	return r
}

// The page number to load.
func (r ApiListPortingPhoneNumberExtensionsRequest) PageNumber(pageNumber int32) ApiListPortingPhoneNumberExtensionsRequest {
	r.pageNumber = &pageNumber
	return r
}

// The size of the page.
func (r ApiListPortingPhoneNumberExtensionsRequest) PageSize(pageSize int32) ApiListPortingPhoneNumberExtensionsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListPortingPhoneNumberExtensionsRequest) Execute() (*ListPortingPhoneNumberExtensions200Response, *http.Response, error) {
	return r.ApiService.ListPortingPhoneNumberExtensionsExecute(r)
}

/*
ListPortingPhoneNumberExtensions List all phone number extensions

Returns a list of all phone number extensions of a porting order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portingOrderId Identifies the Porting Order associated with the phone number extensions
 @return ApiListPortingPhoneNumberExtensionsRequest
*/
func (a *PortingOrdersAPIService) ListPortingPhoneNumberExtensions(ctx context.Context, portingOrderId string) ApiListPortingPhoneNumberExtensionsRequest {
	return ApiListPortingPhoneNumberExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		portingOrderId: portingOrderId,
	}
}

// Execute executes the request
//  @return ListPortingPhoneNumberExtensions200Response
func (a *PortingOrdersAPIService) ListPortingPhoneNumberExtensionsExecute(r ApiListPortingPhoneNumberExtensionsRequest) (*ListPortingPhoneNumberExtensions200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListPortingPhoneNumberExtensions200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.ListPortingPhoneNumberExtensions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting_orders/{porting_order_id}/phone_number_extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"porting_order_id"+"}", url.PathEscape(parameterValueToString(r.portingOrderId, "portingOrderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPhoneNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[phone_number]", r.filterPhoneNumber, "form", "")
	}
	if r.filterPhoneNumberIn != nil {
		t := *r.filterPhoneNumberIn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[phone_number][in][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[phone_number][in][]", t, "form", "multi")
		}
	}
	if r.filterPortingPhoneNumberId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[porting_phone_number_id]", r.filterPortingPhoneNumberId, "form", "")
	}
	if r.filterPortingPhoneNumberIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[porting_phone_number_id][in][]", r.filterPortingPhoneNumberIdIn, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort[]", r.sort, "form", "")
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPortingPhoneNumbersRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	pageNumber *int32
	pageSize *int32
	filterPortingOrderId *string
	filterPortingOrderIdIn *[]string
	filterSupportKeyEq *string
	filterSupportKeyIn *[]string
	filterPhoneNumber *string
	filterPhoneNumberIn *[]string
	filterPortingOrderStatus *string
	filterActivationStatus *PortingOrderActivationStatus
	filterPortabilityStatus *PortabilityStatus
}

// The page number to load.
func (r ApiListPortingPhoneNumbersRequest) PageNumber(pageNumber int32) ApiListPortingPhoneNumbersRequest {
	r.pageNumber = &pageNumber
	return r
}

// The size of the page.
func (r ApiListPortingPhoneNumbersRequest) PageSize(pageSize int32) ApiListPortingPhoneNumbersRequest {
	r.pageSize = &pageSize
	return r
}

// Filter results by porting order id
func (r ApiListPortingPhoneNumbersRequest) FilterPortingOrderId(filterPortingOrderId string) ApiListPortingPhoneNumbersRequest {
	r.filterPortingOrderId = &filterPortingOrderId
	return r
}

// Filter results by a list of porting order ids
func (r ApiListPortingPhoneNumbersRequest) FilterPortingOrderIdIn(filterPortingOrderIdIn []string) ApiListPortingPhoneNumbersRequest {
	r.filterPortingOrderIdIn = &filterPortingOrderIdIn
	return r
}

// Filter results by support key
func (r ApiListPortingPhoneNumbersRequest) FilterSupportKeyEq(filterSupportKeyEq string) ApiListPortingPhoneNumbersRequest {
	r.filterSupportKeyEq = &filterSupportKeyEq
	return r
}

// Filter results by a list of support keys
func (r ApiListPortingPhoneNumbersRequest) FilterSupportKeyIn(filterSupportKeyIn []string) ApiListPortingPhoneNumbersRequest {
	r.filterSupportKeyIn = &filterSupportKeyIn
	return r
}

// Filter results by phone number
func (r ApiListPortingPhoneNumbersRequest) FilterPhoneNumber(filterPhoneNumber string) ApiListPortingPhoneNumbersRequest {
	r.filterPhoneNumber = &filterPhoneNumber
	return r
}

// Filter results by a list of phone numbers
func (r ApiListPortingPhoneNumbersRequest) FilterPhoneNumberIn(filterPhoneNumberIn []string) ApiListPortingPhoneNumbersRequest {
	r.filterPhoneNumberIn = &filterPhoneNumberIn
	return r
}

// Filter results by porting order status
func (r ApiListPortingPhoneNumbersRequest) FilterPortingOrderStatus(filterPortingOrderStatus string) ApiListPortingPhoneNumbersRequest {
	r.filterPortingOrderStatus = &filterPortingOrderStatus
	return r
}

// Filter results by activation status
func (r ApiListPortingPhoneNumbersRequest) FilterActivationStatus(filterActivationStatus PortingOrderActivationStatus) ApiListPortingPhoneNumbersRequest {
	r.filterActivationStatus = &filterActivationStatus
	return r
}

// Filter results by portability status
func (r ApiListPortingPhoneNumbersRequest) FilterPortabilityStatus(filterPortabilityStatus PortabilityStatus) ApiListPortingPhoneNumbersRequest {
	r.filterPortabilityStatus = &filterPortabilityStatus
	return r
}

func (r ApiListPortingPhoneNumbersRequest) Execute() (*ListPortingPhoneNumbers200Response, *http.Response, error) {
	return r.ApiService.ListPortingPhoneNumbersExecute(r)
}

/*
ListPortingPhoneNumbers List all porting phone numbers

Returns a list of your porting phone numbers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListPortingPhoneNumbersRequest
*/
func (a *PortingOrdersAPIService) ListPortingPhoneNumbers(ctx context.Context) ApiListPortingPhoneNumbersRequest {
	return ApiListPortingPhoneNumbersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListPortingPhoneNumbers200Response
func (a *PortingOrdersAPIService) ListPortingPhoneNumbersExecute(r ApiListPortingPhoneNumbersRequest) (*ListPortingPhoneNumbers200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListPortingPhoneNumbers200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.ListPortingPhoneNumbers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting_phone_numbers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.filterPortingOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[porting_order_id]", r.filterPortingOrderId, "form", "")
	}
	if r.filterPortingOrderIdIn != nil {
		t := *r.filterPortingOrderIdIn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[porting_order_id][in][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[porting_order_id][in][]", t, "form", "multi")
		}
	}
	if r.filterSupportKeyEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[support_key][eq]", r.filterSupportKeyEq, "form", "")
	}
	if r.filterSupportKeyIn != nil {
		t := *r.filterSupportKeyIn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[support_key][in][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[support_key][in][]", t, "form", "multi")
		}
	}
	if r.filterPhoneNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[phone_number]", r.filterPhoneNumber, "form", "")
	}
	if r.filterPhoneNumberIn != nil {
		t := *r.filterPhoneNumberIn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[phone_number][in][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[phone_number][in][]", t, "form", "multi")
		}
	}
	if r.filterPortingOrderStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[porting_order_status]", r.filterPortingOrderStatus, "form", "")
	}
	if r.filterActivationStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[activation_status]", r.filterActivationStatus, "form", "")
	}
	if r.filterPortabilityStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[portability_status]", r.filterPortabilityStatus, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPortingReportsRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	pageNumber *int32
	pageSize *int32
	filterReportType *string
	filterStatus *string
}

// The page number to load.
func (r ApiListPortingReportsRequest) PageNumber(pageNumber int32) ApiListPortingReportsRequest {
	r.pageNumber = &pageNumber
	return r
}

// The size of the page.
func (r ApiListPortingReportsRequest) PageSize(pageSize int32) ApiListPortingReportsRequest {
	r.pageSize = &pageSize
	return r
}

// Filter reports of a specific type
func (r ApiListPortingReportsRequest) FilterReportType(filterReportType string) ApiListPortingReportsRequest {
	r.filterReportType = &filterReportType
	return r
}

// Filter reports of a specific status
func (r ApiListPortingReportsRequest) FilterStatus(filterStatus string) ApiListPortingReportsRequest {
	r.filterStatus = &filterStatus
	return r
}

func (r ApiListPortingReportsRequest) Execute() (*ListPortingReports200Response, *http.Response, error) {
	return r.ApiService.ListPortingReportsExecute(r)
}

/*
ListPortingReports List porting related reports

List the reports generated about porting operations.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListPortingReportsRequest
*/
func (a *PortingOrdersAPIService) ListPortingReports(ctx context.Context) ApiListPortingReportsRequest {
	return ApiListPortingReportsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListPortingReports200Response
func (a *PortingOrdersAPIService) ListPortingReportsExecute(r ApiListPortingReportsRequest) (*ListPortingReports200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListPortingReports200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.ListPortingReports")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting/reports"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.filterReportType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[report_type]", r.filterReportType, "form", "")
	}
	if r.filterStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[status]", r.filterStatus, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListVerificationCodesRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	id string
	pageNumber *int32
	pageSize *int32
	filterPhoneNumber *string
	filterPhoneNumberIn *[]string
	filterVerified *bool
	sort *string
}

// The page number to load.
func (r ApiListVerificationCodesRequest) PageNumber(pageNumber int32) ApiListVerificationCodesRequest {
	r.pageNumber = &pageNumber
	return r
}

// The size of the page.
func (r ApiListVerificationCodesRequest) PageSize(pageSize int32) ApiListVerificationCodesRequest {
	r.pageSize = &pageSize
	return r
}

// Filter results by phone number
func (r ApiListVerificationCodesRequest) FilterPhoneNumber(filterPhoneNumber string) ApiListVerificationCodesRequest {
	r.filterPhoneNumber = &filterPhoneNumber
	return r
}

// Filter results by a list of phone numbers
func (r ApiListVerificationCodesRequest) FilterPhoneNumberIn(filterPhoneNumberIn []string) ApiListVerificationCodesRequest {
	r.filterPhoneNumberIn = &filterPhoneNumberIn
	return r
}

// Filter verification codes that have been verified or not
func (r ApiListVerificationCodesRequest) FilterVerified(filterVerified bool) ApiListVerificationCodesRequest {
	r.filterVerified = &filterVerified
	return r
}

// Specifies the sort order for results. If not given, results are sorted by created_at in descending order.
func (r ApiListVerificationCodesRequest) Sort(sort string) ApiListVerificationCodesRequest {
	r.sort = &sort
	return r
}

func (r ApiListVerificationCodesRequest) Execute() (*ListVerificationCodes200Response, *http.Response, error) {
	return r.ApiService.ListVerificationCodesExecute(r)
}

/*
ListVerificationCodes List verification codes

Returns a list of verification codes for a porting order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Porting Order id
 @return ApiListVerificationCodesRequest
*/
func (a *PortingOrdersAPIService) ListVerificationCodes(ctx context.Context, id string) ApiListVerificationCodesRequest {
	return ApiListVerificationCodesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ListVerificationCodes200Response
func (a *PortingOrdersAPIService) ListVerificationCodesExecute(r ApiListVerificationCodesRequest) (*ListVerificationCodes200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListVerificationCodes200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.ListVerificationCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting_orders/{id}/verification_codes"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.filterPhoneNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[phone_number]", r.filterPhoneNumber, "form", "")
	}
	if r.filterPhoneNumberIn != nil {
		t := *r.filterPhoneNumberIn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[phone_number][in][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[phone_number][in][]", t, "form", "multi")
		}
	}
	if r.filterVerified != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[verified]", r.filterVerified, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort[]", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPreviewLoaConfigurationRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	id string
}

func (r ApiPreviewLoaConfigurationRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.PreviewLoaConfigurationExecute(r)
}

/*
PreviewLoaConfiguration Preview a LOA configuration

Preview a specific LOA configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies a LOA configuration.
 @return ApiPreviewLoaConfigurationRequest
*/
func (a *PortingOrdersAPIService) PreviewLoaConfiguration(ctx context.Context, id string) ApiPreviewLoaConfigurationRequest {
	return ApiPreviewLoaConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return *os.File
func (a *PortingOrdersAPIService) PreviewLoaConfigurationExecute(r ApiPreviewLoaConfigurationRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.PreviewLoaConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting/loa_configurations/{id}/preview"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/pdf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPreviewLoaConfigurationParamsRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	previewLoaConfigurationParamsRequest *PreviewLoaConfigurationParamsRequest
}

func (r ApiPreviewLoaConfigurationParamsRequest) PreviewLoaConfigurationParamsRequest(previewLoaConfigurationParamsRequest PreviewLoaConfigurationParamsRequest) ApiPreviewLoaConfigurationParamsRequest {
	r.previewLoaConfigurationParamsRequest = &previewLoaConfigurationParamsRequest
	return r
}

func (r ApiPreviewLoaConfigurationParamsRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.PreviewLoaConfigurationParamsExecute(r)
}

/*
PreviewLoaConfigurationParams Preview the LOA configuration parameters

Preview the LOA template that would be generated without need to create LOA configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPreviewLoaConfigurationParamsRequest
*/
func (a *PortingOrdersAPIService) PreviewLoaConfigurationParams(ctx context.Context) ApiPreviewLoaConfigurationParamsRequest {
	return ApiPreviewLoaConfigurationParamsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return *os.File
func (a *PortingOrdersAPIService) PreviewLoaConfigurationParamsExecute(r ApiPreviewLoaConfigurationParamsRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.PreviewLoaConfigurationParams")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting/loa_configuration/preview"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.previewLoaConfigurationParamsRequest == nil {
		return localVarReturnValue, nil, reportError("previewLoaConfigurationParamsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/pdf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.previewLoaConfigurationParamsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepublishPortingEventRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	id string
}

func (r ApiRepublishPortingEventRequest) Execute() (*http.Response, error) {
	return r.ApiService.RepublishPortingEventExecute(r)
}

/*
RepublishPortingEvent Republish a porting event

Republish a specific porting event.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the porting event.
 @return ApiRepublishPortingEventRequest
*/
func (a *PortingOrdersAPIService) RepublishPortingEvent(ctx context.Context, id string) ApiRepublishPortingEventRequest {
	return ApiRepublishPortingEventRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *PortingOrdersAPIService) RepublishPortingEventExecute(r ApiRepublishPortingEventRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.RepublishPortingEvent")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting/events/{id}/republish"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSendPortingVerificationCodesRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	id string
	sendPortingVerificationCodesRequest *SendPortingVerificationCodesRequest
}

// A list of phone numbers to send the verification codes to and the method to send them by
func (r ApiSendPortingVerificationCodesRequest) SendPortingVerificationCodesRequest(sendPortingVerificationCodesRequest SendPortingVerificationCodesRequest) ApiSendPortingVerificationCodesRequest {
	r.sendPortingVerificationCodesRequest = &sendPortingVerificationCodesRequest
	return r
}

func (r ApiSendPortingVerificationCodesRequest) Execute() (*http.Response, error) {
	return r.ApiService.SendPortingVerificationCodesExecute(r)
}

/*
SendPortingVerificationCodes Send the verification codes

Send the verification code for all porting phone numbers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Porting Order id
 @return ApiSendPortingVerificationCodesRequest
*/
func (a *PortingOrdersAPIService) SendPortingVerificationCodes(ctx context.Context, id string) ApiSendPortingVerificationCodesRequest {
	return ApiSendPortingVerificationCodesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *PortingOrdersAPIService) SendPortingVerificationCodesExecute(r ApiSendPortingVerificationCodesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.SendPortingVerificationCodes")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting_orders/{id}/verification_codes/send"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sendPortingVerificationCodesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSharePortingOrderRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	id string
	sharePortingOrderRequest *SharePortingOrderRequest
}

func (r ApiSharePortingOrderRequest) SharePortingOrderRequest(sharePortingOrderRequest SharePortingOrderRequest) ApiSharePortingOrderRequest {
	r.sharePortingOrderRequest = &sharePortingOrderRequest
	return r
}

func (r ApiSharePortingOrderRequest) Execute() (*SharePortingOrder201Response, *http.Response, error) {
	return r.ApiService.SharePortingOrderExecute(r)
}

/*
SharePortingOrder Share a porting order

Creates a sharing token for a porting order. The token can be used to share the porting order with non-Telnyx users.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Porting Order id
 @return ApiSharePortingOrderRequest
*/
func (a *PortingOrdersAPIService) SharePortingOrder(ctx context.Context, id string) ApiSharePortingOrderRequest {
	return ApiSharePortingOrderRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SharePortingOrder201Response
func (a *PortingOrdersAPIService) SharePortingOrderExecute(r ApiSharePortingOrderRequest) (*SharePortingOrder201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SharePortingOrder201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.SharePortingOrder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting_orders/{id}/actions/share"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sharePortingOrderRequest == nil {
		return localVarReturnValue, nil, reportError("sharePortingOrderRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharePortingOrderRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShowPortingEventRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	id string
}

func (r ApiShowPortingEventRequest) Execute() (*ShowPortingEvent200Response, *http.Response, error) {
	return r.ApiService.ShowPortingEventExecute(r)
}

/*
ShowPortingEvent Show a porting event

Show a specific porting event.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the porting event.
 @return ApiShowPortingEventRequest
*/
func (a *PortingOrdersAPIService) ShowPortingEvent(ctx context.Context, id string) ApiShowPortingEventRequest {
	return ApiShowPortingEventRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ShowPortingEvent200Response
func (a *PortingOrdersAPIService) ShowPortingEventExecute(r ApiShowPortingEventRequest) (*ShowPortingEvent200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShowPortingEvent200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.ShowPortingEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting/events/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateLoaConfigurationRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	id string
	previewLoaConfigurationParamsRequest *PreviewLoaConfigurationParamsRequest
}

func (r ApiUpdateLoaConfigurationRequest) PreviewLoaConfigurationParamsRequest(previewLoaConfigurationParamsRequest PreviewLoaConfigurationParamsRequest) ApiUpdateLoaConfigurationRequest {
	r.previewLoaConfigurationParamsRequest = &previewLoaConfigurationParamsRequest
	return r
}

func (r ApiUpdateLoaConfigurationRequest) Execute() (*CreateLoaConfiguration201Response, *http.Response, error) {
	return r.ApiService.UpdateLoaConfigurationExecute(r)
}

/*
UpdateLoaConfiguration Update a LOA configuration

Update a specific LOA configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies a LOA configuration.
 @return ApiUpdateLoaConfigurationRequest
*/
func (a *PortingOrdersAPIService) UpdateLoaConfiguration(ctx context.Context, id string) ApiUpdateLoaConfigurationRequest {
	return ApiUpdateLoaConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreateLoaConfiguration201Response
func (a *PortingOrdersAPIService) UpdateLoaConfigurationExecute(r ApiUpdateLoaConfigurationRequest) (*CreateLoaConfiguration201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLoaConfiguration201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.UpdateLoaConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting/loa_configurations/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.previewLoaConfigurationParamsRequest == nil {
		return localVarReturnValue, nil, reportError("previewLoaConfigurationParamsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.previewLoaConfigurationParamsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePortingOrderRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	id string
	updatePortingOrder *UpdatePortingOrder
}

func (r ApiUpdatePortingOrderRequest) UpdatePortingOrder(updatePortingOrder UpdatePortingOrder) ApiUpdatePortingOrderRequest {
	r.updatePortingOrder = &updatePortingOrder
	return r
}

func (r ApiUpdatePortingOrderRequest) Execute() (*UpdatePortingOrder200Response, *http.Response, error) {
	return r.ApiService.UpdatePortingOrderExecute(r)
}

/*
UpdatePortingOrder Edit a porting order

Edits the details of an existing porting order.

Any or all of a porting orders attributes may be included in the resource object included in a PATCH request.

If a request does not include all of the attributes for a resource, the system will interpret the missing attributes as if they were included with their current values. To explicitly set something to null, it must be included in the request with a null value.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Porting Order id
 @return ApiUpdatePortingOrderRequest
*/
func (a *PortingOrdersAPIService) UpdatePortingOrder(ctx context.Context, id string) ApiUpdatePortingOrderRequest {
	return ApiUpdatePortingOrderRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return UpdatePortingOrder200Response
func (a *PortingOrdersAPIService) UpdatePortingOrderExecute(r ApiUpdatePortingOrderRequest) (*UpdatePortingOrder200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdatePortingOrder200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.UpdatePortingOrder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting_orders/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updatePortingOrder == nil {
		return localVarReturnValue, nil, reportError("updatePortingOrder is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updatePortingOrder
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePortingOrdersActivationJobRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	id string
	activationJobId string
	updatePortingOrdersActivationJobRequest *UpdatePortingOrdersActivationJobRequest
}

func (r ApiUpdatePortingOrdersActivationJobRequest) UpdatePortingOrdersActivationJobRequest(updatePortingOrdersActivationJobRequest UpdatePortingOrdersActivationJobRequest) ApiUpdatePortingOrdersActivationJobRequest {
	r.updatePortingOrdersActivationJobRequest = &updatePortingOrdersActivationJobRequest
	return r
}

func (r ApiUpdatePortingOrdersActivationJobRequest) Execute() (*ActivatePortingOrder202Response, *http.Response, error) {
	return r.ApiService.UpdatePortingOrdersActivationJobExecute(r)
}

/*
UpdatePortingOrdersActivationJob Update a porting activation job

Updates the activation time of a porting activation job.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Porting Order id
 @param activationJobId Activation Job Identifier
 @return ApiUpdatePortingOrdersActivationJobRequest
*/
func (a *PortingOrdersAPIService) UpdatePortingOrdersActivationJob(ctx context.Context, id string, activationJobId string) ApiUpdatePortingOrdersActivationJobRequest {
	return ApiUpdatePortingOrdersActivationJobRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		activationJobId: activationJobId,
	}
}

// Execute executes the request
//  @return ActivatePortingOrder202Response
func (a *PortingOrdersAPIService) UpdatePortingOrdersActivationJobExecute(r ApiUpdatePortingOrdersActivationJobRequest) (*ActivatePortingOrder202Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActivatePortingOrder202Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.UpdatePortingOrdersActivationJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting_orders/{id}/activation_jobs/{activationJobId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"activationJobId"+"}", url.PathEscape(parameterValueToString(r.activationJobId, "activationJobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updatePortingOrdersActivationJobRequest == nil {
		return localVarReturnValue, nil, reportError("updatePortingOrdersActivationJobRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updatePortingOrdersActivationJobRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVerifyPortingVerificationCodesRequest struct {
	ctx context.Context
	ApiService *PortingOrdersAPIService
	id string
	verifyPortingVerificationCodesRequest *VerifyPortingVerificationCodesRequest
}

// A list of phone numbers and their verification codes
func (r ApiVerifyPortingVerificationCodesRequest) VerifyPortingVerificationCodesRequest(verifyPortingVerificationCodesRequest VerifyPortingVerificationCodesRequest) ApiVerifyPortingVerificationCodesRequest {
	r.verifyPortingVerificationCodesRequest = &verifyPortingVerificationCodesRequest
	return r
}

func (r ApiVerifyPortingVerificationCodesRequest) Execute() (*VerifyPortingVerificationCodes200Response, *http.Response, error) {
	return r.ApiService.VerifyPortingVerificationCodesExecute(r)
}

/*
VerifyPortingVerificationCodes Verify the verification code for a list of phone numbers

Verifies the verification code for a list of phone numbers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Porting Order id
 @return ApiVerifyPortingVerificationCodesRequest
*/
func (a *PortingOrdersAPIService) VerifyPortingVerificationCodes(ctx context.Context, id string) ApiVerifyPortingVerificationCodesRequest {
	return ApiVerifyPortingVerificationCodesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VerifyPortingVerificationCodes200Response
func (a *PortingOrdersAPIService) VerifyPortingVerificationCodesExecute(r ApiVerifyPortingVerificationCodesRequest) (*VerifyPortingVerificationCodes200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VerifyPortingVerificationCodes200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortingOrdersAPIService.VerifyPortingVerificationCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/porting_orders/{id}/verification_codes/verify"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.verifyPortingVerificationCodesRequest == nil {
		return localVarReturnValue, nil, reportError("verifyPortingVerificationCodesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.verifyPortingVerificationCodesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
