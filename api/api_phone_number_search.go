/*
Telnyx API

SIP trunking, SMS, MMS, Call Control and Telephony Data Services.

API version: 2.0.0
Contact: support@telnyx.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package telnyx

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
)


// PhoneNumberSearchAPIService PhoneNumberSearchAPI service
type PhoneNumberSearchAPIService service

type ApiListAvailablePhoneNumberBlocksRequest struct {
	ctx context.Context
	ApiService *PhoneNumberSearchAPIService
	filterLocality *string
	filterCountryCode *string
	filterNationalDestinationCode *string
	filterPhoneNumberType *string
}

// Filter phone numbers by city.
func (r ApiListAvailablePhoneNumberBlocksRequest) FilterLocality(filterLocality string) ApiListAvailablePhoneNumberBlocksRequest {
	r.filterLocality = &filterLocality
	return r
}

// Filter phone numbers by country.
func (r ApiListAvailablePhoneNumberBlocksRequest) FilterCountryCode(filterCountryCode string) ApiListAvailablePhoneNumberBlocksRequest {
	r.filterCountryCode = &filterCountryCode
	return r
}

// Filter by the national destination code of the number.
func (r ApiListAvailablePhoneNumberBlocksRequest) FilterNationalDestinationCode(filterNationalDestinationCode string) ApiListAvailablePhoneNumberBlocksRequest {
	r.filterNationalDestinationCode = &filterNationalDestinationCode
	return r
}

// Filter phone numbers by number type.
func (r ApiListAvailablePhoneNumberBlocksRequest) FilterPhoneNumberType(filterPhoneNumberType string) ApiListAvailablePhoneNumberBlocksRequest {
	r.filterPhoneNumberType = &filterPhoneNumberType
	return r
}

func (r ApiListAvailablePhoneNumberBlocksRequest) Execute() (*ListAvailablePhoneNumbersBlocksResponse, *http.Response, error) {
	return r.ApiService.ListAvailablePhoneNumberBlocksExecute(r)
}

/*
ListAvailablePhoneNumberBlocks List available phone number blocks

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListAvailablePhoneNumberBlocksRequest
*/
func (a *PhoneNumberSearchAPIService) ListAvailablePhoneNumberBlocks(ctx context.Context) ApiListAvailablePhoneNumberBlocksRequest {
	return ApiListAvailablePhoneNumberBlocksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListAvailablePhoneNumbersBlocksResponse
func (a *PhoneNumberSearchAPIService) ListAvailablePhoneNumberBlocksExecute(r ApiListAvailablePhoneNumberBlocksRequest) (*ListAvailablePhoneNumbersBlocksResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAvailablePhoneNumbersBlocksResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PhoneNumberSearchAPIService.ListAvailablePhoneNumberBlocks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/available_phone_number_blocks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterLocality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[locality]", r.filterLocality, "form", "")
	}
	if r.filterCountryCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[country_code]", r.filterCountryCode, "form", "")
	}
	if r.filterNationalDestinationCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[national_destination_code]", r.filterNationalDestinationCode, "form", "")
	}
	if r.filterPhoneNumberType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[phone_number_type]", r.filterPhoneNumberType, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAvailablePhoneNumbersRequest struct {
	ctx context.Context
	ApiService *PhoneNumberSearchAPIService
	filterPhoneNumberStartsWith *string
	filterPhoneNumberEndsWith *string
	filterPhoneNumberContains *string
	filterLocality *string
	filterAdministrativeArea *string
	filterCountryCode *string
	filterNationalDestinationCode *string
	filterRateCenter *string
	filterPhoneNumberType *string
	filterFeatures *[]string
	filterLimit *int32
	filterBestEffort *bool
	filterQuickship *bool
	filterReservable *bool
	filterExcludeHeldNumbers *bool
}

// Filter numbers starting with a pattern (excludes NDC if used with &#x60;national_destination_code&#x60; filter).
func (r ApiListAvailablePhoneNumbersRequest) FilterPhoneNumberStartsWith(filterPhoneNumberStartsWith string) ApiListAvailablePhoneNumbersRequest {
	r.filterPhoneNumberStartsWith = &filterPhoneNumberStartsWith
	return r
}

// Filter numbers ending with a pattern (excludes NDC if used with &#x60;national_destination_code&#x60; filter).
func (r ApiListAvailablePhoneNumbersRequest) FilterPhoneNumberEndsWith(filterPhoneNumberEndsWith string) ApiListAvailablePhoneNumbersRequest {
	r.filterPhoneNumberEndsWith = &filterPhoneNumberEndsWith
	return r
}

// Filter numbers containing a pattern (excludes NDC if used with &#x60;national_destination_code&#x60; filter).
func (r ApiListAvailablePhoneNumbersRequest) FilterPhoneNumberContains(filterPhoneNumberContains string) ApiListAvailablePhoneNumbersRequest {
	r.filterPhoneNumberContains = &filterPhoneNumberContains
	return r
}

// Filter phone numbers by city.
func (r ApiListAvailablePhoneNumbersRequest) FilterLocality(filterLocality string) ApiListAvailablePhoneNumbersRequest {
	r.filterLocality = &filterLocality
	return r
}

// Find numbers in a particular US state or CA province.
func (r ApiListAvailablePhoneNumbersRequest) FilterAdministrativeArea(filterAdministrativeArea string) ApiListAvailablePhoneNumbersRequest {
	r.filterAdministrativeArea = &filterAdministrativeArea
	return r
}

// Filter phone numbers by country.
func (r ApiListAvailablePhoneNumbersRequest) FilterCountryCode(filterCountryCode string) ApiListAvailablePhoneNumbersRequest {
	r.filterCountryCode = &filterCountryCode
	return r
}

// Filter by the national destination code of the number.
func (r ApiListAvailablePhoneNumbersRequest) FilterNationalDestinationCode(filterNationalDestinationCode string) ApiListAvailablePhoneNumbersRequest {
	r.filterNationalDestinationCode = &filterNationalDestinationCode
	return r
}

// Filter phone numbers by rate center. This filter is only applicable to USA and Canada numbers.
func (r ApiListAvailablePhoneNumbersRequest) FilterRateCenter(filterRateCenter string) ApiListAvailablePhoneNumbersRequest {
	r.filterRateCenter = &filterRateCenter
	return r
}

// Filter phone numbers by number type.
func (r ApiListAvailablePhoneNumbersRequest) FilterPhoneNumberType(filterPhoneNumberType string) ApiListAvailablePhoneNumbersRequest {
	r.filterPhoneNumberType = &filterPhoneNumberType
	return r
}

// Filter phone numbers with specific features.
func (r ApiListAvailablePhoneNumbersRequest) FilterFeatures(filterFeatures []string) ApiListAvailablePhoneNumbersRequest {
	r.filterFeatures = &filterFeatures
	return r
}

// Limits the number of results.
func (r ApiListAvailablePhoneNumbersRequest) FilterLimit(filterLimit int32) ApiListAvailablePhoneNumbersRequest {
	r.filterLimit = &filterLimit
	return r
}

// Filter to determine if best effort results should be included. Only available in USA/CANADA.
func (r ApiListAvailablePhoneNumbersRequest) FilterBestEffort(filterBestEffort bool) ApiListAvailablePhoneNumbersRequest {
	r.filterBestEffort = &filterBestEffort
	return r
}

// Filter to exclude phone numbers that need additional time after to purchase to activate. Only applicable for +1 toll_free numbers.
func (r ApiListAvailablePhoneNumbersRequest) FilterQuickship(filterQuickship bool) ApiListAvailablePhoneNumbersRequest {
	r.filterQuickship = &filterQuickship
	return r
}

// Filter to ensure only numbers that can be reserved are included in the results.
func (r ApiListAvailablePhoneNumbersRequest) FilterReservable(filterReservable bool) ApiListAvailablePhoneNumbersRequest {
	r.filterReservable = &filterReservable
	return r
}

// Filter to exclude phone numbers that are currently on hold/reserved for your account.
func (r ApiListAvailablePhoneNumbersRequest) FilterExcludeHeldNumbers(filterExcludeHeldNumbers bool) ApiListAvailablePhoneNumbersRequest {
	r.filterExcludeHeldNumbers = &filterExcludeHeldNumbers
	return r
}

func (r ApiListAvailablePhoneNumbersRequest) Execute() (*ListAvailablePhoneNumbersResponse, *http.Response, error) {
	return r.ApiService.ListAvailablePhoneNumbersExecute(r)
}

/*
ListAvailablePhoneNumbers List available phone numbers

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListAvailablePhoneNumbersRequest
*/
func (a *PhoneNumberSearchAPIService) ListAvailablePhoneNumbers(ctx context.Context) ApiListAvailablePhoneNumbersRequest {
	return ApiListAvailablePhoneNumbersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListAvailablePhoneNumbersResponse
func (a *PhoneNumberSearchAPIService) ListAvailablePhoneNumbersExecute(r ApiListAvailablePhoneNumbersRequest) (*ListAvailablePhoneNumbersResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAvailablePhoneNumbersResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PhoneNumberSearchAPIService.ListAvailablePhoneNumbers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/available_phone_numbers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPhoneNumberStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[phone_number][starts_with]", r.filterPhoneNumberStartsWith, "form", "")
	}
	if r.filterPhoneNumberEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[phone_number][ends_with]", r.filterPhoneNumberEndsWith, "form", "")
	}
	if r.filterPhoneNumberContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[phone_number][contains]", r.filterPhoneNumberContains, "form", "")
	}
	if r.filterLocality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[locality]", r.filterLocality, "form", "")
	}
	if r.filterAdministrativeArea != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[administrative_area]", r.filterAdministrativeArea, "form", "")
	}
	if r.filterCountryCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[country_code]", r.filterCountryCode, "form", "")
	}
	if r.filterNationalDestinationCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[national_destination_code]", r.filterNationalDestinationCode, "form", "")
	}
	if r.filterRateCenter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[rate_center]", r.filterRateCenter, "form", "")
	}
	if r.filterPhoneNumberType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[phone_number_type]", r.filterPhoneNumberType, "form", "")
	}
	if r.filterFeatures != nil {
		t := *r.filterFeatures
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[features]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[features]", t, "form", "multi")
		}
	}
	if r.filterLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[limit]", r.filterLimit, "form", "")
	}
	if r.filterBestEffort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[best_effort]", r.filterBestEffort, "form", "")
	}
	if r.filterQuickship != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[quickship]", r.filterQuickship, "form", "")
	}
	if r.filterReservable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[reservable]", r.filterReservable, "form", "")
	}
	if r.filterExcludeHeldNumbers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[exclude_held_numbers]", r.filterExcludeHeldNumbers, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
