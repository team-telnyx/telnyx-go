/*
Telnyx API

SIP trunking, SMS, MMS, Call Control and Telephony Data Services.

API version: 2.0.0
Contact: support@telnyx.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package telnyx

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
	"reflect"
)


// NumberPortoutAPIService NumberPortoutAPI service
type NumberPortoutAPIService service

type ApiCreatePortoutReportRequest struct {
	ctx context.Context
	ApiService *NumberPortoutAPIService
	createPortoutReportRequest *CreatePortoutReportRequest
}

func (r ApiCreatePortoutReportRequest) CreatePortoutReportRequest(createPortoutReportRequest CreatePortoutReportRequest) ApiCreatePortoutReportRequest {
	r.createPortoutReportRequest = &createPortoutReportRequest
	return r
}

func (r ApiCreatePortoutReportRequest) Execute() (*CreatePortoutReport201Response, *http.Response, error) {
	return r.ApiService.CreatePortoutReportExecute(r)
}

/*
CreatePortoutReport Create a port-out related report

Generate reports about port-out operations.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreatePortoutReportRequest
*/
func (a *NumberPortoutAPIService) CreatePortoutReport(ctx context.Context) ApiCreatePortoutReportRequest {
	return ApiCreatePortoutReportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreatePortoutReport201Response
func (a *NumberPortoutAPIService) CreatePortoutReportExecute(r ApiCreatePortoutReportRequest) (*CreatePortoutReport201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreatePortoutReport201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NumberPortoutAPIService.CreatePortoutReport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/portouts/reports"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createPortoutReportRequest == nil {
		return localVarReturnValue, nil, reportError("createPortoutReportRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createPortoutReportRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindPortoutCommentsRequest struct {
	ctx context.Context
	ApiService *NumberPortoutAPIService
	id string
}

func (r ApiFindPortoutCommentsRequest) Execute() (*FindPortoutComments200Response, *http.Response, error) {
	return r.ApiService.FindPortoutCommentsExecute(r)
}

/*
FindPortoutComments List all comments for a portout request

Returns a list of comments for a portout request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Portout id
 @return ApiFindPortoutCommentsRequest
*/
func (a *NumberPortoutAPIService) FindPortoutComments(ctx context.Context, id string) ApiFindPortoutCommentsRequest {
	return ApiFindPortoutCommentsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FindPortoutComments200Response
func (a *NumberPortoutAPIService) FindPortoutCommentsExecute(r ApiFindPortoutCommentsRequest) (*FindPortoutComments200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FindPortoutComments200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NumberPortoutAPIService.FindPortoutComments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/portouts/{id}/comments"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindPortoutRequestRequest struct {
	ctx context.Context
	ApiService *NumberPortoutAPIService
	id string
}

func (r ApiFindPortoutRequestRequest) Execute() (*FindPortoutRequest200Response, *http.Response, error) {
	return r.ApiService.FindPortoutRequestExecute(r)
}

/*
FindPortoutRequest Get a portout request

Returns the portout request based on the ID provided

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Portout id
 @return ApiFindPortoutRequestRequest
*/
func (a *NumberPortoutAPIService) FindPortoutRequest(ctx context.Context, id string) ApiFindPortoutRequestRequest {
	return ApiFindPortoutRequestRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FindPortoutRequest200Response
func (a *NumberPortoutAPIService) FindPortoutRequestExecute(r ApiFindPortoutRequestRequest) (*FindPortoutRequest200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FindPortoutRequest200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NumberPortoutAPIService.FindPortoutRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/portouts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPortRequestSupportingDocumentsRequest struct {
	ctx context.Context
	ApiService *NumberPortoutAPIService
	id string
}

func (r ApiGetPortRequestSupportingDocumentsRequest) Execute() (*GetPortRequestSupportingDocuments201Response, *http.Response, error) {
	return r.ApiService.GetPortRequestSupportingDocumentsExecute(r)
}

/*
GetPortRequestSupportingDocuments List supporting documents on a portout request

List every supporting documents for a portout request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Portout id
 @return ApiGetPortRequestSupportingDocumentsRequest
*/
func (a *NumberPortoutAPIService) GetPortRequestSupportingDocuments(ctx context.Context, id string) ApiGetPortRequestSupportingDocumentsRequest {
	return ApiGetPortRequestSupportingDocumentsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetPortRequestSupportingDocuments201Response
func (a *NumberPortoutAPIService) GetPortRequestSupportingDocumentsExecute(r ApiGetPortRequestSupportingDocumentsRequest) (*GetPortRequestSupportingDocuments201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPortRequestSupportingDocuments201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NumberPortoutAPIService.GetPortRequestSupportingDocuments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/portouts/{id}/supporting_documents"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPortoutReportRequest struct {
	ctx context.Context
	ApiService *NumberPortoutAPIService
	id string
}

func (r ApiGetPortoutReportRequest) Execute() (*CreatePortoutReport201Response, *http.Response, error) {
	return r.ApiService.GetPortoutReportExecute(r)
}

/*
GetPortoutReport Retrieve a report

Retrieve a specific report generated.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies a report.
 @return ApiGetPortoutReportRequest
*/
func (a *NumberPortoutAPIService) GetPortoutReport(ctx context.Context, id string) ApiGetPortoutReportRequest {
	return ApiGetPortoutReportRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreatePortoutReport201Response
func (a *NumberPortoutAPIService) GetPortoutReportExecute(r ApiGetPortoutReportRequest) (*CreatePortoutReport201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreatePortoutReport201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NumberPortoutAPIService.GetPortoutReport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/portouts/reports/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPortoutEventsRequest struct {
	ctx context.Context
	ApiService *NumberPortoutAPIService
	pageNumber *int32
	pageSize *int32
	filterEventType *string
	filterPortoutId *string
	filterCreatedAtGte *time.Time
	filterCreatedAtLte *time.Time
}

// The page number to load.
func (r ApiListPortoutEventsRequest) PageNumber(pageNumber int32) ApiListPortoutEventsRequest {
	r.pageNumber = &pageNumber
	return r
}

// The size of the page.
func (r ApiListPortoutEventsRequest) PageSize(pageSize int32) ApiListPortoutEventsRequest {
	r.pageSize = &pageSize
	return r
}

// Filter by event type.
func (r ApiListPortoutEventsRequest) FilterEventType(filterEventType string) ApiListPortoutEventsRequest {
	r.filterEventType = &filterEventType
	return r
}

// Filter by port-out order ID.
func (r ApiListPortoutEventsRequest) FilterPortoutId(filterPortoutId string) ApiListPortoutEventsRequest {
	r.filterPortoutId = &filterPortoutId
	return r
}

// Filter by created at greater than or equal to.
func (r ApiListPortoutEventsRequest) FilterCreatedAtGte(filterCreatedAtGte time.Time) ApiListPortoutEventsRequest {
	r.filterCreatedAtGte = &filterCreatedAtGte
	return r
}

// Filter by created at less than or equal to.
func (r ApiListPortoutEventsRequest) FilterCreatedAtLte(filterCreatedAtLte time.Time) ApiListPortoutEventsRequest {
	r.filterCreatedAtLte = &filterCreatedAtLte
	return r
}

func (r ApiListPortoutEventsRequest) Execute() (*ListPortoutEvents200Response, *http.Response, error) {
	return r.ApiService.ListPortoutEventsExecute(r)
}

/*
ListPortoutEvents List all port-out events

Returns a list of all port-out events.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListPortoutEventsRequest
*/
func (a *NumberPortoutAPIService) ListPortoutEvents(ctx context.Context) ApiListPortoutEventsRequest {
	return ApiListPortoutEventsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListPortoutEvents200Response
func (a *NumberPortoutAPIService) ListPortoutEventsExecute(r ApiListPortoutEventsRequest) (*ListPortoutEvents200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListPortoutEvents200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NumberPortoutAPIService.ListPortoutEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/portouts/events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.filterEventType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[event_type]", r.filterEventType, "form", "")
	}
	if r.filterPortoutId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[portout_id]", r.filterPortoutId, "form", "")
	}
	if r.filterCreatedAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[created_at][gte]", r.filterCreatedAtGte, "form", "")
	}
	if r.filterCreatedAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[created_at][lte]", r.filterCreatedAtLte, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPortoutRejectionsRequest struct {
	ctx context.Context
	ApiService *NumberPortoutAPIService
	portoutId string
	filterCode *int32
	filterCodeIn *[]int32
}

// Filter rejections of a specific code
func (r ApiListPortoutRejectionsRequest) FilterCode(filterCode int32) ApiListPortoutRejectionsRequest {
	r.filterCode = &filterCode
	return r
}

// Filter rejections in a list of codes
func (r ApiListPortoutRejectionsRequest) FilterCodeIn(filterCodeIn []int32) ApiListPortoutRejectionsRequest {
	r.filterCodeIn = &filterCodeIn
	return r
}

func (r ApiListPortoutRejectionsRequest) Execute() (*ListPortoutRejections200Response, *http.Response, error) {
	return r.ApiService.ListPortoutRejectionsExecute(r)
}

/*
ListPortoutRejections List eligible port-out rejection codes for a specific order

Given a port-out ID, list rejection codes that are eligible for that port-out

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portoutId Identifies a port out order.
 @return ApiListPortoutRejectionsRequest
*/
func (a *NumberPortoutAPIService) ListPortoutRejections(ctx context.Context, portoutId string) ApiListPortoutRejectionsRequest {
	return ApiListPortoutRejectionsRequest{
		ApiService: a,
		ctx: ctx,
		portoutId: portoutId,
	}
}

// Execute executes the request
//  @return ListPortoutRejections200Response
func (a *NumberPortoutAPIService) ListPortoutRejectionsExecute(r ApiListPortoutRejectionsRequest) (*ListPortoutRejections200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListPortoutRejections200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NumberPortoutAPIService.ListPortoutRejections")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/portouts/rejections/{portout_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"portout_id"+"}", url.PathEscape(parameterValueToString(r.portoutId, "portoutId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[code]", r.filterCode, "form", "")
	}
	if r.filterCodeIn != nil {
		t := *r.filterCodeIn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[code][in]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[code][in]", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPortoutReportsRequest struct {
	ctx context.Context
	ApiService *NumberPortoutAPIService
	pageNumber *int32
	pageSize *int32
	filterReportType *string
	filterStatus *string
}

// The page number to load.
func (r ApiListPortoutReportsRequest) PageNumber(pageNumber int32) ApiListPortoutReportsRequest {
	r.pageNumber = &pageNumber
	return r
}

// The size of the page.
func (r ApiListPortoutReportsRequest) PageSize(pageSize int32) ApiListPortoutReportsRequest {
	r.pageSize = &pageSize
	return r
}

// Filter reports of a specific type
func (r ApiListPortoutReportsRequest) FilterReportType(filterReportType string) ApiListPortoutReportsRequest {
	r.filterReportType = &filterReportType
	return r
}

// Filter reports of a specific status
func (r ApiListPortoutReportsRequest) FilterStatus(filterStatus string) ApiListPortoutReportsRequest {
	r.filterStatus = &filterStatus
	return r
}

func (r ApiListPortoutReportsRequest) Execute() (*ListPortoutReports200Response, *http.Response, error) {
	return r.ApiService.ListPortoutReportsExecute(r)
}

/*
ListPortoutReports List port-out related reports

List the reports generated about port-out operations.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListPortoutReportsRequest
*/
func (a *NumberPortoutAPIService) ListPortoutReports(ctx context.Context) ApiListPortoutReportsRequest {
	return ApiListPortoutReportsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListPortoutReports200Response
func (a *NumberPortoutAPIService) ListPortoutReportsExecute(r ApiListPortoutReportsRequest) (*ListPortoutReports200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListPortoutReports200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NumberPortoutAPIService.ListPortoutReports")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/portouts/reports"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.filterReportType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[report_type]", r.filterReportType, "form", "")
	}
	if r.filterStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[status]", r.filterStatus, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPortoutRequestRequest struct {
	ctx context.Context
	ApiService *NumberPortoutAPIService
	filterCarrierName *string
	filterPon *string
	filterSpid *string
	filterStatus *string
	filterStatusIn *[]string
	filterPortedOutAtGte *time.Time
	filterPortedOutAtLte *time.Time
	filterInsertedAtGte *time.Time
	filterInsertedAtLte *time.Time
	filterFocDate *time.Time
	filterPhoneNumber *string
	filterSupportKey *string
	pageNumber *int32
	pageSize *int32
}

// Filter by new carrier name.
func (r ApiListPortoutRequestRequest) FilterCarrierName(filterCarrierName string) ApiListPortoutRequestRequest {
	r.filterCarrierName = &filterCarrierName
	return r
}

// Filter by Port Order Number (PON).
func (r ApiListPortoutRequestRequest) FilterPon(filterPon string) ApiListPortoutRequestRequest {
	r.filterPon = &filterPon
	return r
}

// Filter by new carrier spid.
func (r ApiListPortoutRequestRequest) FilterSpid(filterSpid string) ApiListPortoutRequestRequest {
	r.filterSpid = &filterSpid
	return r
}

// Filter by portout status.
func (r ApiListPortoutRequestRequest) FilterStatus(filterStatus string) ApiListPortoutRequestRequest {
	r.filterStatus = &filterStatus
	return r
}

// Filter by a list of portout statuses
func (r ApiListPortoutRequestRequest) FilterStatusIn(filterStatusIn []string) ApiListPortoutRequestRequest {
	r.filterStatusIn = &filterStatusIn
	return r
}

// Filter by ported_out_at date greater than or equal.
func (r ApiListPortoutRequestRequest) FilterPortedOutAtGte(filterPortedOutAtGte time.Time) ApiListPortoutRequestRequest {
	r.filterPortedOutAtGte = &filterPortedOutAtGte
	return r
}

// Filter by ported_out_at date less than or equal.
func (r ApiListPortoutRequestRequest) FilterPortedOutAtLte(filterPortedOutAtLte time.Time) ApiListPortoutRequestRequest {
	r.filterPortedOutAtLte = &filterPortedOutAtLte
	return r
}

// Filter by inserted_at date greater than or equal.
func (r ApiListPortoutRequestRequest) FilterInsertedAtGte(filterInsertedAtGte time.Time) ApiListPortoutRequestRequest {
	r.filterInsertedAtGte = &filterInsertedAtGte
	return r
}

// Filter by inserted_at date less than or equal.
func (r ApiListPortoutRequestRequest) FilterInsertedAtLte(filterInsertedAtLte time.Time) ApiListPortoutRequestRequest {
	r.filterInsertedAtLte = &filterInsertedAtLte
	return r
}

// Filter by foc_date. Matches all portouts with the same date
func (r ApiListPortoutRequestRequest) FilterFocDate(filterFocDate time.Time) ApiListPortoutRequestRequest {
	r.filterFocDate = &filterFocDate
	return r
}

// Filter by a phone number on the portout. Matches all portouts with the phone number
func (r ApiListPortoutRequestRequest) FilterPhoneNumber(filterPhoneNumber string) ApiListPortoutRequestRequest {
	r.filterPhoneNumber = &filterPhoneNumber
	return r
}

// Filter by the portout&#39;s support_key
func (r ApiListPortoutRequestRequest) FilterSupportKey(filterSupportKey string) ApiListPortoutRequestRequest {
	r.filterSupportKey = &filterSupportKey
	return r
}

// The page number to load.
func (r ApiListPortoutRequestRequest) PageNumber(pageNumber int32) ApiListPortoutRequestRequest {
	r.pageNumber = &pageNumber
	return r
}

// The size of the page.
func (r ApiListPortoutRequestRequest) PageSize(pageSize int32) ApiListPortoutRequestRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListPortoutRequestRequest) Execute() (*ListPortoutRequest200Response, *http.Response, error) {
	return r.ApiService.ListPortoutRequestExecute(r)
}

/*
ListPortoutRequest List portout requests

Returns the portout requests according to filters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListPortoutRequestRequest
*/
func (a *NumberPortoutAPIService) ListPortoutRequest(ctx context.Context) ApiListPortoutRequestRequest {
	return ApiListPortoutRequestRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListPortoutRequest200Response
func (a *NumberPortoutAPIService) ListPortoutRequestExecute(r ApiListPortoutRequestRequest) (*ListPortoutRequest200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListPortoutRequest200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NumberPortoutAPIService.ListPortoutRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/portouts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterCarrierName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[carrier_name]", r.filterCarrierName, "form", "")
	}
	if r.filterPon != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[pon]", r.filterPon, "form", "")
	}
	if r.filterSpid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[spid]", r.filterSpid, "form", "")
	}
	if r.filterStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[status]", r.filterStatus, "form", "")
	}
	if r.filterStatusIn != nil {
		t := *r.filterStatusIn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[status_in]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[status_in]", t, "form", "multi")
		}
	}
	if r.filterPortedOutAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[ported_out_at][gte]", r.filterPortedOutAtGte, "form", "")
	}
	if r.filterPortedOutAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[ported_out_at][lte]", r.filterPortedOutAtLte, "form", "")
	}
	if r.filterInsertedAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[inserted_at][gte]", r.filterInsertedAtGte, "form", "")
	}
	if r.filterInsertedAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[inserted_at][lte]", r.filterInsertedAtLte, "form", "")
	}
	if r.filterFocDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[foc_date]", r.filterFocDate, "form", "")
	}
	if r.filterPhoneNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[phone_number]", r.filterPhoneNumber, "form", "")
	}
	if r.filterSupportKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[support_key]", r.filterSupportKey, "form", "")
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostPortRequestCommentRequest struct {
	ctx context.Context
	ApiService *NumberPortoutAPIService
	id string
	postPortRequestCommentRequest *PostPortRequestCommentRequest
}

func (r ApiPostPortRequestCommentRequest) PostPortRequestCommentRequest(postPortRequestCommentRequest PostPortRequestCommentRequest) ApiPostPortRequestCommentRequest {
	r.postPortRequestCommentRequest = &postPortRequestCommentRequest
	return r
}

func (r ApiPostPortRequestCommentRequest) Execute() (*PostPortRequestComment201Response, *http.Response, error) {
	return r.ApiService.PostPortRequestCommentExecute(r)
}

/*
PostPortRequestComment Create a comment on a portout request

Creates a comment on a portout request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Portout id
 @return ApiPostPortRequestCommentRequest
*/
func (a *NumberPortoutAPIService) PostPortRequestComment(ctx context.Context, id string) ApiPostPortRequestCommentRequest {
	return ApiPostPortRequestCommentRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PostPortRequestComment201Response
func (a *NumberPortoutAPIService) PostPortRequestCommentExecute(r ApiPostPortRequestCommentRequest) (*PostPortRequestComment201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostPortRequestComment201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NumberPortoutAPIService.PostPortRequestComment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/portouts/{id}/comments"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postPortRequestCommentRequest == nil {
		return localVarReturnValue, nil, reportError("postPortRequestCommentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postPortRequestCommentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostPortRequestSupportingDocumentsRequest struct {
	ctx context.Context
	ApiService *NumberPortoutAPIService
	id string
	postPortRequestSupportingDocumentsRequest *PostPortRequestSupportingDocumentsRequest
}

func (r ApiPostPortRequestSupportingDocumentsRequest) PostPortRequestSupportingDocumentsRequest(postPortRequestSupportingDocumentsRequest PostPortRequestSupportingDocumentsRequest) ApiPostPortRequestSupportingDocumentsRequest {
	r.postPortRequestSupportingDocumentsRequest = &postPortRequestSupportingDocumentsRequest
	return r
}

func (r ApiPostPortRequestSupportingDocumentsRequest) Execute() (*GetPortRequestSupportingDocuments201Response, *http.Response, error) {
	return r.ApiService.PostPortRequestSupportingDocumentsExecute(r)
}

/*
PostPortRequestSupportingDocuments Create a list of supporting documents on a portout request

Creates a list of supporting documents on a portout request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Portout id
 @return ApiPostPortRequestSupportingDocumentsRequest
*/
func (a *NumberPortoutAPIService) PostPortRequestSupportingDocuments(ctx context.Context, id string) ApiPostPortRequestSupportingDocumentsRequest {
	return ApiPostPortRequestSupportingDocumentsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetPortRequestSupportingDocuments201Response
func (a *NumberPortoutAPIService) PostPortRequestSupportingDocumentsExecute(r ApiPostPortRequestSupportingDocumentsRequest) (*GetPortRequestSupportingDocuments201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPortRequestSupportingDocuments201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NumberPortoutAPIService.PostPortRequestSupportingDocuments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/portouts/{id}/supporting_documents"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postPortRequestSupportingDocumentsRequest == nil {
		return localVarReturnValue, nil, reportError("postPortRequestSupportingDocumentsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postPortRequestSupportingDocumentsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepublishPortoutEventRequest struct {
	ctx context.Context
	ApiService *NumberPortoutAPIService
	id string
}

func (r ApiRepublishPortoutEventRequest) Execute() (*http.Response, error) {
	return r.ApiService.RepublishPortoutEventExecute(r)
}

/*
RepublishPortoutEvent Republish a port-out event

Republish a specific port-out event.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the port-out event.
 @return ApiRepublishPortoutEventRequest
*/
func (a *NumberPortoutAPIService) RepublishPortoutEvent(ctx context.Context, id string) ApiRepublishPortoutEventRequest {
	return ApiRepublishPortoutEventRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *NumberPortoutAPIService) RepublishPortoutEventExecute(r ApiRepublishPortoutEventRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NumberPortoutAPIService.RepublishPortoutEvent")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/portouts/events/{id}/republish"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiShowPortoutEventRequest struct {
	ctx context.Context
	ApiService *NumberPortoutAPIService
	id string
}

func (r ApiShowPortoutEventRequest) Execute() (*ShowPortoutEvent200Response, *http.Response, error) {
	return r.ApiService.ShowPortoutEventExecute(r)
}

/*
ShowPortoutEvent Show a port-out event

Show a specific port-out event.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the port-out event.
 @return ApiShowPortoutEventRequest
*/
func (a *NumberPortoutAPIService) ShowPortoutEvent(ctx context.Context, id string) ApiShowPortoutEventRequest {
	return ApiShowPortoutEventRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ShowPortoutEvent200Response
func (a *NumberPortoutAPIService) ShowPortoutEventExecute(r ApiShowPortoutEventRequest) (*ShowPortoutEvent200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShowPortoutEvent200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NumberPortoutAPIService.ShowPortoutEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/portouts/events/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePortoutStatusRequest struct {
	ctx context.Context
	ApiService *NumberPortoutAPIService
	id string
	status string
	updatePortoutStatusRequest *UpdatePortoutStatusRequest
}

func (r ApiUpdatePortoutStatusRequest) UpdatePortoutStatusRequest(updatePortoutStatusRequest UpdatePortoutStatusRequest) ApiUpdatePortoutStatusRequest {
	r.updatePortoutStatusRequest = &updatePortoutStatusRequest
	return r
}

func (r ApiUpdatePortoutStatusRequest) Execute() (*FindPortoutRequest200Response, *http.Response, error) {
	return r.ApiService.UpdatePortoutStatusExecute(r)
}

/*
UpdatePortoutStatus Update Status

Authorize or reject portout request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Portout id
 @param status Updated portout status
 @return ApiUpdatePortoutStatusRequest
*/
func (a *NumberPortoutAPIService) UpdatePortoutStatus(ctx context.Context, id string, status string) ApiUpdatePortoutStatusRequest {
	return ApiUpdatePortoutStatusRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		status: status,
	}
}

// Execute executes the request
//  @return FindPortoutRequest200Response
func (a *NumberPortoutAPIService) UpdatePortoutStatusExecute(r ApiUpdatePortoutStatusRequest) (*FindPortoutRequest200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FindPortoutRequest200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NumberPortoutAPIService.UpdatePortoutStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/portouts/{id}/{status}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"status"+"}", url.PathEscape(parameterValueToString(r.status, "status")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updatePortoutStatusRequest == nil {
		return localVarReturnValue, nil, reportError("updatePortoutStatusRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updatePortoutStatusRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
