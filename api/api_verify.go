/*
Telnyx API

SIP trunking, SMS, MMS, Call Control and Telephony Data Services.

API version: 2.0.0
Contact: support@telnyx.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package telnyx

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// VerifyAPIService VerifyAPI service
type VerifyAPIService service

type ApiCreateFlashcallVerificationRequest struct {
	ctx context.Context
	ApiService *VerifyAPIService
	createVerificationRequestFlashcall *CreateVerificationRequestFlashcall
}

func (r ApiCreateFlashcallVerificationRequest) CreateVerificationRequestFlashcall(createVerificationRequestFlashcall CreateVerificationRequestFlashcall) ApiCreateFlashcallVerificationRequest {
	r.createVerificationRequestFlashcall = &createVerificationRequestFlashcall
	return r
}

func (r ApiCreateFlashcallVerificationRequest) Execute() (*CreateVerificationResponse, *http.Response, error) {
	return r.ApiService.CreateFlashcallVerificationExecute(r)
}

/*
CreateFlashcallVerification Trigger Flash call verification

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateFlashcallVerificationRequest
*/
func (a *VerifyAPIService) CreateFlashcallVerification(ctx context.Context) ApiCreateFlashcallVerificationRequest {
	return ApiCreateFlashcallVerificationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateVerificationResponse
func (a *VerifyAPIService) CreateFlashcallVerificationExecute(r ApiCreateFlashcallVerificationRequest) (*CreateVerificationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVerificationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VerifyAPIService.CreateFlashcallVerification")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/verifications/flashcall"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createVerificationRequestFlashcall == nil {
		return localVarReturnValue, nil, reportError("createVerificationRequestFlashcall is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createVerificationRequestFlashcall
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateVerificationCallRequest struct {
	ctx context.Context
	ApiService *VerifyAPIService
	createVerificationRequestCall *CreateVerificationRequestCall
}

func (r ApiCreateVerificationCallRequest) CreateVerificationRequestCall(createVerificationRequestCall CreateVerificationRequestCall) ApiCreateVerificationCallRequest {
	r.createVerificationRequestCall = &createVerificationRequestCall
	return r
}

func (r ApiCreateVerificationCallRequest) Execute() (*CreateVerificationResponse, *http.Response, error) {
	return r.ApiService.CreateVerificationCallExecute(r)
}

/*
CreateVerificationCall Trigger Call verification

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateVerificationCallRequest
*/
func (a *VerifyAPIService) CreateVerificationCall(ctx context.Context) ApiCreateVerificationCallRequest {
	return ApiCreateVerificationCallRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateVerificationResponse
func (a *VerifyAPIService) CreateVerificationCallExecute(r ApiCreateVerificationCallRequest) (*CreateVerificationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVerificationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VerifyAPIService.CreateVerificationCall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/verifications/call"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createVerificationRequestCall == nil {
		return localVarReturnValue, nil, reportError("createVerificationRequestCall is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createVerificationRequestCall
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateVerificationSmsRequest struct {
	ctx context.Context
	ApiService *VerifyAPIService
	createVerificationRequestSMS *CreateVerificationRequestSMS
}

func (r ApiCreateVerificationSmsRequest) CreateVerificationRequestSMS(createVerificationRequestSMS CreateVerificationRequestSMS) ApiCreateVerificationSmsRequest {
	r.createVerificationRequestSMS = &createVerificationRequestSMS
	return r
}

func (r ApiCreateVerificationSmsRequest) Execute() (*CreateVerificationResponse, *http.Response, error) {
	return r.ApiService.CreateVerificationSmsExecute(r)
}

/*
CreateVerificationSms Trigger SMS verification

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateVerificationSmsRequest
*/
func (a *VerifyAPIService) CreateVerificationSms(ctx context.Context) ApiCreateVerificationSmsRequest {
	return ApiCreateVerificationSmsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateVerificationResponse
func (a *VerifyAPIService) CreateVerificationSmsExecute(r ApiCreateVerificationSmsRequest) (*CreateVerificationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVerificationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VerifyAPIService.CreateVerificationSms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/verifications/sms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createVerificationRequestSMS == nil {
		return localVarReturnValue, nil, reportError("createVerificationRequestSMS is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createVerificationRequestSMS
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateVerifyProfileRequest struct {
	ctx context.Context
	ApiService *VerifyAPIService
	createVerifyProfileRequest *CreateVerifyProfileRequest
}

func (r ApiCreateVerifyProfileRequest) CreateVerifyProfileRequest(createVerifyProfileRequest CreateVerifyProfileRequest) ApiCreateVerifyProfileRequest {
	r.createVerifyProfileRequest = &createVerifyProfileRequest
	return r
}

func (r ApiCreateVerifyProfileRequest) Execute() (*VerifyProfileResponseDataWrapper, *http.Response, error) {
	return r.ApiService.CreateVerifyProfileExecute(r)
}

/*
CreateVerifyProfile Create a Verify profile

Creates a new Verify profile to associate verifications with.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateVerifyProfileRequest
*/
func (a *VerifyAPIService) CreateVerifyProfile(ctx context.Context) ApiCreateVerifyProfileRequest {
	return ApiCreateVerifyProfileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VerifyProfileResponseDataWrapper
func (a *VerifyAPIService) CreateVerifyProfileExecute(r ApiCreateVerifyProfileRequest) (*VerifyProfileResponseDataWrapper, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VerifyProfileResponseDataWrapper
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VerifyAPIService.CreateVerifyProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/verify_profiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createVerifyProfileRequest == nil {
		return localVarReturnValue, nil, reportError("createVerifyProfileRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createVerifyProfileRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteProfileRequest struct {
	ctx context.Context
	ApiService *VerifyAPIService
	verifyProfileId string
}

func (r ApiDeleteProfileRequest) Execute() (*VerifyProfileResponseDataWrapper, *http.Response, error) {
	return r.ApiService.DeleteProfileExecute(r)
}

/*
DeleteProfile Delete Verify profile

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param verifyProfileId The identifier of the Verify profile to delete.
 @return ApiDeleteProfileRequest
*/
func (a *VerifyAPIService) DeleteProfile(ctx context.Context, verifyProfileId string) ApiDeleteProfileRequest {
	return ApiDeleteProfileRequest{
		ApiService: a,
		ctx: ctx,
		verifyProfileId: verifyProfileId,
	}
}

// Execute executes the request
//  @return VerifyProfileResponseDataWrapper
func (a *VerifyAPIService) DeleteProfileExecute(r ApiDeleteProfileRequest) (*VerifyProfileResponseDataWrapper, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VerifyProfileResponseDataWrapper
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VerifyAPIService.DeleteProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/verify_profiles/{verify_profile_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"verify_profile_id"+"}", url.PathEscape(parameterValueToString(r.verifyProfileId, "verifyProfileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVerifyProfileRequest struct {
	ctx context.Context
	ApiService *VerifyAPIService
	verifyProfileId string
}

func (r ApiGetVerifyProfileRequest) Execute() (*VerifyProfileResponseDataWrapper, *http.Response, error) {
	return r.ApiService.GetVerifyProfileExecute(r)
}

/*
GetVerifyProfile Retrieve Verify profile

Gets a single Verify profile.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param verifyProfileId The identifier of the Verify profile to retrieve.
 @return ApiGetVerifyProfileRequest
*/
func (a *VerifyAPIService) GetVerifyProfile(ctx context.Context, verifyProfileId string) ApiGetVerifyProfileRequest {
	return ApiGetVerifyProfileRequest{
		ApiService: a,
		ctx: ctx,
		verifyProfileId: verifyProfileId,
	}
}

// Execute executes the request
//  @return VerifyProfileResponseDataWrapper
func (a *VerifyAPIService) GetVerifyProfileExecute(r ApiGetVerifyProfileRequest) (*VerifyProfileResponseDataWrapper, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VerifyProfileResponseDataWrapper
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VerifyAPIService.GetVerifyProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/verify_profiles/{verify_profile_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"verify_profile_id"+"}", url.PathEscape(parameterValueToString(r.verifyProfileId, "verifyProfileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListProfileMessageTemplatesRequest struct {
	ctx context.Context
	ApiService *VerifyAPIService
}

func (r ApiListProfileMessageTemplatesRequest) Execute() (*ListVerifyProfileMessageTemplateResponse, *http.Response, error) {
	return r.ApiService.ListProfileMessageTemplatesExecute(r)
}

/*
ListProfileMessageTemplates Retrieve Verify profile message templates

List all Verify profile message templates.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListProfileMessageTemplatesRequest
*/
func (a *VerifyAPIService) ListProfileMessageTemplates(ctx context.Context) ApiListProfileMessageTemplatesRequest {
	return ApiListProfileMessageTemplatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListVerifyProfileMessageTemplateResponse
func (a *VerifyAPIService) ListProfileMessageTemplatesExecute(r ApiListProfileMessageTemplatesRequest) (*ListVerifyProfileMessageTemplateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListVerifyProfileMessageTemplateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VerifyAPIService.ListProfileMessageTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/verify_profiles/templates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListProfilesRequest struct {
	ctx context.Context
	ApiService *VerifyAPIService
	filterName *string
	pageSize *int32
	pageNumber *int32
}

func (r ApiListProfilesRequest) FilterName(filterName string) ApiListProfilesRequest {
	r.filterName = &filterName
	return r
}

func (r ApiListProfilesRequest) PageSize(pageSize int32) ApiListProfilesRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListProfilesRequest) PageNumber(pageNumber int32) ApiListProfilesRequest {
	r.pageNumber = &pageNumber
	return r
}

func (r ApiListProfilesRequest) Execute() (*ListVerifyProfilesResponse, *http.Response, error) {
	return r.ApiService.ListProfilesExecute(r)
}

/*
ListProfiles List all Verify profiles

Gets a paginated list of Verify profiles.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListProfilesRequest
*/
func (a *VerifyAPIService) ListProfiles(ctx context.Context) ApiListProfilesRequest {
	return ApiListProfilesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListVerifyProfilesResponse
func (a *VerifyAPIService) ListProfilesExecute(r ApiListProfilesRequest) (*ListVerifyProfilesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListVerifyProfilesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VerifyAPIService.ListProfiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/verify_profiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[name]", r.filterName, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 25
		r.pageSize = &defaultValue
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListVerificationsRequest struct {
	ctx context.Context
	ApiService *VerifyAPIService
	phoneNumber string
}

func (r ApiListVerificationsRequest) Execute() (*ListVerificationsResponse, *http.Response, error) {
	return r.ApiService.ListVerificationsExecute(r)
}

/*
ListVerifications List verifications by phone number

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param phoneNumber The phone number associated with the verifications to retrieve.
 @return ApiListVerificationsRequest
*/
func (a *VerifyAPIService) ListVerifications(ctx context.Context, phoneNumber string) ApiListVerificationsRequest {
	return ApiListVerificationsRequest{
		ApiService: a,
		ctx: ctx,
		phoneNumber: phoneNumber,
	}
}

// Execute executes the request
//  @return ListVerificationsResponse
func (a *VerifyAPIService) ListVerificationsExecute(r ApiListVerificationsRequest) (*ListVerificationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListVerificationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VerifyAPIService.ListVerifications")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/verifications/by_phone_number/{phone_number}"
	localVarPath = strings.Replace(localVarPath, "{"+"phone_number"+"}", url.PathEscape(parameterValueToString(r.phoneNumber, "phoneNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrieveVerificationRequest struct {
	ctx context.Context
	ApiService *VerifyAPIService
	verificationId string
}

func (r ApiRetrieveVerificationRequest) Execute() (*RetrieveVerificationResponse, *http.Response, error) {
	return r.ApiService.RetrieveVerificationExecute(r)
}

/*
RetrieveVerification Retrieve verification

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param verificationId The identifier of the verification to retrieve.
 @return ApiRetrieveVerificationRequest
*/
func (a *VerifyAPIService) RetrieveVerification(ctx context.Context, verificationId string) ApiRetrieveVerificationRequest {
	return ApiRetrieveVerificationRequest{
		ApiService: a,
		ctx: ctx,
		verificationId: verificationId,
	}
}

// Execute executes the request
//  @return RetrieveVerificationResponse
func (a *VerifyAPIService) RetrieveVerificationExecute(r ApiRetrieveVerificationRequest) (*RetrieveVerificationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RetrieveVerificationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VerifyAPIService.RetrieveVerification")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/verifications/{verification_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"verification_id"+"}", url.PathEscape(parameterValueToString(r.verificationId, "verificationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateVerifyProfileRequest struct {
	ctx context.Context
	ApiService *VerifyAPIService
	verifyProfileId string
	updateVerifyProfileRequest *UpdateVerifyProfileRequest
}

func (r ApiUpdateVerifyProfileRequest) UpdateVerifyProfileRequest(updateVerifyProfileRequest UpdateVerifyProfileRequest) ApiUpdateVerifyProfileRequest {
	r.updateVerifyProfileRequest = &updateVerifyProfileRequest
	return r
}

func (r ApiUpdateVerifyProfileRequest) Execute() (*VerifyProfileResponseDataWrapper, *http.Response, error) {
	return r.ApiService.UpdateVerifyProfileExecute(r)
}

/*
UpdateVerifyProfile Update Verify profile

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param verifyProfileId The identifier of the Verify profile to update.
 @return ApiUpdateVerifyProfileRequest
*/
func (a *VerifyAPIService) UpdateVerifyProfile(ctx context.Context, verifyProfileId string) ApiUpdateVerifyProfileRequest {
	return ApiUpdateVerifyProfileRequest{
		ApiService: a,
		ctx: ctx,
		verifyProfileId: verifyProfileId,
	}
}

// Execute executes the request
//  @return VerifyProfileResponseDataWrapper
func (a *VerifyAPIService) UpdateVerifyProfileExecute(r ApiUpdateVerifyProfileRequest) (*VerifyProfileResponseDataWrapper, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VerifyProfileResponseDataWrapper
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VerifyAPIService.UpdateVerifyProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/verify_profiles/{verify_profile_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"verify_profile_id"+"}", url.PathEscape(parameterValueToString(r.verifyProfileId, "verifyProfileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateVerifyProfileRequest == nil {
		return localVarReturnValue, nil, reportError("updateVerifyProfileRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateVerifyProfileRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVerifyVerificationCodeByIdRequest struct {
	ctx context.Context
	ApiService *VerifyAPIService
	verificationId string
	verifyVerificationCodeRequestById *VerifyVerificationCodeRequestById
}

func (r ApiVerifyVerificationCodeByIdRequest) VerifyVerificationCodeRequestById(verifyVerificationCodeRequestById VerifyVerificationCodeRequestById) ApiVerifyVerificationCodeByIdRequest {
	r.verifyVerificationCodeRequestById = &verifyVerificationCodeRequestById
	return r
}

func (r ApiVerifyVerificationCodeByIdRequest) Execute() (*VerifyVerificationCodeResponse, *http.Response, error) {
	return r.ApiService.VerifyVerificationCodeByIdExecute(r)
}

/*
VerifyVerificationCodeById Verify verification code by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param verificationId The identifier of the verification to retrieve.
 @return ApiVerifyVerificationCodeByIdRequest
*/
func (a *VerifyAPIService) VerifyVerificationCodeById(ctx context.Context, verificationId string) ApiVerifyVerificationCodeByIdRequest {
	return ApiVerifyVerificationCodeByIdRequest{
		ApiService: a,
		ctx: ctx,
		verificationId: verificationId,
	}
}

// Execute executes the request
//  @return VerifyVerificationCodeResponse
func (a *VerifyAPIService) VerifyVerificationCodeByIdExecute(r ApiVerifyVerificationCodeByIdRequest) (*VerifyVerificationCodeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VerifyVerificationCodeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VerifyAPIService.VerifyVerificationCodeById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/verifications/{verification_id}/actions/verify"
	localVarPath = strings.Replace(localVarPath, "{"+"verification_id"+"}", url.PathEscape(parameterValueToString(r.verificationId, "verificationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.verifyVerificationCodeRequestById == nil {
		return localVarReturnValue, nil, reportError("verifyVerificationCodeRequestById is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.verifyVerificationCodeRequestById
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVerifyVerificationCodeByPhoneNumberRequest struct {
	ctx context.Context
	ApiService *VerifyAPIService
	phoneNumber string
	verifyVerificationCodeRequestByPhoneNumber *VerifyVerificationCodeRequestByPhoneNumber
}

func (r ApiVerifyVerificationCodeByPhoneNumberRequest) VerifyVerificationCodeRequestByPhoneNumber(verifyVerificationCodeRequestByPhoneNumber VerifyVerificationCodeRequestByPhoneNumber) ApiVerifyVerificationCodeByPhoneNumberRequest {
	r.verifyVerificationCodeRequestByPhoneNumber = &verifyVerificationCodeRequestByPhoneNumber
	return r
}

func (r ApiVerifyVerificationCodeByPhoneNumberRequest) Execute() (*VerifyVerificationCodeResponse, *http.Response, error) {
	return r.ApiService.VerifyVerificationCodeByPhoneNumberExecute(r)
}

/*
VerifyVerificationCodeByPhoneNumber Verify verification code by phone number

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param phoneNumber The phone number associated with the verification code being verified.
 @return ApiVerifyVerificationCodeByPhoneNumberRequest
*/
func (a *VerifyAPIService) VerifyVerificationCodeByPhoneNumber(ctx context.Context, phoneNumber string) ApiVerifyVerificationCodeByPhoneNumberRequest {
	return ApiVerifyVerificationCodeByPhoneNumberRequest{
		ApiService: a,
		ctx: ctx,
		phoneNumber: phoneNumber,
	}
}

// Execute executes the request
//  @return VerifyVerificationCodeResponse
func (a *VerifyAPIService) VerifyVerificationCodeByPhoneNumberExecute(r ApiVerifyVerificationCodeByPhoneNumberRequest) (*VerifyVerificationCodeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VerifyVerificationCodeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VerifyAPIService.VerifyVerificationCodeByPhoneNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/verifications/by_phone_number/{phone_number}/actions/verify"
	localVarPath = strings.Replace(localVarPath, "{"+"phone_number"+"}", url.PathEscape(parameterValueToString(r.phoneNumber, "phoneNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.verifyVerificationCodeRequestByPhoneNumber == nil {
		return localVarReturnValue, nil, reportError("verifyVerificationCodeRequestByPhoneNumber is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.verifyVerificationCodeRequestByPhoneNumber
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
