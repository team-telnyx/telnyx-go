/*
Telnyx API

SIP trunking, SMS, MMS, Call Control and Telephony Data Services.

API version: 2.0.0
Contact: support@telnyx.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package telnyx

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// RoomSessionsAPIService RoomSessionsAPI service
type RoomSessionsAPIService service

type ApiEndSessionRequest struct {
	ctx context.Context
	ApiService *RoomSessionsAPIService
	roomSessionId string
}

func (r ApiEndSessionRequest) Execute() (*EndSession200Response, *http.Response, error) {
	return r.ApiService.EndSessionExecute(r)
}

/*
EndSession End a room session.

Note: this will also kick all participants currently present in the room

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomSessionId The unique identifier of a room session.
 @return ApiEndSessionRequest
*/
func (a *RoomSessionsAPIService) EndSession(ctx context.Context, roomSessionId string) ApiEndSessionRequest {
	return ApiEndSessionRequest{
		ApiService: a,
		ctx: ctx,
		roomSessionId: roomSessionId,
	}
}

// Execute executes the request
//  @return EndSession200Response
func (a *RoomSessionsAPIService) EndSessionExecute(r ApiEndSessionRequest) (*EndSession200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EndSession200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomSessionsAPIService.EndSession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/room_sessions/{room_session_id}/actions/end"
	localVarPath = strings.Replace(localVarPath, "{"+"room_session_id"+"}", url.PathEscape(parameterValueToString(r.roomSessionId, "roomSessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKickParticipantInSessionRequest struct {
	ctx context.Context
	ApiService *RoomSessionsAPIService
	roomSessionId string
	actionsParticipantsRequest *ActionsParticipantsRequest
}

// Parameters that can be defined during Kick action.
func (r ApiKickParticipantInSessionRequest) ActionsParticipantsRequest(actionsParticipantsRequest ActionsParticipantsRequest) ApiKickParticipantInSessionRequest {
	r.actionsParticipantsRequest = &actionsParticipantsRequest
	return r
}

func (r ApiKickParticipantInSessionRequest) Execute() (*EndSession200Response, *http.Response, error) {
	return r.ApiService.KickParticipantInSessionExecute(r)
}

/*
KickParticipantInSession Kick participants from a room session.



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomSessionId The unique identifier of a room session.
 @return ApiKickParticipantInSessionRequest
*/
func (a *RoomSessionsAPIService) KickParticipantInSession(ctx context.Context, roomSessionId string) ApiKickParticipantInSessionRequest {
	return ApiKickParticipantInSessionRequest{
		ApiService: a,
		ctx: ctx,
		roomSessionId: roomSessionId,
	}
}

// Execute executes the request
//  @return EndSession200Response
func (a *RoomSessionsAPIService) KickParticipantInSessionExecute(r ApiKickParticipantInSessionRequest) (*EndSession200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EndSession200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomSessionsAPIService.KickParticipantInSession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/room_sessions/{room_session_id}/actions/kick"
	localVarPath = strings.Replace(localVarPath, "{"+"room_session_id"+"}", url.PathEscape(parameterValueToString(r.roomSessionId, "roomSessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.actionsParticipantsRequest == nil {
		return localVarReturnValue, nil, reportError("actionsParticipantsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.actionsParticipantsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListRoomSessionsRequest struct {
	ctx context.Context
	ApiService *RoomSessionsAPIService
	filterDateCreatedAtEq *string
	filterDateCreatedAtGte *string
	filterDateCreatedAtLte *string
	filterDateUpdatedAtEq *string
	filterDateUpdatedAtGte *string
	filterDateUpdatedAtLte *string
	filterDateEndedAtEq *string
	filterDateEndedAtGte *string
	filterDateEndedAtLte *string
	filterRoomId *string
	filterActive *bool
	includeParticipants *bool
	pageSize *int32
	pageNumber *int32
}

// ISO 8601 date for filtering room sessions created on that date.
func (r ApiListRoomSessionsRequest) FilterDateCreatedAtEq(filterDateCreatedAtEq string) ApiListRoomSessionsRequest {
	r.filterDateCreatedAtEq = &filterDateCreatedAtEq
	return r
}

// ISO 8601 date for filtering room sessions created after that date.
func (r ApiListRoomSessionsRequest) FilterDateCreatedAtGte(filterDateCreatedAtGte string) ApiListRoomSessionsRequest {
	r.filterDateCreatedAtGte = &filterDateCreatedAtGte
	return r
}

// ISO 8601 date for filtering room sessions created before that date.
func (r ApiListRoomSessionsRequest) FilterDateCreatedAtLte(filterDateCreatedAtLte string) ApiListRoomSessionsRequest {
	r.filterDateCreatedAtLte = &filterDateCreatedAtLte
	return r
}

// ISO 8601 date for filtering room sessions updated on that date.
func (r ApiListRoomSessionsRequest) FilterDateUpdatedAtEq(filterDateUpdatedAtEq string) ApiListRoomSessionsRequest {
	r.filterDateUpdatedAtEq = &filterDateUpdatedAtEq
	return r
}

// ISO 8601 date for filtering room sessions updated after that date.
func (r ApiListRoomSessionsRequest) FilterDateUpdatedAtGte(filterDateUpdatedAtGte string) ApiListRoomSessionsRequest {
	r.filterDateUpdatedAtGte = &filterDateUpdatedAtGte
	return r
}

// ISO 8601 date for filtering room sessions updated before that date.
func (r ApiListRoomSessionsRequest) FilterDateUpdatedAtLte(filterDateUpdatedAtLte string) ApiListRoomSessionsRequest {
	r.filterDateUpdatedAtLte = &filterDateUpdatedAtLte
	return r
}

// ISO 8601 date for filtering room sessions ended on that date.
func (r ApiListRoomSessionsRequest) FilterDateEndedAtEq(filterDateEndedAtEq string) ApiListRoomSessionsRequest {
	r.filterDateEndedAtEq = &filterDateEndedAtEq
	return r
}

// ISO 8601 date for filtering room sessions ended after that date.
func (r ApiListRoomSessionsRequest) FilterDateEndedAtGte(filterDateEndedAtGte string) ApiListRoomSessionsRequest {
	r.filterDateEndedAtGte = &filterDateEndedAtGte
	return r
}

// ISO 8601 date for filtering room sessions ended before that date.
func (r ApiListRoomSessionsRequest) FilterDateEndedAtLte(filterDateEndedAtLte string) ApiListRoomSessionsRequest {
	r.filterDateEndedAtLte = &filterDateEndedAtLte
	return r
}

// Room_id for filtering room sessions.
func (r ApiListRoomSessionsRequest) FilterRoomId(filterRoomId string) ApiListRoomSessionsRequest {
	r.filterRoomId = &filterRoomId
	return r
}

// Filter active or inactive room sessions.
func (r ApiListRoomSessionsRequest) FilterActive(filterActive bool) ApiListRoomSessionsRequest {
	r.filterActive = &filterActive
	return r
}

// To decide if room participants should be included in the response.
func (r ApiListRoomSessionsRequest) IncludeParticipants(includeParticipants bool) ApiListRoomSessionsRequest {
	r.includeParticipants = &includeParticipants
	return r
}

// The size of the page.
func (r ApiListRoomSessionsRequest) PageSize(pageSize int32) ApiListRoomSessionsRequest {
	r.pageSize = &pageSize
	return r
}

// The page number to load.
func (r ApiListRoomSessionsRequest) PageNumber(pageNumber int32) ApiListRoomSessionsRequest {
	r.pageNumber = &pageNumber
	return r
}

func (r ApiListRoomSessionsRequest) Execute() (*ListRoomSessions200Response, *http.Response, error) {
	return r.ApiService.ListRoomSessionsExecute(r)
}

/*
ListRoomSessions View a list of room sessions.



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListRoomSessionsRequest
*/
func (a *RoomSessionsAPIService) ListRoomSessions(ctx context.Context) ApiListRoomSessionsRequest {
	return ApiListRoomSessionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListRoomSessions200Response
func (a *RoomSessionsAPIService) ListRoomSessionsExecute(r ApiListRoomSessionsRequest) (*ListRoomSessions200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListRoomSessions200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomSessionsAPIService.ListRoomSessions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/room_sessions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterDateCreatedAtEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date_created_at][eq]", r.filterDateCreatedAtEq, "form", "")
	}
	if r.filterDateCreatedAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date_created_at][gte]", r.filterDateCreatedAtGte, "form", "")
	}
	if r.filterDateCreatedAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date_created_at][lte]", r.filterDateCreatedAtLte, "form", "")
	}
	if r.filterDateUpdatedAtEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date_updated_at][eq]", r.filterDateUpdatedAtEq, "form", "")
	}
	if r.filterDateUpdatedAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date_updated_at][gte]", r.filterDateUpdatedAtGte, "form", "")
	}
	if r.filterDateUpdatedAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date_updated_at][lte]", r.filterDateUpdatedAtLte, "form", "")
	}
	if r.filterDateEndedAtEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date_ended_at][eq]", r.filterDateEndedAtEq, "form", "")
	}
	if r.filterDateEndedAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date_ended_at][gte]", r.filterDateEndedAtGte, "form", "")
	}
	if r.filterDateEndedAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date_ended_at][lte]", r.filterDateEndedAtLte, "form", "")
	}
	if r.filterRoomId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[room_id]", r.filterRoomId, "form", "")
	}
	if r.filterActive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[active]", r.filterActive, "form", "")
	}
	if r.includeParticipants != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_participants", r.includeParticipants, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMuteParticipantInSessionRequest struct {
	ctx context.Context
	ApiService *RoomSessionsAPIService
	roomSessionId string
	actionsParticipantsRequest *ActionsParticipantsRequest
}

// Parameters that can be defined during Mute action.
func (r ApiMuteParticipantInSessionRequest) ActionsParticipantsRequest(actionsParticipantsRequest ActionsParticipantsRequest) ApiMuteParticipantInSessionRequest {
	r.actionsParticipantsRequest = &actionsParticipantsRequest
	return r
}

func (r ApiMuteParticipantInSessionRequest) Execute() (*EndSession200Response, *http.Response, error) {
	return r.ApiService.MuteParticipantInSessionExecute(r)
}

/*
MuteParticipantInSession Mute participants in room session.



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomSessionId The unique identifier of a room session.
 @return ApiMuteParticipantInSessionRequest
*/
func (a *RoomSessionsAPIService) MuteParticipantInSession(ctx context.Context, roomSessionId string) ApiMuteParticipantInSessionRequest {
	return ApiMuteParticipantInSessionRequest{
		ApiService: a,
		ctx: ctx,
		roomSessionId: roomSessionId,
	}
}

// Execute executes the request
//  @return EndSession200Response
func (a *RoomSessionsAPIService) MuteParticipantInSessionExecute(r ApiMuteParticipantInSessionRequest) (*EndSession200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EndSession200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomSessionsAPIService.MuteParticipantInSession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/room_sessions/{room_session_id}/actions/mute"
	localVarPath = strings.Replace(localVarPath, "{"+"room_session_id"+"}", url.PathEscape(parameterValueToString(r.roomSessionId, "roomSessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.actionsParticipantsRequest == nil {
		return localVarReturnValue, nil, reportError("actionsParticipantsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.actionsParticipantsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrieveListRoomParticipantsRequest struct {
	ctx context.Context
	ApiService *RoomSessionsAPIService
	roomSessionId string
	filterDateJoinedAtEq *string
	filterDateJoinedAtGte *string
	filterDateJoinedAtLte *string
	filterDateUpdatedAtEq *string
	filterDateUpdatedAtGte *string
	filterDateUpdatedAtLte *string
	filterDateLeftAtEq *string
	filterDateLeftAtGte *string
	filterDateLeftAtLte *string
	filterContext *string
	pageSize *int32
	pageNumber *int32
}

// ISO 8601 date for filtering room participants that joined on that date.
func (r ApiRetrieveListRoomParticipantsRequest) FilterDateJoinedAtEq(filterDateJoinedAtEq string) ApiRetrieveListRoomParticipantsRequest {
	r.filterDateJoinedAtEq = &filterDateJoinedAtEq
	return r
}

// ISO 8601 date for filtering room participants that joined after that date.
func (r ApiRetrieveListRoomParticipantsRequest) FilterDateJoinedAtGte(filterDateJoinedAtGte string) ApiRetrieveListRoomParticipantsRequest {
	r.filterDateJoinedAtGte = &filterDateJoinedAtGte
	return r
}

// ISO 8601 date for filtering room participants that joined before that date.
func (r ApiRetrieveListRoomParticipantsRequest) FilterDateJoinedAtLte(filterDateJoinedAtLte string) ApiRetrieveListRoomParticipantsRequest {
	r.filterDateJoinedAtLte = &filterDateJoinedAtLte
	return r
}

// ISO 8601 date for filtering room participants updated on that date.
func (r ApiRetrieveListRoomParticipantsRequest) FilterDateUpdatedAtEq(filterDateUpdatedAtEq string) ApiRetrieveListRoomParticipantsRequest {
	r.filterDateUpdatedAtEq = &filterDateUpdatedAtEq
	return r
}

// ISO 8601 date for filtering room participants updated after that date.
func (r ApiRetrieveListRoomParticipantsRequest) FilterDateUpdatedAtGte(filterDateUpdatedAtGte string) ApiRetrieveListRoomParticipantsRequest {
	r.filterDateUpdatedAtGte = &filterDateUpdatedAtGte
	return r
}

// ISO 8601 date for filtering room participants updated before that date.
func (r ApiRetrieveListRoomParticipantsRequest) FilterDateUpdatedAtLte(filterDateUpdatedAtLte string) ApiRetrieveListRoomParticipantsRequest {
	r.filterDateUpdatedAtLte = &filterDateUpdatedAtLte
	return r
}

// ISO 8601 date for filtering room participants that left on that date.
func (r ApiRetrieveListRoomParticipantsRequest) FilterDateLeftAtEq(filterDateLeftAtEq string) ApiRetrieveListRoomParticipantsRequest {
	r.filterDateLeftAtEq = &filterDateLeftAtEq
	return r
}

// ISO 8601 date for filtering room participants that left after that date.
func (r ApiRetrieveListRoomParticipantsRequest) FilterDateLeftAtGte(filterDateLeftAtGte string) ApiRetrieveListRoomParticipantsRequest {
	r.filterDateLeftAtGte = &filterDateLeftAtGte
	return r
}

// ISO 8601 date for filtering room participants that left before that date.
func (r ApiRetrieveListRoomParticipantsRequest) FilterDateLeftAtLte(filterDateLeftAtLte string) ApiRetrieveListRoomParticipantsRequest {
	r.filterDateLeftAtLte = &filterDateLeftAtLte
	return r
}

// Filter room participants based on the context.
func (r ApiRetrieveListRoomParticipantsRequest) FilterContext(filterContext string) ApiRetrieveListRoomParticipantsRequest {
	r.filterContext = &filterContext
	return r
}

// The size of the page.
func (r ApiRetrieveListRoomParticipantsRequest) PageSize(pageSize int32) ApiRetrieveListRoomParticipantsRequest {
	r.pageSize = &pageSize
	return r
}

// The page number to load.
func (r ApiRetrieveListRoomParticipantsRequest) PageNumber(pageNumber int32) ApiRetrieveListRoomParticipantsRequest {
	r.pageNumber = &pageNumber
	return r
}

func (r ApiRetrieveListRoomParticipantsRequest) Execute() (*ListRoomParticipants200Response, *http.Response, error) {
	return r.ApiService.RetrieveListRoomParticipantsExecute(r)
}

/*
RetrieveListRoomParticipants View a list of room participants.



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomSessionId The unique identifier of a room session.
 @return ApiRetrieveListRoomParticipantsRequest
*/
func (a *RoomSessionsAPIService) RetrieveListRoomParticipants(ctx context.Context, roomSessionId string) ApiRetrieveListRoomParticipantsRequest {
	return ApiRetrieveListRoomParticipantsRequest{
		ApiService: a,
		ctx: ctx,
		roomSessionId: roomSessionId,
	}
}

// Execute executes the request
//  @return ListRoomParticipants200Response
func (a *RoomSessionsAPIService) RetrieveListRoomParticipantsExecute(r ApiRetrieveListRoomParticipantsRequest) (*ListRoomParticipants200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListRoomParticipants200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomSessionsAPIService.RetrieveListRoomParticipants")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/room_sessions/{room_session_id}/participants"
	localVarPath = strings.Replace(localVarPath, "{"+"room_session_id"+"}", url.PathEscape(parameterValueToString(r.roomSessionId, "roomSessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterDateJoinedAtEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date_joined_at][eq]", r.filterDateJoinedAtEq, "form", "")
	}
	if r.filterDateJoinedAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date_joined_at][gte]", r.filterDateJoinedAtGte, "form", "")
	}
	if r.filterDateJoinedAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date_joined_at][lte]", r.filterDateJoinedAtLte, "form", "")
	}
	if r.filterDateUpdatedAtEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date_updated_at][eq]", r.filterDateUpdatedAtEq, "form", "")
	}
	if r.filterDateUpdatedAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date_updated_at][gte]", r.filterDateUpdatedAtGte, "form", "")
	}
	if r.filterDateUpdatedAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date_updated_at][lte]", r.filterDateUpdatedAtLte, "form", "")
	}
	if r.filterDateLeftAtEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date_left_at][eq]", r.filterDateLeftAtEq, "form", "")
	}
	if r.filterDateLeftAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date_left_at][gte]", r.filterDateLeftAtGte, "form", "")
	}
	if r.filterDateLeftAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date_left_at][lte]", r.filterDateLeftAtLte, "form", "")
	}
	if r.filterContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[context]", r.filterContext, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnmuteParticipantInSessionRequest struct {
	ctx context.Context
	ApiService *RoomSessionsAPIService
	roomSessionId string
	actionsParticipantsRequest *ActionsParticipantsRequest
}

// Parameters that can be defined during Unmute action.
func (r ApiUnmuteParticipantInSessionRequest) ActionsParticipantsRequest(actionsParticipantsRequest ActionsParticipantsRequest) ApiUnmuteParticipantInSessionRequest {
	r.actionsParticipantsRequest = &actionsParticipantsRequest
	return r
}

func (r ApiUnmuteParticipantInSessionRequest) Execute() (*EndSession200Response, *http.Response, error) {
	return r.ApiService.UnmuteParticipantInSessionExecute(r)
}

/*
UnmuteParticipantInSession Unmute participants in room session.



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomSessionId The unique identifier of a room session.
 @return ApiUnmuteParticipantInSessionRequest
*/
func (a *RoomSessionsAPIService) UnmuteParticipantInSession(ctx context.Context, roomSessionId string) ApiUnmuteParticipantInSessionRequest {
	return ApiUnmuteParticipantInSessionRequest{
		ApiService: a,
		ctx: ctx,
		roomSessionId: roomSessionId,
	}
}

// Execute executes the request
//  @return EndSession200Response
func (a *RoomSessionsAPIService) UnmuteParticipantInSessionExecute(r ApiUnmuteParticipantInSessionRequest) (*EndSession200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EndSession200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomSessionsAPIService.UnmuteParticipantInSession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/room_sessions/{room_session_id}/actions/unmute"
	localVarPath = strings.Replace(localVarPath, "{"+"room_session_id"+"}", url.PathEscape(parameterValueToString(r.roomSessionId, "roomSessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.actionsParticipantsRequest == nil {
		return localVarReturnValue, nil, reportError("actionsParticipantsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.actionsParticipantsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiViewRoomSessionRequest struct {
	ctx context.Context
	ApiService *RoomSessionsAPIService
	roomSessionId string
	includeParticipants *bool
}

// To decide if room participants should be included in the response.
func (r ApiViewRoomSessionRequest) IncludeParticipants(includeParticipants bool) ApiViewRoomSessionRequest {
	r.includeParticipants = &includeParticipants
	return r
}

func (r ApiViewRoomSessionRequest) Execute() (*ViewRoomSession200Response, *http.Response, error) {
	return r.ApiService.ViewRoomSessionExecute(r)
}

/*
ViewRoomSession View a room session.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomSessionId The unique identifier of a room session.
 @return ApiViewRoomSessionRequest
*/
func (a *RoomSessionsAPIService) ViewRoomSession(ctx context.Context, roomSessionId string) ApiViewRoomSessionRequest {
	return ApiViewRoomSessionRequest{
		ApiService: a,
		ctx: ctx,
		roomSessionId: roomSessionId,
	}
}

// Execute executes the request
//  @return ViewRoomSession200Response
func (a *RoomSessionsAPIService) ViewRoomSessionExecute(r ApiViewRoomSessionRequest) (*ViewRoomSession200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ViewRoomSession200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomSessionsAPIService.ViewRoomSession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/room_sessions/{room_session_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"room_session_id"+"}", url.PathEscape(parameterValueToString(r.roomSessionId, "roomSessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeParticipants != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_participants", r.includeParticipants, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
