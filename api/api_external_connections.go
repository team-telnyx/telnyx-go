/*
Telnyx API

SIP trunking, SMS, MMS, Call Control and Telephony Data Services.

API version: 2.0.0
Contact: support@telnyx.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package telnyx

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ExternalConnectionsAPIService ExternalConnectionsAPI service
type ExternalConnectionsAPIService service

type ApiCreateExternalConnectionRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionsAPIService
	createExternalConnectionRequest *CreateExternalConnectionRequest
}

// Parameters that can be set when creating a External Connection
func (r ApiCreateExternalConnectionRequest) CreateExternalConnectionRequest(createExternalConnectionRequest CreateExternalConnectionRequest) ApiCreateExternalConnectionRequest {
	r.createExternalConnectionRequest = &createExternalConnectionRequest
	return r
}

func (r ApiCreateExternalConnectionRequest) Execute() (*ExternalConnectionResponse, *http.Response, error) {
	return r.ApiService.CreateExternalConnectionExecute(r)
}

/*
CreateExternalConnection Creates an External Connection

Creates a new External Connection based on the parameters sent in the request. The external_sip_connection and outbound voice profile id are required. Once created, you can assign phone numbers to your application using the `/phone_numbers` endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateExternalConnectionRequest
*/
func (a *ExternalConnectionsAPIService) CreateExternalConnection(ctx context.Context) ApiCreateExternalConnectionRequest {
	return ApiCreateExternalConnectionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExternalConnectionResponse
func (a *ExternalConnectionsAPIService) CreateExternalConnectionExecute(r ApiCreateExternalConnectionRequest) (*ExternalConnectionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExternalConnectionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionsAPIService.CreateExternalConnection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external_connections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createExternalConnectionRequest == nil {
		return localVarReturnValue, nil, reportError("createExternalConnectionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createExternalConnectionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateExternalConnectionUploadRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionsAPIService
	id string
	createExternalConnectionUploadRequest *CreateExternalConnectionUploadRequest
}

// Parameters that can be set when creating an Upload request.
func (r ApiCreateExternalConnectionUploadRequest) CreateExternalConnectionUploadRequest(createExternalConnectionUploadRequest CreateExternalConnectionUploadRequest) ApiCreateExternalConnectionUploadRequest {
	r.createExternalConnectionUploadRequest = &createExternalConnectionUploadRequest
	return r
}

func (r ApiCreateExternalConnectionUploadRequest) Execute() (*CreateUploadRequestResponse, *http.Response, error) {
	return r.ApiService.CreateExternalConnectionUploadExecute(r)
}

/*
CreateExternalConnectionUpload Creates an Upload request

Creates a new Upload request to Microsoft teams with the included phone numbers. Only one of civic_address_id or location_id must be provided, not both. The maximum allowed phone numbers for the numbers_ids array is 1000.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the resource.
 @return ApiCreateExternalConnectionUploadRequest
*/
func (a *ExternalConnectionsAPIService) CreateExternalConnectionUpload(ctx context.Context, id string) ApiCreateExternalConnectionUploadRequest {
	return ApiCreateExternalConnectionUploadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreateUploadRequestResponse
func (a *ExternalConnectionsAPIService) CreateExternalConnectionUploadExecute(r ApiCreateExternalConnectionUploadRequest) (*CreateUploadRequestResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateUploadRequestResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionsAPIService.CreateExternalConnectionUpload")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external_connections/{id}/uploads"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createExternalConnectionUploadRequest == nil {
		return localVarReturnValue, nil, reportError("createExternalConnectionUploadRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createExternalConnectionUploadRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteExternalConnectionRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionsAPIService
	id string
}

func (r ApiDeleteExternalConnectionRequest) Execute() (*ExternalConnectionResponse, *http.Response, error) {
	return r.ApiService.DeleteExternalConnectionExecute(r)
}

/*
DeleteExternalConnection Deletes an External Connection

Permanently deletes an External Connection. Deletion may be prevented if the application is in use by phone numbers, is active, or if it is an Operator Connect connection. To remove an Operator Connect integration please contact Telnyx support.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the resource.
 @return ApiDeleteExternalConnectionRequest
*/
func (a *ExternalConnectionsAPIService) DeleteExternalConnection(ctx context.Context, id string) ApiDeleteExternalConnectionRequest {
	return ApiDeleteExternalConnectionRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ExternalConnectionResponse
func (a *ExternalConnectionsAPIService) DeleteExternalConnectionExecute(r ApiDeleteExternalConnectionRequest) (*ExternalConnectionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExternalConnectionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionsAPIService.DeleteExternalConnection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external_connections/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteExternalConnectionLogMessageRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionsAPIService
	id string
}

func (r ApiDeleteExternalConnectionLogMessageRequest) Execute() (*DismissRequestWasSuccessful, *http.Response, error) {
	return r.ApiService.DeleteExternalConnectionLogMessageExecute(r)
}

/*
DeleteExternalConnectionLogMessage Dismiss a log message

Dismiss a log message for an external connection associated with your account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the resource.
 @return ApiDeleteExternalConnectionLogMessageRequest
*/
func (a *ExternalConnectionsAPIService) DeleteExternalConnectionLogMessage(ctx context.Context, id string) ApiDeleteExternalConnectionLogMessageRequest {
	return ApiDeleteExternalConnectionLogMessageRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DismissRequestWasSuccessful
func (a *ExternalConnectionsAPIService) DeleteExternalConnectionLogMessageExecute(r ApiDeleteExternalConnectionLogMessageRequest) (*DismissRequestWasSuccessful, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DismissRequestWasSuccessful
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionsAPIService.DeleteExternalConnectionLogMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external_connections/log_messages/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExternalConnectionRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionsAPIService
	id string
}

func (r ApiGetExternalConnectionRequest) Execute() (*ExternalConnectionResponse, *http.Response, error) {
	return r.ApiService.GetExternalConnectionExecute(r)
}

/*
GetExternalConnection Retrieve an External Connection

Return the details of an existing External Connection inside the 'data' attribute of the response.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the resource.
 @return ApiGetExternalConnectionRequest
*/
func (a *ExternalConnectionsAPIService) GetExternalConnection(ctx context.Context, id string) ApiGetExternalConnectionRequest {
	return ApiGetExternalConnectionRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ExternalConnectionResponse
func (a *ExternalConnectionsAPIService) GetExternalConnectionExecute(r ApiGetExternalConnectionRequest) (*ExternalConnectionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExternalConnectionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionsAPIService.GetExternalConnection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external_connections/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExternalConnectionCivicAddressRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionsAPIService
	id string
	addressId string
}

func (r ApiGetExternalConnectionCivicAddressRequest) Execute() (*GetCivicAddressResponse, *http.Response, error) {
	return r.ApiService.GetExternalConnectionCivicAddressExecute(r)
}

/*
GetExternalConnectionCivicAddress Retrieve a Civic Address

Return the details of an existing Civic Address with its Locations inside the 'data' attribute of the response.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the resource.
 @param addressId Identifies a civic address or a location.
 @return ApiGetExternalConnectionCivicAddressRequest
*/
func (a *ExternalConnectionsAPIService) GetExternalConnectionCivicAddress(ctx context.Context, id string, addressId string) ApiGetExternalConnectionCivicAddressRequest {
	return ApiGetExternalConnectionCivicAddressRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		addressId: addressId,
	}
}

// Execute executes the request
//  @return GetCivicAddressResponse
func (a *ExternalConnectionsAPIService) GetExternalConnectionCivicAddressExecute(r ApiGetExternalConnectionCivicAddressRequest) (*GetCivicAddressResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCivicAddressResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionsAPIService.GetExternalConnectionCivicAddress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external_connections/{id}/civic_addresses/{address_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"address_id"+"}", url.PathEscape(parameterValueToString(r.addressId, "addressId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExternalConnectionLogMessageRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionsAPIService
	id string
}

func (r ApiGetExternalConnectionLogMessageRequest) Execute() (*GetLogMessageResponse, *http.Response, error) {
	return r.ApiService.GetExternalConnectionLogMessageExecute(r)
}

/*
GetExternalConnectionLogMessage Retrieve a log message

Retrieve a log message for an external connection associated with your account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the resource.
 @return ApiGetExternalConnectionLogMessageRequest
*/
func (a *ExternalConnectionsAPIService) GetExternalConnectionLogMessage(ctx context.Context, id string) ApiGetExternalConnectionLogMessageRequest {
	return ApiGetExternalConnectionLogMessageRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetLogMessageResponse
func (a *ExternalConnectionsAPIService) GetExternalConnectionLogMessageExecute(r ApiGetExternalConnectionLogMessageRequest) (*GetLogMessageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetLogMessageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionsAPIService.GetExternalConnectionLogMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external_connections/log_messages/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExternalConnectionPhoneNumberRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionsAPIService
	id string
	phoneNumberId string
}

func (r ApiGetExternalConnectionPhoneNumberRequest) Execute() (*GetExternalConnectionPhoneNumberResponse, *http.Response, error) {
	return r.ApiService.GetExternalConnectionPhoneNumberExecute(r)
}

/*
GetExternalConnectionPhoneNumber Retrieve a phone number

Return the details of a phone number associated with the given external connection.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the resource.
 @param phoneNumberId A phone number's ID via the Telnyx API
 @return ApiGetExternalConnectionPhoneNumberRequest
*/
func (a *ExternalConnectionsAPIService) GetExternalConnectionPhoneNumber(ctx context.Context, id string, phoneNumberId string) ApiGetExternalConnectionPhoneNumberRequest {
	return ApiGetExternalConnectionPhoneNumberRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		phoneNumberId: phoneNumberId,
	}
}

// Execute executes the request
//  @return GetExternalConnectionPhoneNumberResponse
func (a *ExternalConnectionsAPIService) GetExternalConnectionPhoneNumberExecute(r ApiGetExternalConnectionPhoneNumberRequest) (*GetExternalConnectionPhoneNumberResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetExternalConnectionPhoneNumberResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionsAPIService.GetExternalConnectionPhoneNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external_connections/{id}/phone_numbers/{phone_number_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"phone_number_id"+"}", url.PathEscape(parameterValueToString(r.phoneNumberId, "phoneNumberId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExternalConnectionReleaseRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionsAPIService
	id string
	releaseId string
}

func (r ApiGetExternalConnectionReleaseRequest) Execute() (*GetReleaseResponse, *http.Response, error) {
	return r.ApiService.GetExternalConnectionReleaseExecute(r)
}

/*
GetExternalConnectionRelease Retrieve a Release request

Return the details of a Release request and its phone numbers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the resource.
 @param releaseId Identifies a Release request
 @return ApiGetExternalConnectionReleaseRequest
*/
func (a *ExternalConnectionsAPIService) GetExternalConnectionRelease(ctx context.Context, id string, releaseId string) ApiGetExternalConnectionReleaseRequest {
	return ApiGetExternalConnectionReleaseRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		releaseId: releaseId,
	}
}

// Execute executes the request
//  @return GetReleaseResponse
func (a *ExternalConnectionsAPIService) GetExternalConnectionReleaseExecute(r ApiGetExternalConnectionReleaseRequest) (*GetReleaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetReleaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionsAPIService.GetExternalConnectionRelease")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external_connections/{id}/releases/{release_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"release_id"+"}", url.PathEscape(parameterValueToString(r.releaseId, "releaseId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExternalConnectionUploadRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionsAPIService
	id string
	ticketId string
}

func (r ApiGetExternalConnectionUploadRequest) Execute() (*GetUploadResponse, *http.Response, error) {
	return r.ApiService.GetExternalConnectionUploadExecute(r)
}

/*
GetExternalConnectionUpload Retrieve an Upload request

Return the details of an Upload request and its phone numbers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the resource.
 @param ticketId Identifies an Upload request
 @return ApiGetExternalConnectionUploadRequest
*/
func (a *ExternalConnectionsAPIService) GetExternalConnectionUpload(ctx context.Context, id string, ticketId string) ApiGetExternalConnectionUploadRequest {
	return ApiGetExternalConnectionUploadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		ticketId: ticketId,
	}
}

// Execute executes the request
//  @return GetUploadResponse
func (a *ExternalConnectionsAPIService) GetExternalConnectionUploadExecute(r ApiGetExternalConnectionUploadRequest) (*GetUploadResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetUploadResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionsAPIService.GetExternalConnectionUpload")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external_connections/{id}/uploads/{ticket_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ticket_id"+"}", url.PathEscape(parameterValueToString(r.ticketId, "ticketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExternalConnectionUploadsStatusRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionsAPIService
	id string
}

func (r ApiGetExternalConnectionUploadsStatusRequest) Execute() (*GetUploadsStatusResponse, *http.Response, error) {
	return r.ApiService.GetExternalConnectionUploadsStatusExecute(r)
}

/*
GetExternalConnectionUploadsStatus Get the count of pending upload requests

Returns the count of all pending upload requests for the given external connection.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the resource.
 @return ApiGetExternalConnectionUploadsStatusRequest
*/
func (a *ExternalConnectionsAPIService) GetExternalConnectionUploadsStatus(ctx context.Context, id string) ApiGetExternalConnectionUploadsStatusRequest {
	return ApiGetExternalConnectionUploadsStatusRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetUploadsStatusResponse
func (a *ExternalConnectionsAPIService) GetExternalConnectionUploadsStatusExecute(r ApiGetExternalConnectionUploadsStatusRequest) (*GetUploadsStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetUploadsStatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionsAPIService.GetExternalConnectionUploadsStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external_connections/{id}/uploads/status"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCivicAddressesRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionsAPIService
	id string
	filterCountry *[]string
}

// The country (or countries) to filter addresses by.
func (r ApiListCivicAddressesRequest) FilterCountry(filterCountry []string) ApiListCivicAddressesRequest {
	r.filterCountry = &filterCountry
	return r
}

func (r ApiListCivicAddressesRequest) Execute() (*GetAllCivicAddressesResponse, *http.Response, error) {
	return r.ApiService.ListCivicAddressesExecute(r)
}

/*
ListCivicAddresses List all civic addresses and locations

Returns the civic addresses and locations from Microsoft Teams.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the resource.
 @return ApiListCivicAddressesRequest
*/
func (a *ExternalConnectionsAPIService) ListCivicAddresses(ctx context.Context, id string) ApiListCivicAddressesRequest {
	return ApiListCivicAddressesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetAllCivicAddressesResponse
func (a *ExternalConnectionsAPIService) ListCivicAddressesExecute(r ApiListCivicAddressesRequest) (*GetAllCivicAddressesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAllCivicAddressesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionsAPIService.ListCivicAddresses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external_connections/{id}/civic_addresses"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterCountry != nil {
		t := *r.filterCountry
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[country]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[country]", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListExternalConnectionLogMessagesRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionsAPIService
	pageNumber *int32
	pageSize *int32
	filterExternalConnectionId *string
	filterTelephoneNumberContains *string
	filterTelephoneNumberEq *string
}

// The page number to load.
func (r ApiListExternalConnectionLogMessagesRequest) PageNumber(pageNumber int32) ApiListExternalConnectionLogMessagesRequest {
	r.pageNumber = &pageNumber
	return r
}

// The size of the page.
func (r ApiListExternalConnectionLogMessagesRequest) PageSize(pageSize int32) ApiListExternalConnectionLogMessagesRequest {
	r.pageSize = &pageSize
	return r
}

// The external connection ID to filter by or \&quot;null\&quot; to filter for logs without an external connection ID
func (r ApiListExternalConnectionLogMessagesRequest) FilterExternalConnectionId(filterExternalConnectionId string) ApiListExternalConnectionLogMessagesRequest {
	r.filterExternalConnectionId = &filterExternalConnectionId
	return r
}

// The partial phone number to filter log messages for. Requires 3-15 digits.
func (r ApiListExternalConnectionLogMessagesRequest) FilterTelephoneNumberContains(filterTelephoneNumberContains string) ApiListExternalConnectionLogMessagesRequest {
	r.filterTelephoneNumberContains = &filterTelephoneNumberContains
	return r
}

// The phone number to filter log messages for or \&quot;null\&quot; to filter for logs without a phone number
func (r ApiListExternalConnectionLogMessagesRequest) FilterTelephoneNumberEq(filterTelephoneNumberEq string) ApiListExternalConnectionLogMessagesRequest {
	r.filterTelephoneNumberEq = &filterTelephoneNumberEq
	return r
}

func (r ApiListExternalConnectionLogMessagesRequest) Execute() (*ListLogMessagesResponse, *http.Response, error) {
	return r.ApiService.ListExternalConnectionLogMessagesExecute(r)
}

/*
ListExternalConnectionLogMessages List all log messages

Retrieve a list of log messages for all external connections associated with your account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListExternalConnectionLogMessagesRequest
*/
func (a *ExternalConnectionsAPIService) ListExternalConnectionLogMessages(ctx context.Context) ApiListExternalConnectionLogMessagesRequest {
	return ApiListExternalConnectionLogMessagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListLogMessagesResponse
func (a *ExternalConnectionsAPIService) ListExternalConnectionLogMessagesExecute(r ApiListExternalConnectionLogMessagesRequest) (*ListLogMessagesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListLogMessagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionsAPIService.ListExternalConnectionLogMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external_connections/log_messages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.filterExternalConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[external_connection_id]", r.filterExternalConnectionId, "form", "")
	}
	if r.filterTelephoneNumberContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[telephone_number][contains]", r.filterTelephoneNumberContains, "form", "")
	}
	if r.filterTelephoneNumberEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[telephone_number][eq]", r.filterTelephoneNumberEq, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListExternalConnectionPhoneNumbersRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionsAPIService
	id string
	pageNumber *int32
	pageSize *int32
	filterPhoneNumberEq *string
	filterPhoneNumberContains *string
	filterCivicAddressIdEq *string
	filterLocationIdEq *string
}

// The page number to load.
func (r ApiListExternalConnectionPhoneNumbersRequest) PageNumber(pageNumber int32) ApiListExternalConnectionPhoneNumbersRequest {
	r.pageNumber = &pageNumber
	return r
}

// The size of the page.
func (r ApiListExternalConnectionPhoneNumbersRequest) PageSize(pageSize int32) ApiListExternalConnectionPhoneNumbersRequest {
	r.pageSize = &pageSize
	return r
}

// The phone number to filter by
func (r ApiListExternalConnectionPhoneNumbersRequest) FilterPhoneNumberEq(filterPhoneNumberEq string) ApiListExternalConnectionPhoneNumbersRequest {
	r.filterPhoneNumberEq = &filterPhoneNumberEq
	return r
}

// The partial phone number to filter by. Requires 3-15 digits.
func (r ApiListExternalConnectionPhoneNumbersRequest) FilterPhoneNumberContains(filterPhoneNumberContains string) ApiListExternalConnectionPhoneNumbersRequest {
	r.filterPhoneNumberContains = &filterPhoneNumberContains
	return r
}

// The civic address ID to filter by
func (r ApiListExternalConnectionPhoneNumbersRequest) FilterCivicAddressIdEq(filterCivicAddressIdEq string) ApiListExternalConnectionPhoneNumbersRequest {
	r.filterCivicAddressIdEq = &filterCivicAddressIdEq
	return r
}

// The location ID to filter by
func (r ApiListExternalConnectionPhoneNumbersRequest) FilterLocationIdEq(filterLocationIdEq string) ApiListExternalConnectionPhoneNumbersRequest {
	r.filterLocationIdEq = &filterLocationIdEq
	return r
}

func (r ApiListExternalConnectionPhoneNumbersRequest) Execute() (*ListExternalConnectionPhoneNumbersResponse, *http.Response, error) {
	return r.ApiService.ListExternalConnectionPhoneNumbersExecute(r)
}

/*
ListExternalConnectionPhoneNumbers List all phone numbers

Returns a list of all active phone numbers associated with the given external connection.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the resource.
 @return ApiListExternalConnectionPhoneNumbersRequest
*/
func (a *ExternalConnectionsAPIService) ListExternalConnectionPhoneNumbers(ctx context.Context, id string) ApiListExternalConnectionPhoneNumbersRequest {
	return ApiListExternalConnectionPhoneNumbersRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ListExternalConnectionPhoneNumbersResponse
func (a *ExternalConnectionsAPIService) ListExternalConnectionPhoneNumbersExecute(r ApiListExternalConnectionPhoneNumbersRequest) (*ListExternalConnectionPhoneNumbersResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListExternalConnectionPhoneNumbersResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionsAPIService.ListExternalConnectionPhoneNumbers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external_connections/{id}/phone_numbers"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.filterPhoneNumberEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[phone_number][eq]", r.filterPhoneNumberEq, "form", "")
	}
	if r.filterPhoneNumberContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[phone_number][contains]", r.filterPhoneNumberContains, "form", "")
	}
	if r.filterCivicAddressIdEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[civic_address_id][eq]", r.filterCivicAddressIdEq, "form", "")
	}
	if r.filterLocationIdEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[location_id][eq]", r.filterLocationIdEq, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListExternalConnectionReleasesRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionsAPIService
	id string
	pageNumber *int32
	pageSize *int32
	filterStatusEq *[]string
	filterCivicAddressIdEq *string
	filterLocationIdEq *string
	filterPhoneNumberEq *string
	filterPhoneNumberContains *string
}

// The page number to load.
func (r ApiListExternalConnectionReleasesRequest) PageNumber(pageNumber int32) ApiListExternalConnectionReleasesRequest {
	r.pageNumber = &pageNumber
	return r
}

// The size of the page.
func (r ApiListExternalConnectionReleasesRequest) PageSize(pageSize int32) ApiListExternalConnectionReleasesRequest {
	r.pageSize = &pageSize
	return r
}

// The status of the release to filter by
func (r ApiListExternalConnectionReleasesRequest) FilterStatusEq(filterStatusEq []string) ApiListExternalConnectionReleasesRequest {
	r.filterStatusEq = &filterStatusEq
	return r
}

// The civic address ID to filter by
func (r ApiListExternalConnectionReleasesRequest) FilterCivicAddressIdEq(filterCivicAddressIdEq string) ApiListExternalConnectionReleasesRequest {
	r.filterCivicAddressIdEq = &filterCivicAddressIdEq
	return r
}

// The location ID to filter by
func (r ApiListExternalConnectionReleasesRequest) FilterLocationIdEq(filterLocationIdEq string) ApiListExternalConnectionReleasesRequest {
	r.filterLocationIdEq = &filterLocationIdEq
	return r
}

// The phone number to filter by
func (r ApiListExternalConnectionReleasesRequest) FilterPhoneNumberEq(filterPhoneNumberEq string) ApiListExternalConnectionReleasesRequest {
	r.filterPhoneNumberEq = &filterPhoneNumberEq
	return r
}

// The partial phone number to filter by. Requires 3-15 digits.
func (r ApiListExternalConnectionReleasesRequest) FilterPhoneNumberContains(filterPhoneNumberContains string) ApiListExternalConnectionReleasesRequest {
	r.filterPhoneNumberContains = &filterPhoneNumberContains
	return r
}

func (r ApiListExternalConnectionReleasesRequest) Execute() (*ListReleasesResponse, *http.Response, error) {
	return r.ApiService.ListExternalConnectionReleasesExecute(r)
}

/*
ListExternalConnectionReleases List all Releases

Returns a list of your Releases for the given external connection. These are automatically created when you change the `connection_id` of a phone number that is currently on Microsoft Teams.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the resource.
 @return ApiListExternalConnectionReleasesRequest
*/
func (a *ExternalConnectionsAPIService) ListExternalConnectionReleases(ctx context.Context, id string) ApiListExternalConnectionReleasesRequest {
	return ApiListExternalConnectionReleasesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ListReleasesResponse
func (a *ExternalConnectionsAPIService) ListExternalConnectionReleasesExecute(r ApiListExternalConnectionReleasesRequest) (*ListReleasesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListReleasesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionsAPIService.ListExternalConnectionReleases")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external_connections/{id}/releases"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.filterStatusEq != nil {
		t := *r.filterStatusEq
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[status][eq]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[status][eq]", t, "form", "multi")
		}
	}
	if r.filterCivicAddressIdEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[civic_address_id][eq]", r.filterCivicAddressIdEq, "form", "")
	}
	if r.filterLocationIdEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[location_id][eq]", r.filterLocationIdEq, "form", "")
	}
	if r.filterPhoneNumberEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[phone_number][eq]", r.filterPhoneNumberEq, "form", "")
	}
	if r.filterPhoneNumberContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[phone_number][contains]", r.filterPhoneNumberContains, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListExternalConnectionUploadsRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionsAPIService
	id string
	pageNumber *int32
	pageSize *int32
	filterStatusEq *[]string
	filterCivicAddressIdEq *string
	filterLocationIdEq *string
	filterPhoneNumberEq *string
	filterPhoneNumberContains *string
}

// The page number to load.
func (r ApiListExternalConnectionUploadsRequest) PageNumber(pageNumber int32) ApiListExternalConnectionUploadsRequest {
	r.pageNumber = &pageNumber
	return r
}

// The size of the page.
func (r ApiListExternalConnectionUploadsRequest) PageSize(pageSize int32) ApiListExternalConnectionUploadsRequest {
	r.pageSize = &pageSize
	return r
}

// The status of the upload to filter by
func (r ApiListExternalConnectionUploadsRequest) FilterStatusEq(filterStatusEq []string) ApiListExternalConnectionUploadsRequest {
	r.filterStatusEq = &filterStatusEq
	return r
}

// The civic address ID to filter by
func (r ApiListExternalConnectionUploadsRequest) FilterCivicAddressIdEq(filterCivicAddressIdEq string) ApiListExternalConnectionUploadsRequest {
	r.filterCivicAddressIdEq = &filterCivicAddressIdEq
	return r
}

// The location ID to filter by
func (r ApiListExternalConnectionUploadsRequest) FilterLocationIdEq(filterLocationIdEq string) ApiListExternalConnectionUploadsRequest {
	r.filterLocationIdEq = &filterLocationIdEq
	return r
}

// The phone number to filter by
func (r ApiListExternalConnectionUploadsRequest) FilterPhoneNumberEq(filterPhoneNumberEq string) ApiListExternalConnectionUploadsRequest {
	r.filterPhoneNumberEq = &filterPhoneNumberEq
	return r
}

// The partial phone number to filter by. Requires 3-15 digits.
func (r ApiListExternalConnectionUploadsRequest) FilterPhoneNumberContains(filterPhoneNumberContains string) ApiListExternalConnectionUploadsRequest {
	r.filterPhoneNumberContains = &filterPhoneNumberContains
	return r
}

func (r ApiListExternalConnectionUploadsRequest) Execute() (*ListUploadsResponse, *http.Response, error) {
	return r.ApiService.ListExternalConnectionUploadsExecute(r)
}

/*
ListExternalConnectionUploads List all Upload requests

Returns a list of your Upload requests for the given external connection.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the resource.
 @return ApiListExternalConnectionUploadsRequest
*/
func (a *ExternalConnectionsAPIService) ListExternalConnectionUploads(ctx context.Context, id string) ApiListExternalConnectionUploadsRequest {
	return ApiListExternalConnectionUploadsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ListUploadsResponse
func (a *ExternalConnectionsAPIService) ListExternalConnectionUploadsExecute(r ApiListExternalConnectionUploadsRequest) (*ListUploadsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListUploadsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionsAPIService.ListExternalConnectionUploads")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external_connections/{id}/uploads"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.filterStatusEq != nil {
		t := *r.filterStatusEq
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[status][eq]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[status][eq]", t, "form", "multi")
		}
	}
	if r.filterCivicAddressIdEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[civic_address_id][eq]", r.filterCivicAddressIdEq, "form", "")
	}
	if r.filterLocationIdEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[location_id][eq]", r.filterLocationIdEq, "form", "")
	}
	if r.filterPhoneNumberEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[phone_number][eq]", r.filterPhoneNumberEq, "form", "")
	}
	if r.filterPhoneNumberContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[phone_number][contains]", r.filterPhoneNumberContains, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListExternalConnectionsRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionsAPIService
	pageNumber *int32
	pageSize *int32
	filterConnectionNameContains *string
	filterExternalSipConnection *string
	filterId *string
	filterCreatedAt *string
	filterPhoneNumberEq *string
}

// The page number to load.
func (r ApiListExternalConnectionsRequest) PageNumber(pageNumber int32) ApiListExternalConnectionsRequest {
	r.pageNumber = &pageNumber
	return r
}

// The size of the page.
func (r ApiListExternalConnectionsRequest) PageSize(pageSize int32) ApiListExternalConnectionsRequest {
	r.pageSize = &pageSize
	return r
}

// If present, connections with &lt;code&gt;connection_name&lt;/code&gt; containing the given value will be returned. Matching is not case-sensitive. Requires at least three characters.
func (r ApiListExternalConnectionsRequest) FilterConnectionNameContains(filterConnectionNameContains string) ApiListExternalConnectionsRequest {
	r.filterConnectionNameContains = &filterConnectionNameContains
	return r
}

// If present, connections with &lt;code&gt;external_sip_connection&lt;/code&gt; matching the given value will be returned.
func (r ApiListExternalConnectionsRequest) FilterExternalSipConnection(filterExternalSipConnection string) ApiListExternalConnectionsRequest {
	r.filterExternalSipConnection = &filterExternalSipConnection
	return r
}

// If present, connections with &lt;code&gt;id&lt;/code&gt; matching the given value will be returned.
func (r ApiListExternalConnectionsRequest) FilterId(filterId string) ApiListExternalConnectionsRequest {
	r.filterId = &filterId
	return r
}

// Filter by ISO 8601 formatted date-time string matching resource creation date-time.
func (r ApiListExternalConnectionsRequest) FilterCreatedAt(filterCreatedAt string) ApiListExternalConnectionsRequest {
	r.filterCreatedAt = &filterCreatedAt
	return r
}

// If present, connections associated with the given phone_number will be returned. A full match is necessary with a e164 format.
func (r ApiListExternalConnectionsRequest) FilterPhoneNumberEq(filterPhoneNumberEq string) ApiListExternalConnectionsRequest {
	r.filterPhoneNumberEq = &filterPhoneNumberEq
	return r
}

func (r ApiListExternalConnectionsRequest) Execute() (*GetAllExternalConnectionsResponse, *http.Response, error) {
	return r.ApiService.ListExternalConnectionsExecute(r)
}

/*
ListExternalConnections List all External Connections

This endpoint returns a list of your External Connections inside the 'data' attribute of the response. External Connections are used by Telnyx customers to seamless configure SIP trunking integrations with Telnyx Partners, through External Voice Integrations in Mission Control Portal.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListExternalConnectionsRequest
*/
func (a *ExternalConnectionsAPIService) ListExternalConnections(ctx context.Context) ApiListExternalConnectionsRequest {
	return ApiListExternalConnectionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAllExternalConnectionsResponse
func (a *ExternalConnectionsAPIService) ListExternalConnectionsExecute(r ApiListExternalConnectionsRequest) (*GetAllExternalConnectionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAllExternalConnectionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionsAPIService.ListExternalConnections")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external_connections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.filterConnectionNameContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[connection_name][contains]", r.filterConnectionNameContains, "form", "")
	}
	if r.filterExternalSipConnection != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[external_sip_connection]", r.filterExternalSipConnection, "form", "")
	}
	if r.filterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[id]", r.filterId, "form", "")
	}
	if r.filterCreatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[created_at]", r.filterCreatedAt, "form", "")
	}
	if r.filterPhoneNumberEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[phone_number][eq]", r.filterPhoneNumberEq, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOperatorConnectRefreshRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionsAPIService
}

func (r ApiOperatorConnectRefreshRequest) Execute() (*OperatorConnectRefreshResponse, *http.Response, error) {
	return r.ApiService.OperatorConnectRefreshExecute(r)
}

/*
OperatorConnectRefresh Refresh Operator Connect integration

This endpoint will make an asynchronous request to refresh the Operator Connect integration with Microsoft Teams for the current user. This will create new external connections on the user's account if needed, and/or report the integration results as [log messages](https://developers.telnyx.com/api/external-voice-integrations/list-external-connection-log-messages).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOperatorConnectRefreshRequest
*/
func (a *ExternalConnectionsAPIService) OperatorConnectRefresh(ctx context.Context) ApiOperatorConnectRefreshRequest {
	return ApiOperatorConnectRefreshRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OperatorConnectRefreshResponse
func (a *ExternalConnectionsAPIService) OperatorConnectRefreshExecute(r ApiOperatorConnectRefreshRequest) (*OperatorConnectRefreshResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OperatorConnectRefreshResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionsAPIService.OperatorConnectRefresh")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/operator_connect/actions/refresh"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRefreshExternalConnectionUploadsRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionsAPIService
	id string
}

func (r ApiRefreshExternalConnectionUploadsRequest) Execute() (*CreateUploadRequestResponse1, *http.Response, error) {
	return r.ApiService.RefreshExternalConnectionUploadsExecute(r)
}

/*
RefreshExternalConnectionUploads Refresh the status of all Upload requests

Forces a recheck of the status of all pending Upload requests for the given external connection in the background.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the resource.
 @return ApiRefreshExternalConnectionUploadsRequest
*/
func (a *ExternalConnectionsAPIService) RefreshExternalConnectionUploads(ctx context.Context, id string) ApiRefreshExternalConnectionUploadsRequest {
	return ApiRefreshExternalConnectionUploadsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreateUploadRequestResponse1
func (a *ExternalConnectionsAPIService) RefreshExternalConnectionUploadsExecute(r ApiRefreshExternalConnectionUploadsRequest) (*CreateUploadRequestResponse1, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateUploadRequestResponse1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionsAPIService.RefreshExternalConnectionUploads")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external_connections/{id}/uploads/refresh"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetryUploadRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionsAPIService
	id string
	ticketId string
}

func (r ApiRetryUploadRequest) Execute() (*GetUploadResponse, *http.Response, error) {
	return r.ApiService.RetryUploadExecute(r)
}

/*
RetryUpload Retry an Upload request

If there were any errors during the upload process, this endpoint will retry the upload request. In some cases this will reattempt the existing upload request, in other cases it may create a new upload request. Please check the ticket_id in the response to determine if a new upload request was created.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the resource.
 @param ticketId Identifies an Upload request
 @return ApiRetryUploadRequest
*/
func (a *ExternalConnectionsAPIService) RetryUpload(ctx context.Context, id string, ticketId string) ApiRetryUploadRequest {
	return ApiRetryUploadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		ticketId: ticketId,
	}
}

// Execute executes the request
//  @return GetUploadResponse
func (a *ExternalConnectionsAPIService) RetryUploadExecute(r ApiRetryUploadRequest) (*GetUploadResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetUploadResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionsAPIService.RetryUpload")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external_connections/{id}/uploads/{ticket_id}/retry"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ticket_id"+"}", url.PathEscape(parameterValueToString(r.ticketId, "ticketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateExternalConnectionRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionsAPIService
	id string
	updateExternalConnectionRequest *UpdateExternalConnectionRequest
}

// Parameters to be updated for the External Connection
func (r ApiUpdateExternalConnectionRequest) UpdateExternalConnectionRequest(updateExternalConnectionRequest UpdateExternalConnectionRequest) ApiUpdateExternalConnectionRequest {
	r.updateExternalConnectionRequest = &updateExternalConnectionRequest
	return r
}

func (r ApiUpdateExternalConnectionRequest) Execute() (*ExternalConnectionResponse, *http.Response, error) {
	return r.ApiService.UpdateExternalConnectionExecute(r)
}

/*
UpdateExternalConnection Update an External Connection

Updates settings of an existing External Connection based on the parameters of the request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the resource.
 @return ApiUpdateExternalConnectionRequest
*/
func (a *ExternalConnectionsAPIService) UpdateExternalConnection(ctx context.Context, id string) ApiUpdateExternalConnectionRequest {
	return ApiUpdateExternalConnectionRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ExternalConnectionResponse
func (a *ExternalConnectionsAPIService) UpdateExternalConnectionExecute(r ApiUpdateExternalConnectionRequest) (*ExternalConnectionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExternalConnectionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionsAPIService.UpdateExternalConnection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external_connections/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateExternalConnectionRequest == nil {
		return localVarReturnValue, nil, reportError("updateExternalConnectionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateExternalConnectionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateExternalConnectionPhoneNumberRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionsAPIService
	id string
	phoneNumberId string
	updateExternalConnectionPhoneNumberRequest *UpdateExternalConnectionPhoneNumberRequest
}

// Values that can be set when updating a phone number
func (r ApiUpdateExternalConnectionPhoneNumberRequest) UpdateExternalConnectionPhoneNumberRequest(updateExternalConnectionPhoneNumberRequest UpdateExternalConnectionPhoneNumberRequest) ApiUpdateExternalConnectionPhoneNumberRequest {
	r.updateExternalConnectionPhoneNumberRequest = &updateExternalConnectionPhoneNumberRequest
	return r
}

func (r ApiUpdateExternalConnectionPhoneNumberRequest) Execute() (*GetExternalConnectionPhoneNumberResponse, *http.Response, error) {
	return r.ApiService.UpdateExternalConnectionPhoneNumberExecute(r)
}

/*
UpdateExternalConnectionPhoneNumber Update a phone number

Asynchronously update settings of the phone number associated with the given external connection.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifies the resource.
 @param phoneNumberId A phone number's ID via the Telnyx API
 @return ApiUpdateExternalConnectionPhoneNumberRequest
*/
func (a *ExternalConnectionsAPIService) UpdateExternalConnectionPhoneNumber(ctx context.Context, id string, phoneNumberId string) ApiUpdateExternalConnectionPhoneNumberRequest {
	return ApiUpdateExternalConnectionPhoneNumberRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		phoneNumberId: phoneNumberId,
	}
}

// Execute executes the request
//  @return GetExternalConnectionPhoneNumberResponse
func (a *ExternalConnectionsAPIService) UpdateExternalConnectionPhoneNumberExecute(r ApiUpdateExternalConnectionPhoneNumberRequest) (*GetExternalConnectionPhoneNumberResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetExternalConnectionPhoneNumberResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionsAPIService.UpdateExternalConnectionPhoneNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external_connections/{id}/phone_numbers/{phone_number_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"phone_number_id"+"}", url.PathEscape(parameterValueToString(r.phoneNumberId, "phoneNumberId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateExternalConnectionPhoneNumberRequest == nil {
		return localVarReturnValue, nil, reportError("updateExternalConnectionPhoneNumberRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateExternalConnectionPhoneNumberRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateLocationRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionsAPIService
	id string
	locationId string
	updateLocationRequest *UpdateLocationRequest
}

func (r ApiUpdateLocationRequest) UpdateLocationRequest(updateLocationRequest UpdateLocationRequest) ApiUpdateLocationRequest {
	r.updateLocationRequest = &updateLocationRequest
	return r
}

func (r ApiUpdateLocationRequest) Execute() (*LocationResponse, *http.Response, error) {
	return r.ApiService.UpdateLocationExecute(r)
}

/*
UpdateLocation Update a location's static emergency address

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the external connection
 @param locationId The ID of the location to update
 @return ApiUpdateLocationRequest
*/
func (a *ExternalConnectionsAPIService) UpdateLocation(ctx context.Context, id string, locationId string) ApiUpdateLocationRequest {
	return ApiUpdateLocationRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		locationId: locationId,
	}
}

// Execute executes the request
//  @return LocationResponse
func (a *ExternalConnectionsAPIService) UpdateLocationExecute(r ApiUpdateLocationRequest) (*LocationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LocationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionsAPIService.UpdateLocation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external_connections/{id}/locations/{location_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"location_id"+"}", url.PathEscape(parameterValueToString(r.locationId, "locationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateLocationRequest == nil {
		return localVarReturnValue, nil, reportError("updateLocationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateLocationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
