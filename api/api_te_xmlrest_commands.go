/*
Telnyx API

SIP trunking, SMS, MMS, Call Control and Telephony Data Services.

API version: 2.0.0
Contact: support@telnyx.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package telnyx

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// TeXMLRESTCommandsAPIService TeXMLRESTCommandsAPI service
type TeXMLRESTCommandsAPIService service

type ApiCreateTexmlSecretRequest struct {
	ctx context.Context
	ApiService *TeXMLRESTCommandsAPIService
	createTeXMLSecretRequest *CreateTeXMLSecretRequest
}

// Create TeXML secret request object
func (r ApiCreateTexmlSecretRequest) CreateTeXMLSecretRequest(createTeXMLSecretRequest CreateTeXMLSecretRequest) ApiCreateTexmlSecretRequest {
	r.createTeXMLSecretRequest = &createTeXMLSecretRequest
	return r
}

func (r ApiCreateTexmlSecretRequest) Execute() (*CreateTeXMLSecretRequest, *http.Response, error) {
	return r.ApiService.CreateTexmlSecretExecute(r)
}

/*
CreateTexmlSecret Create a TeXML secret

Create a TeXML secret which can be later used as a Dynamic Parameter for TeXML when using Mustache Templates in your TeXML. In your TeXML you will be able to use your secret name, and this name will be replaced by the actual secret value when processing the TeXML on Telnyx side.  The secrets are not visible in any logs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTexmlSecretRequest
*/
func (a *TeXMLRESTCommandsAPIService) CreateTexmlSecret(ctx context.Context) ApiCreateTexmlSecretRequest {
	return ApiCreateTexmlSecretRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateTeXMLSecretRequest
func (a *TeXMLRESTCommandsAPIService) CreateTexmlSecretExecute(r ApiCreateTexmlSecretRequest) (*CreateTeXMLSecretRequest, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTeXMLSecretRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeXMLRESTCommandsAPIService.CreateTexmlSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/texml/secrets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createTeXMLSecretRequest == nil {
		return localVarReturnValue, nil, reportError("createTeXMLSecretRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createTeXMLSecretRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteTeXMLCallRecordingRequest struct {
	ctx context.Context
	ApiService *TeXMLRESTCommandsAPIService
	accountSid string
	recordingSid string
}

func (r ApiDeleteTeXMLCallRecordingRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteTeXMLCallRecordingExecute(r)
}

/*
DeleteTeXMLCallRecording Delete recording resource

Deletes recording resource identified by recording id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The id of the account the resource belongs to.
 @param recordingSid Uniquely identifies the recording by id.
 @return ApiDeleteTeXMLCallRecordingRequest
*/
func (a *TeXMLRESTCommandsAPIService) DeleteTeXMLCallRecording(ctx context.Context, accountSid string, recordingSid string) ApiDeleteTeXMLCallRecordingRequest {
	return ApiDeleteTeXMLCallRecordingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		recordingSid: recordingSid,
	}
}

// Execute executes the request
func (a *TeXMLRESTCommandsAPIService) DeleteTeXMLCallRecordingExecute(r ApiDeleteTeXMLCallRecordingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeXMLRESTCommandsAPIService.DeleteTeXMLCallRecording")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/texml/Accounts/{account_sid}/Recordings/{recording_sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"account_sid"+"}", url.PathEscape(parameterValueToString(r.accountSid, "accountSid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"recording_sid"+"}", url.PathEscape(parameterValueToString(r.recordingSid, "recordingSid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteTeXMLRecordingTranscriptionRequest struct {
	ctx context.Context
	ApiService *TeXMLRESTCommandsAPIService
	accountSid string
	recordingTranscriptionSid string
}

func (r ApiDeleteTeXMLRecordingTranscriptionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteTeXMLRecordingTranscriptionExecute(r)
}

/*
DeleteTeXMLRecordingTranscription Delete a recording transcription

Permanently deletes a recording transcription.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The id of the account the resource belongs to.
 @param recordingTranscriptionSid Uniquely identifies the recording transcription by id.
 @return ApiDeleteTeXMLRecordingTranscriptionRequest
*/
func (a *TeXMLRESTCommandsAPIService) DeleteTeXMLRecordingTranscription(ctx context.Context, accountSid string, recordingTranscriptionSid string) ApiDeleteTeXMLRecordingTranscriptionRequest {
	return ApiDeleteTeXMLRecordingTranscriptionRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		recordingTranscriptionSid: recordingTranscriptionSid,
	}
}

// Execute executes the request
func (a *TeXMLRESTCommandsAPIService) DeleteTeXMLRecordingTranscriptionExecute(r ApiDeleteTeXMLRecordingTranscriptionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeXMLRESTCommandsAPIService.DeleteTeXMLRecordingTranscription")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/texml/Accounts/{account_sid}/Transcriptions/{recording_transcription_sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"account_sid"+"}", url.PathEscape(parameterValueToString(r.accountSid, "accountSid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"recording_transcription_sid"+"}", url.PathEscape(parameterValueToString(r.recordingTranscriptionSid, "recordingTranscriptionSid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteTexmlConferenceParticipantRequest struct {
	ctx context.Context
	ApiService *TeXMLRESTCommandsAPIService
	accountSid string
	conferenceSid string
	callSid string
}

func (r ApiDeleteTexmlConferenceParticipantRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteTexmlConferenceParticipantExecute(r)
}

/*
DeleteTexmlConferenceParticipant Delete a conference participant

Deletes a conference participant

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The id of the account the resource belongs to.
 @param conferenceSid The ConferenceSid that uniquely identifies a conference.
 @param callSid The CallSid that identifies the call to update.
 @return ApiDeleteTexmlConferenceParticipantRequest
*/
func (a *TeXMLRESTCommandsAPIService) DeleteTexmlConferenceParticipant(ctx context.Context, accountSid string, conferenceSid string, callSid string) ApiDeleteTexmlConferenceParticipantRequest {
	return ApiDeleteTexmlConferenceParticipantRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		conferenceSid: conferenceSid,
		callSid: callSid,
	}
}

// Execute executes the request
func (a *TeXMLRESTCommandsAPIService) DeleteTexmlConferenceParticipantExecute(r ApiDeleteTexmlConferenceParticipantRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeXMLRESTCommandsAPIService.DeleteTexmlConferenceParticipant")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/texml/Accounts/{account_sid}/Conferences/{conference_sid}/Participants/{call_sid}"
	localVarPath = strings.Replace(localVarPath, "{"+"account_sid"+"}", url.PathEscape(parameterValueToString(r.accountSid, "accountSid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conference_sid"+"}", url.PathEscape(parameterValueToString(r.conferenceSid, "conferenceSid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_sid"+"}", url.PathEscape(parameterValueToString(r.callSid, "callSid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeprecatedInitiateTexmlCallRequest struct {
	ctx context.Context
	ApiService *TeXMLRESTCommandsAPIService
	applicationId string
	deprecatedInitiateCallRequest *DeprecatedInitiateCallRequest
}

// Iniatiate Call request object
func (r ApiDeprecatedInitiateTexmlCallRequest) DeprecatedInitiateCallRequest(deprecatedInitiateCallRequest DeprecatedInitiateCallRequest) ApiDeprecatedInitiateTexmlCallRequest {
	r.deprecatedInitiateCallRequest = &deprecatedInitiateCallRequest
	return r
}

func (r ApiDeprecatedInitiateTexmlCallRequest) Execute() (*InitiateTeXMLCallResponse, *http.Response, error) {
	return r.ApiService.DeprecatedInitiateTexmlCallExecute(r)
}

/*
DeprecatedInitiateTexmlCall (Deprecated) Initiate an outbound call

Initiate an outbound TeXML call. Telnyx will request TeXML from the XML Request URL configured for the connection in the Mission Control Portal.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId The ID of the TeXML application used for the call.
 @return ApiDeprecatedInitiateTexmlCallRequest
*/
func (a *TeXMLRESTCommandsAPIService) DeprecatedInitiateTexmlCall(ctx context.Context, applicationId string) ApiDeprecatedInitiateTexmlCallRequest {
	return ApiDeprecatedInitiateTexmlCallRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
	}
}

// Execute executes the request
//  @return InitiateTeXMLCallResponse
func (a *TeXMLRESTCommandsAPIService) DeprecatedInitiateTexmlCallExecute(r ApiDeprecatedInitiateTexmlCallRequest) (*InitiateTeXMLCallResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InitiateTeXMLCallResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeXMLRESTCommandsAPIService.DeprecatedInitiateTexmlCall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/texml/calls/{application_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"application_id"+"}", url.PathEscape(parameterValueToString(r.applicationId, "applicationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deprecatedInitiateCallRequest == nil {
		return localVarReturnValue, nil, reportError("deprecatedInitiateCallRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deprecatedInitiateCallRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeprecatedUpdateTexmlCallRequest struct {
	ctx context.Context
	ApiService *TeXMLRESTCommandsAPIService
	callSid string
	updateCallRequest *UpdateCallRequest
}

// Update Call request object
func (r ApiDeprecatedUpdateTexmlCallRequest) UpdateCallRequest(updateCallRequest UpdateCallRequest) ApiDeprecatedUpdateTexmlCallRequest {
	r.updateCallRequest = &updateCallRequest
	return r
}

func (r ApiDeprecatedUpdateTexmlCallRequest) Execute() (*TeXMLRESTCommandResponse, *http.Response, error) {
	return r.ApiService.DeprecatedUpdateTexmlCallExecute(r)
}

/*
DeprecatedUpdateTexmlCall (Deprecated) Update call

Update TeXML call. Please note that the keys present in the payload MUST BE formatted in CamelCase as specified in the example.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callSid The CallSid that identifies the call to update.
 @return ApiDeprecatedUpdateTexmlCallRequest
*/
func (a *TeXMLRESTCommandsAPIService) DeprecatedUpdateTexmlCall(ctx context.Context, callSid string) ApiDeprecatedUpdateTexmlCallRequest {
	return ApiDeprecatedUpdateTexmlCallRequest{
		ApiService: a,
		ctx: ctx,
		callSid: callSid,
	}
}

// Execute executes the request
//  @return TeXMLRESTCommandResponse
func (a *TeXMLRESTCommandsAPIService) DeprecatedUpdateTexmlCallExecute(r ApiDeprecatedUpdateTexmlCallRequest) (*TeXMLRESTCommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TeXMLRESTCommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeXMLRESTCommandsAPIService.DeprecatedUpdateTexmlCall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/texml/calls/{call_sid}/update"
	localVarPath = strings.Replace(localVarPath, "{"+"call_sid"+"}", url.PathEscape(parameterValueToString(r.callSid, "callSid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateCallRequest == nil {
		return localVarReturnValue, nil, reportError("updateCallRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateCallRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDialTexmlConferenceParticipantRequest struct {
	ctx context.Context
	ApiService *TeXMLRESTCommandsAPIService
	accountSid string
	conferenceSid string
	beep *string
	statusCallback *string
	statusCallbackMethod *string
	statusCallbackEvent *string
	to *string
	from *string
	timeout *int32
	muted *bool
	startConferenceOnEnter *bool
	endConferenceOnExit *bool
	earlyMedia *bool
	conferenceStatusCallback *string
	conferenceStatusCallbackMethod *string
	conferenceStatusCallbackEvent *string
	waitUrl *string
	maxParticipants *int32
	coaching *bool
	callSidToCoach *string
	callerId *string
	timeLimit *int32
	machineDetection *string
	machineDetectionTimeout *int32
	machineDetectionSpeechThreshold *int32
	machineDetectionSpeechEndThreshold *int32
	machineDetectionSilenceTimeout *int32
	amdStatusCallback *string
	amdStatusCallbackMethod *string
	cancelPlaybackOnMachineDetection *bool
	cancelPlaybackOnDetectMessageEnd *bool
	preferredCodecs *string
	record *bool
	recordingChannels *string
	recordingStatusCallback *string
	recordingStatusCallbackMethod *string
	recordingStatusCallbackEvent *string
	recordingTrack *string
	sipAuthPassword *string
	sipAuthUsername *string
	trim *string
	conferenceRecord *string
	conferenceRecordingStatusCallback *string
	conferenceRecordingStatusCallbackMethod *string
	conferenceRecordingStatusCallbackEvent *string
	conferenceRecordingTimeout *int32
	conferenceTrim *string
}

// Whether to play a notification beep to the conference when the participant enters and exits.
func (r ApiDialTexmlConferenceParticipantRequest) Beep(beep string) ApiDialTexmlConferenceParticipantRequest {
	r.beep = &beep
	return r
}

// URL destination for Telnyx to send status callback events to for the call.
func (r ApiDialTexmlConferenceParticipantRequest) StatusCallback(statusCallback string) ApiDialTexmlConferenceParticipantRequest {
	r.statusCallback = &statusCallback
	return r
}

// HTTP request type used for &#x60;StatusCallback&#x60;.
func (r ApiDialTexmlConferenceParticipantRequest) StatusCallbackMethod(statusCallbackMethod string) ApiDialTexmlConferenceParticipantRequest {
	r.statusCallbackMethod = &statusCallbackMethod
	return r
}

// The changes to the call&#39;s state that should generate a call to &#x60;StatusCallback&#x60;. Can be: &#x60;initiated&#x60;, &#x60;ringing&#x60;, &#x60;answered&#x60;, and &#x60;completed&#x60;. Separate multiple values with a space. The default value is &#x60;completed&#x60;.
func (r ApiDialTexmlConferenceParticipantRequest) StatusCallbackEvent(statusCallbackEvent string) ApiDialTexmlConferenceParticipantRequest {
	r.statusCallbackEvent = &statusCallbackEvent
	return r
}

// The phone number of the called party. Phone numbers are formatted with a &#x60;+&#x60; and country code.
func (r ApiDialTexmlConferenceParticipantRequest) To(to string) ApiDialTexmlConferenceParticipantRequest {
	r.to = &to
	return r
}

// The phone number of the party that initiated the call. Phone numbers are formatted with a &#x60;+&#x60; and country code.
func (r ApiDialTexmlConferenceParticipantRequest) From(from string) ApiDialTexmlConferenceParticipantRequest {
	r.from = &from
	return r
}

// The number of seconds that we should allow the phone to ring before assuming there is no answer. Can be an integer between 5 and 120, inclusive. The default value is 30.
func (r ApiDialTexmlConferenceParticipantRequest) Timeout(timeout int32) ApiDialTexmlConferenceParticipantRequest {
	r.timeout = &timeout
	return r
}

// Whether the participant should be muted.
func (r ApiDialTexmlConferenceParticipantRequest) Muted(muted bool) ApiDialTexmlConferenceParticipantRequest {
	r.muted = &muted
	return r
}

// Whether to start the conference when the participant enters. Defaults to &#x60;true&#x60;.
func (r ApiDialTexmlConferenceParticipantRequest) StartConferenceOnEnter(startConferenceOnEnter bool) ApiDialTexmlConferenceParticipantRequest {
	r.startConferenceOnEnter = &startConferenceOnEnter
	return r
}

// Whether to end the conference when the participant leaves. Defaults to &#x60;false&#x60;.
func (r ApiDialTexmlConferenceParticipantRequest) EndConferenceOnExit(endConferenceOnExit bool) ApiDialTexmlConferenceParticipantRequest {
	r.endConferenceOnExit = &endConferenceOnExit
	return r
}

// Whether participant shall be bridged to conference before the participant answers (from early media if available). Defaults to &#x60;false&#x60;.
func (r ApiDialTexmlConferenceParticipantRequest) EarlyMedia(earlyMedia bool) ApiDialTexmlConferenceParticipantRequest {
	r.earlyMedia = &earlyMedia
	return r
}

// The URL the conference callbacks will be sent to.
func (r ApiDialTexmlConferenceParticipantRequest) ConferenceStatusCallback(conferenceStatusCallback string) ApiDialTexmlConferenceParticipantRequest {
	r.conferenceStatusCallback = &conferenceStatusCallback
	return r
}

// HTTP request type used for &#x60;ConferenceStatusCallback&#x60;. Defaults to &#x60;POST&#x60;.
func (r ApiDialTexmlConferenceParticipantRequest) ConferenceStatusCallbackMethod(conferenceStatusCallbackMethod string) ApiDialTexmlConferenceParticipantRequest {
	r.conferenceStatusCallbackMethod = &conferenceStatusCallbackMethod
	return r
}

// The changes to the conference&#39;s state that should generate a call to &#x60;ConferenceStatusCallback&#x60;. Can be: &#x60;start&#x60;, &#x60;end&#x60;, &#x60;join&#x60; and &#x60;leave&#x60;. Separate multiple values with a space. By default no callbacks are sent.
func (r ApiDialTexmlConferenceParticipantRequest) ConferenceStatusCallbackEvent(conferenceStatusCallbackEvent string) ApiDialTexmlConferenceParticipantRequest {
	r.conferenceStatusCallbackEvent = &conferenceStatusCallbackEvent
	return r
}

// The URL to call for an audio file to play while the participant is waiting for the conference to start.
func (r ApiDialTexmlConferenceParticipantRequest) WaitUrl(waitUrl string) ApiDialTexmlConferenceParticipantRequest {
	r.waitUrl = &waitUrl
	return r
}

// The maximum number of participants in the conference. Can be a positive integer from 2 to 800. The default value is 250.
func (r ApiDialTexmlConferenceParticipantRequest) MaxParticipants(maxParticipants int32) ApiDialTexmlConferenceParticipantRequest {
	r.maxParticipants = &maxParticipants
	return r
}

// Whether the participant is coaching another call. When &#x60;true&#x60;, &#x60;CallSidToCoach&#x60; has to be given.
func (r ApiDialTexmlConferenceParticipantRequest) Coaching(coaching bool) ApiDialTexmlConferenceParticipantRequest {
	r.coaching = &coaching
	return r
}

// The SID of the participant who is being coached. The participant being coached is the only participant who can hear the participant who is coaching.
func (r ApiDialTexmlConferenceParticipantRequest) CallSidToCoach(callSidToCoach string) ApiDialTexmlConferenceParticipantRequest {
	r.callSidToCoach = &callSidToCoach
	return r
}

// To be used as the caller id name (SIP From Display Name) presented to the destination (&#x60;To&#x60; number). The string should have a maximum of 128 characters, containing only letters, numbers, spaces, and &#x60;-_~!.+&#x60; special characters. If ommited, the display name will be the same as the number in the &#x60;From&#x60; field.
func (r ApiDialTexmlConferenceParticipantRequest) CallerId(callerId string) ApiDialTexmlConferenceParticipantRequest {
	r.callerId = &callerId
	return r
}

// The maximum duration of the call in seconds.
func (r ApiDialTexmlConferenceParticipantRequest) TimeLimit(timeLimit int32) ApiDialTexmlConferenceParticipantRequest {
	r.timeLimit = &timeLimit
	return r
}

// Whether to detect if a human or an answering machine picked up the call. Use &#x60;Enable&#x60; if you would like to ne notified as soon as the called party is identified. Use &#x60;DetectMessageEnd&#x60;, if you would like to leave a message on an answering machine.
func (r ApiDialTexmlConferenceParticipantRequest) MachineDetection(machineDetection string) ApiDialTexmlConferenceParticipantRequest {
	r.machineDetection = &machineDetection
	return r
}

// How long answering machine detection should go on for before sending an &#x60;Unknown&#x60; result. Given in milliseconds.
func (r ApiDialTexmlConferenceParticipantRequest) MachineDetectionTimeout(machineDetectionTimeout int32) ApiDialTexmlConferenceParticipantRequest {
	r.machineDetectionTimeout = &machineDetectionTimeout
	return r
}

// Maximum threshold of a human greeting. If greeting longer than this value, considered machine. Ignored when &#x60;premium&#x60; detection is used.
func (r ApiDialTexmlConferenceParticipantRequest) MachineDetectionSpeechThreshold(machineDetectionSpeechThreshold int32) ApiDialTexmlConferenceParticipantRequest {
	r.machineDetectionSpeechThreshold = &machineDetectionSpeechThreshold
	return r
}

// Silence duration threshold after a greeting message or voice for it be considered human. Ignored when &#x60;premium&#x60; detection is used.
func (r ApiDialTexmlConferenceParticipantRequest) MachineDetectionSpeechEndThreshold(machineDetectionSpeechEndThreshold int32) ApiDialTexmlConferenceParticipantRequest {
	r.machineDetectionSpeechEndThreshold = &machineDetectionSpeechEndThreshold
	return r
}

// If initial silence duration is greater than this value, consider it a machine. Ignored when &#x60;premium&#x60; detection is used.
func (r ApiDialTexmlConferenceParticipantRequest) MachineDetectionSilenceTimeout(machineDetectionSilenceTimeout int32) ApiDialTexmlConferenceParticipantRequest {
	r.machineDetectionSilenceTimeout = &machineDetectionSilenceTimeout
	return r
}

// The URL the result of answering machine detection will be sent to.
func (r ApiDialTexmlConferenceParticipantRequest) AmdStatusCallback(amdStatusCallback string) ApiDialTexmlConferenceParticipantRequest {
	r.amdStatusCallback = &amdStatusCallback
	return r
}

// HTTP request type used for &#x60;AmdStatusCallback&#x60;. Defaults to &#x60;POST&#x60;.
func (r ApiDialTexmlConferenceParticipantRequest) AmdStatusCallbackMethod(amdStatusCallbackMethod string) ApiDialTexmlConferenceParticipantRequest {
	r.amdStatusCallbackMethod = &amdStatusCallbackMethod
	return r
}

// Whether to cancel ongoing playback on &#x60;machine&#x60; detection. Defaults to &#x60;true&#x60;.
func (r ApiDialTexmlConferenceParticipantRequest) CancelPlaybackOnMachineDetection(cancelPlaybackOnMachineDetection bool) ApiDialTexmlConferenceParticipantRequest {
	r.cancelPlaybackOnMachineDetection = &cancelPlaybackOnMachineDetection
	return r
}

// Whether to cancel ongoing playback on &#x60;greeting ended&#x60; detection. Defaults to &#x60;true&#x60;.
func (r ApiDialTexmlConferenceParticipantRequest) CancelPlaybackOnDetectMessageEnd(cancelPlaybackOnDetectMessageEnd bool) ApiDialTexmlConferenceParticipantRequest {
	r.cancelPlaybackOnDetectMessageEnd = &cancelPlaybackOnDetectMessageEnd
	return r
}

// The list of comma-separated codecs to be offered on a call.
func (r ApiDialTexmlConferenceParticipantRequest) PreferredCodecs(preferredCodecs string) ApiDialTexmlConferenceParticipantRequest {
	r.preferredCodecs = &preferredCodecs
	return r
}

// Whether to record the entire participant&#39;s call leg. Defaults to &#x60;false&#x60;.
func (r ApiDialTexmlConferenceParticipantRequest) Record(record bool) ApiDialTexmlConferenceParticipantRequest {
	r.record = &record
	return r
}

// The number of channels in the final recording. Defaults to &#x60;mono&#x60;.
func (r ApiDialTexmlConferenceParticipantRequest) RecordingChannels(recordingChannels string) ApiDialTexmlConferenceParticipantRequest {
	r.recordingChannels = &recordingChannels
	return r
}

// The URL the recording callbacks will be sent to.
func (r ApiDialTexmlConferenceParticipantRequest) RecordingStatusCallback(recordingStatusCallback string) ApiDialTexmlConferenceParticipantRequest {
	r.recordingStatusCallback = &recordingStatusCallback
	return r
}

// HTTP request type used for &#x60;RecordingStatusCallback&#x60;. Defaults to &#x60;POST&#x60;.
func (r ApiDialTexmlConferenceParticipantRequest) RecordingStatusCallbackMethod(recordingStatusCallbackMethod string) ApiDialTexmlConferenceParticipantRequest {
	r.recordingStatusCallbackMethod = &recordingStatusCallbackMethod
	return r
}

// The changes to the recording&#39;s state that should generate a call to &#x60;RecoridngStatusCallback&#x60;. Can be: &#x60;in-progress&#x60;, &#x60;completed&#x60; and &#x60;absent&#x60;. Separate multiple values with a space. Defaults to &#x60;completed&#x60;.
func (r ApiDialTexmlConferenceParticipantRequest) RecordingStatusCallbackEvent(recordingStatusCallbackEvent string) ApiDialTexmlConferenceParticipantRequest {
	r.recordingStatusCallbackEvent = &recordingStatusCallbackEvent
	return r
}

// The audio track to record for the call. The default is &#x60;both&#x60;.
func (r ApiDialTexmlConferenceParticipantRequest) RecordingTrack(recordingTrack string) ApiDialTexmlConferenceParticipantRequest {
	r.recordingTrack = &recordingTrack
	return r
}

// The password to use for SIP authentication.
func (r ApiDialTexmlConferenceParticipantRequest) SipAuthPassword(sipAuthPassword string) ApiDialTexmlConferenceParticipantRequest {
	r.sipAuthPassword = &sipAuthPassword
	return r
}

// The username to use for SIP authentication.
func (r ApiDialTexmlConferenceParticipantRequest) SipAuthUsername(sipAuthUsername string) ApiDialTexmlConferenceParticipantRequest {
	r.sipAuthUsername = &sipAuthUsername
	return r
}

// Whether to trim any leading and trailing silence from the recording. Defaults to &#x60;trim-silence&#x60;.
func (r ApiDialTexmlConferenceParticipantRequest) Trim(trim string) ApiDialTexmlConferenceParticipantRequest {
	r.trim = &trim
	return r
}

// Whether to record the conference the participant is joining. Defualts to &#x60;do-not-record&#x60;. The boolean values &#x60;true&#x60; and &#x60;false&#x60; are synonymous with &#x60;record-from-start&#x60; and &#x60;do-not-record&#x60; respectively.
func (r ApiDialTexmlConferenceParticipantRequest) ConferenceRecord(conferenceRecord string) ApiDialTexmlConferenceParticipantRequest {
	r.conferenceRecord = &conferenceRecord
	return r
}

// The URL the conference recording callbacks will be sent to.
func (r ApiDialTexmlConferenceParticipantRequest) ConferenceRecordingStatusCallback(conferenceRecordingStatusCallback string) ApiDialTexmlConferenceParticipantRequest {
	r.conferenceRecordingStatusCallback = &conferenceRecordingStatusCallback
	return r
}

// HTTP request type used for &#x60;ConferenceRecordingStatusCallback&#x60;. Defaults to &#x60;POST&#x60;.
func (r ApiDialTexmlConferenceParticipantRequest) ConferenceRecordingStatusCallbackMethod(conferenceRecordingStatusCallbackMethod string) ApiDialTexmlConferenceParticipantRequest {
	r.conferenceRecordingStatusCallbackMethod = &conferenceRecordingStatusCallbackMethod
	return r
}

// The changes to the conference recording&#39;s state that should generate a call to &#x60;RecoridngStatusCallback&#x60;. Can be: &#x60;in-progress&#x60;, &#x60;completed&#x60; and &#x60;absent&#x60;. Separate multiple values with a space. Defaults to &#x60;completed&#x60;. &#x60;failed&#x60; and &#x60;absent&#x60; are synonymous.
func (r ApiDialTexmlConferenceParticipantRequest) ConferenceRecordingStatusCallbackEvent(conferenceRecordingStatusCallbackEvent string) ApiDialTexmlConferenceParticipantRequest {
	r.conferenceRecordingStatusCallbackEvent = &conferenceRecordingStatusCallbackEvent
	return r
}

// The number of seconds that Telnyx will wait for the recording to be stopped if silence is detected. The timer only starts when the speech is detected. Please note that the transcription is used to detect silence and the related charge will be applied. The minimum value is 0. The default value is 0 (infinite)
func (r ApiDialTexmlConferenceParticipantRequest) ConferenceRecordingTimeout(conferenceRecordingTimeout int32) ApiDialTexmlConferenceParticipantRequest {
	r.conferenceRecordingTimeout = &conferenceRecordingTimeout
	return r
}

// Whether to trim any leading and trailing silence from the conference recording. Defaults to &#x60;trim-silence&#x60;.
func (r ApiDialTexmlConferenceParticipantRequest) ConferenceTrim(conferenceTrim string) ApiDialTexmlConferenceParticipantRequest {
	r.conferenceTrim = &conferenceTrim
	return r
}

func (r ApiDialTexmlConferenceParticipantRequest) Execute() (*NewParticipantResource, *http.Response, error) {
	return r.ApiService.DialTexmlConferenceParticipantExecute(r)
}

/*
DialTexmlConferenceParticipant Dial a new conference participant

Dials a new conference participant

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The id of the account the resource belongs to.
 @param conferenceSid The ConferenceSid that uniquely identifies a conference.
 @return ApiDialTexmlConferenceParticipantRequest
*/
func (a *TeXMLRESTCommandsAPIService) DialTexmlConferenceParticipant(ctx context.Context, accountSid string, conferenceSid string) ApiDialTexmlConferenceParticipantRequest {
	return ApiDialTexmlConferenceParticipantRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		conferenceSid: conferenceSid,
	}
}

// Execute executes the request
//  @return NewParticipantResource
func (a *TeXMLRESTCommandsAPIService) DialTexmlConferenceParticipantExecute(r ApiDialTexmlConferenceParticipantRequest) (*NewParticipantResource, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NewParticipantResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeXMLRESTCommandsAPIService.DialTexmlConferenceParticipant")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/texml/Accounts/{account_sid}/Conferences/{conference_sid}/Participants"
	localVarPath = strings.Replace(localVarPath, "{"+"account_sid"+"}", url.PathEscape(parameterValueToString(r.accountSid, "accountSid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conference_sid"+"}", url.PathEscape(parameterValueToString(r.conferenceSid, "conferenceSid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.beep != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "Beep", r.beep, "", "")
	}
	if r.statusCallback != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "StatusCallback", r.statusCallback, "", "")
	}
	if r.statusCallbackMethod != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "StatusCallbackMethod", r.statusCallbackMethod, "", "")
	}
	if r.statusCallbackEvent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "StatusCallbackEvent", r.statusCallbackEvent, "", "")
	}
	if r.to != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "To", r.to, "", "")
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "From", r.from, "", "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "Timeout", r.timeout, "", "")
	}
	if r.muted != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "Muted", r.muted, "", "")
	}
	if r.startConferenceOnEnter != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "StartConferenceOnEnter", r.startConferenceOnEnter, "", "")
	}
	if r.endConferenceOnExit != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "EndConferenceOnExit", r.endConferenceOnExit, "", "")
	}
	if r.earlyMedia != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "EarlyMedia", r.earlyMedia, "", "")
	}
	if r.conferenceStatusCallback != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "ConferenceStatusCallback", r.conferenceStatusCallback, "", "")
	}
	if r.conferenceStatusCallbackMethod != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "ConferenceStatusCallbackMethod", r.conferenceStatusCallbackMethod, "", "")
	}
	if r.conferenceStatusCallbackEvent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "ConferenceStatusCallbackEvent", r.conferenceStatusCallbackEvent, "", "")
	}
	if r.waitUrl != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "WaitUrl", r.waitUrl, "", "")
	}
	if r.maxParticipants != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "MaxParticipants", r.maxParticipants, "", "")
	}
	if r.coaching != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "Coaching", r.coaching, "", "")
	}
	if r.callSidToCoach != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "CallSidToCoach", r.callSidToCoach, "", "")
	}
	if r.callerId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "CallerId", r.callerId, "", "")
	}
	if r.timeLimit != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "TimeLimit", r.timeLimit, "", "")
	}
	if r.machineDetection != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "MachineDetection", r.machineDetection, "", "")
	}
	if r.machineDetectionTimeout != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "MachineDetectionTimeout", r.machineDetectionTimeout, "", "")
	}
	if r.machineDetectionSpeechThreshold != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "MachineDetectionSpeechThreshold", r.machineDetectionSpeechThreshold, "", "")
	}
	if r.machineDetectionSpeechEndThreshold != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "MachineDetectionSpeechEndThreshold", r.machineDetectionSpeechEndThreshold, "", "")
	}
	if r.machineDetectionSilenceTimeout != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "MachineDetectionSilenceTimeout", r.machineDetectionSilenceTimeout, "", "")
	}
	if r.amdStatusCallback != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "AmdStatusCallback", r.amdStatusCallback, "", "")
	}
	if r.amdStatusCallbackMethod != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "AmdStatusCallbackMethod", r.amdStatusCallbackMethod, "", "")
	}
	if r.cancelPlaybackOnMachineDetection != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "CancelPlaybackOnMachineDetection", r.cancelPlaybackOnMachineDetection, "", "")
	}
	if r.cancelPlaybackOnDetectMessageEnd != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "CancelPlaybackOnDetectMessageEnd", r.cancelPlaybackOnDetectMessageEnd, "", "")
	}
	if r.preferredCodecs != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "PreferredCodecs", r.preferredCodecs, "", "")
	}
	if r.record != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "Record", r.record, "", "")
	}
	if r.recordingChannels != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "RecordingChannels", r.recordingChannels, "", "")
	}
	if r.recordingStatusCallback != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "RecordingStatusCallback", r.recordingStatusCallback, "", "")
	}
	if r.recordingStatusCallbackMethod != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "RecordingStatusCallbackMethod", r.recordingStatusCallbackMethod, "", "")
	}
	if r.recordingStatusCallbackEvent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "RecordingStatusCallbackEvent", r.recordingStatusCallbackEvent, "", "")
	}
	if r.recordingTrack != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "RecordingTrack", r.recordingTrack, "", "")
	}
	if r.sipAuthPassword != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "SipAuthPassword", r.sipAuthPassword, "", "")
	}
	if r.sipAuthUsername != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "SipAuthUsername", r.sipAuthUsername, "", "")
	}
	if r.trim != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "Trim", r.trim, "", "")
	}
	if r.conferenceRecord != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "ConferenceRecord", r.conferenceRecord, "", "")
	}
	if r.conferenceRecordingStatusCallback != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "ConferenceRecordingStatusCallback", r.conferenceRecordingStatusCallback, "", "")
	}
	if r.conferenceRecordingStatusCallbackMethod != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "ConferenceRecordingStatusCallbackMethod", r.conferenceRecordingStatusCallbackMethod, "", "")
	}
	if r.conferenceRecordingStatusCallbackEvent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "ConferenceRecordingStatusCallbackEvent", r.conferenceRecordingStatusCallbackEvent, "", "")
	}
	if r.conferenceRecordingTimeout != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "ConferenceRecordingTimeout", r.conferenceRecordingTimeout, "", "")
	}
	if r.conferenceTrim != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "ConferenceTrim", r.conferenceTrim, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchTeXMLCallRecordingsRequest struct {
	ctx context.Context
	ApiService *TeXMLRESTCommandsAPIService
	accountSid string
	callSid string
}

func (r ApiFetchTeXMLCallRecordingsRequest) Execute() (*TexmlGetCallRecordingsResponseBody, *http.Response, error) {
	return r.ApiService.FetchTeXMLCallRecordingsExecute(r)
}

/*
FetchTeXMLCallRecordings Fetch recordings for a call

Returns recordings for a call identified by call_sid.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The id of the account the resource belongs to.
 @param callSid The CallSid that identifies the call to update.
 @return ApiFetchTeXMLCallRecordingsRequest
*/
func (a *TeXMLRESTCommandsAPIService) FetchTeXMLCallRecordings(ctx context.Context, accountSid string, callSid string) ApiFetchTeXMLCallRecordingsRequest {
	return ApiFetchTeXMLCallRecordingsRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		callSid: callSid,
	}
}

// Execute executes the request
//  @return TexmlGetCallRecordingsResponseBody
func (a *TeXMLRESTCommandsAPIService) FetchTeXMLCallRecordingsExecute(r ApiFetchTeXMLCallRecordingsRequest) (*TexmlGetCallRecordingsResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TexmlGetCallRecordingsResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeXMLRESTCommandsAPIService.FetchTeXMLCallRecordings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/texml/Accounts/{account_sid}/Calls/{call_sid}/Recordings.json"
	localVarPath = strings.Replace(localVarPath, "{"+"account_sid"+"}", url.PathEscape(parameterValueToString(r.accountSid, "accountSid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_sid"+"}", url.PathEscape(parameterValueToString(r.callSid, "callSid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchTeXMLConferenceRecordingsRequest struct {
	ctx context.Context
	ApiService *TeXMLRESTCommandsAPIService
	accountSid string
	conferenceSid string
}

func (r ApiFetchTeXMLConferenceRecordingsRequest) Execute() (*TexmlGetCallRecordingsResponseBody, *http.Response, error) {
	return r.ApiService.FetchTeXMLConferenceRecordingsExecute(r)
}

/*
FetchTeXMLConferenceRecordings Fetch recordings for a conference

Returns recordings for a conference identified by conference_sid.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The id of the account the resource belongs to.
 @param conferenceSid The ConferenceSid that uniquely identifies a conference.
 @return ApiFetchTeXMLConferenceRecordingsRequest
*/
func (a *TeXMLRESTCommandsAPIService) FetchTeXMLConferenceRecordings(ctx context.Context, accountSid string, conferenceSid string) ApiFetchTeXMLConferenceRecordingsRequest {
	return ApiFetchTeXMLConferenceRecordingsRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		conferenceSid: conferenceSid,
	}
}

// Execute executes the request
//  @return TexmlGetCallRecordingsResponseBody
func (a *TeXMLRESTCommandsAPIService) FetchTeXMLConferenceRecordingsExecute(r ApiFetchTeXMLConferenceRecordingsRequest) (*TexmlGetCallRecordingsResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TexmlGetCallRecordingsResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeXMLRESTCommandsAPIService.FetchTeXMLConferenceRecordings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/texml/Accounts/{account_sid}/Conferences/{conference_sid}/Recordings.json"
	localVarPath = strings.Replace(localVarPath, "{"+"account_sid"+"}", url.PathEscape(parameterValueToString(r.accountSid, "accountSid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conference_sid"+"}", url.PathEscape(parameterValueToString(r.conferenceSid, "conferenceSid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTeXMLCallRecordingRequest struct {
	ctx context.Context
	ApiService *TeXMLRESTCommandsAPIService
	accountSid string
	recordingSid string
}

func (r ApiGetTeXMLCallRecordingRequest) Execute() (*TexmlGetCallRecordingResponseBody, *http.Response, error) {
	return r.ApiService.GetTeXMLCallRecordingExecute(r)
}

/*
GetTeXMLCallRecording Fetch recording resource

Returns recording resource identified by recording id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The id of the account the resource belongs to.
 @param recordingSid Uniquely identifies the recording by id.
 @return ApiGetTeXMLCallRecordingRequest
*/
func (a *TeXMLRESTCommandsAPIService) GetTeXMLCallRecording(ctx context.Context, accountSid string, recordingSid string) ApiGetTeXMLCallRecordingRequest {
	return ApiGetTeXMLCallRecordingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		recordingSid: recordingSid,
	}
}

// Execute executes the request
//  @return TexmlGetCallRecordingResponseBody
func (a *TeXMLRESTCommandsAPIService) GetTeXMLCallRecordingExecute(r ApiGetTeXMLCallRecordingRequest) (*TexmlGetCallRecordingResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TexmlGetCallRecordingResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeXMLRESTCommandsAPIService.GetTeXMLCallRecording")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/texml/Accounts/{account_sid}/Recordings/{recording_sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"account_sid"+"}", url.PathEscape(parameterValueToString(r.accountSid, "accountSid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"recording_sid"+"}", url.PathEscape(parameterValueToString(r.recordingSid, "recordingSid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTeXMLCallRecordingsRequest struct {
	ctx context.Context
	ApiService *TeXMLRESTCommandsAPIService
	accountSid string
	page *int32
	pageSize *int32
	dateCreated *string
}

// The number of the page to be displayed, zero-indexed, should be used in conjuction with PageToken.
func (r ApiGetTeXMLCallRecordingsRequest) Page(page int32) ApiGetTeXMLCallRecordingsRequest {
	r.page = &page
	return r
}

// The number of records to be displayed on a page
func (r ApiGetTeXMLCallRecordingsRequest) PageSize(pageSize int32) ApiGetTeXMLCallRecordingsRequest {
	r.pageSize = &pageSize
	return r
}

// Filters recording by the creation date. Expected format is ISO8601 date or date-time, ie. {YYYY}-{MM}-{DD} or {YYYY}-{MM}-{DD}T{hh}:{mm}:{ss}Z. Also accepts inequality operators, e.g. DateCreated&gt;&#x3D;2023-05-22.
func (r ApiGetTeXMLCallRecordingsRequest) DateCreated(dateCreated string) ApiGetTeXMLCallRecordingsRequest {
	r.dateCreated = &dateCreated
	return r
}

func (r ApiGetTeXMLCallRecordingsRequest) Execute() (*TexmlGetCallRecordingsResponseBody, *http.Response, error) {
	return r.ApiService.GetTeXMLCallRecordingsExecute(r)
}

/*
GetTeXMLCallRecordings Fetch multiple recording resources

Returns multiple recording resources for an account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The id of the account the resource belongs to.
 @return ApiGetTeXMLCallRecordingsRequest
*/
func (a *TeXMLRESTCommandsAPIService) GetTeXMLCallRecordings(ctx context.Context, accountSid string) ApiGetTeXMLCallRecordingsRequest {
	return ApiGetTeXMLCallRecordingsRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return TexmlGetCallRecordingsResponseBody
func (a *TeXMLRESTCommandsAPIService) GetTeXMLCallRecordingsExecute(r ApiGetTeXMLCallRecordingsRequest) (*TexmlGetCallRecordingsResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TexmlGetCallRecordingsResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeXMLRESTCommandsAPIService.GetTeXMLCallRecordings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/texml/Accounts/{account_sid}/Recordings.json"
	localVarPath = strings.Replace(localVarPath, "{"+"account_sid"+"}", url.PathEscape(parameterValueToString(r.accountSid, "accountSid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PageSize", r.pageSize, "form", "")
	}
	if r.dateCreated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "DateCreated", r.dateCreated, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTeXMLRecordingTranscriptionRequest struct {
	ctx context.Context
	ApiService *TeXMLRESTCommandsAPIService
	accountSid string
	recordingTranscriptionSid string
}

func (r ApiGetTeXMLRecordingTranscriptionRequest) Execute() (*TexmlRecordingTranscription, *http.Response, error) {
	return r.ApiService.GetTeXMLRecordingTranscriptionExecute(r)
}

/*
GetTeXMLRecordingTranscription Fetch a recording transcription resource

Returns the recording transcription resource identified by its ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The id of the account the resource belongs to.
 @param recordingTranscriptionSid Uniquely identifies the recording transcription by id.
 @return ApiGetTeXMLRecordingTranscriptionRequest
*/
func (a *TeXMLRESTCommandsAPIService) GetTeXMLRecordingTranscription(ctx context.Context, accountSid string, recordingTranscriptionSid string) ApiGetTeXMLRecordingTranscriptionRequest {
	return ApiGetTeXMLRecordingTranscriptionRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		recordingTranscriptionSid: recordingTranscriptionSid,
	}
}

// Execute executes the request
//  @return TexmlRecordingTranscription
func (a *TeXMLRESTCommandsAPIService) GetTeXMLRecordingTranscriptionExecute(r ApiGetTeXMLRecordingTranscriptionRequest) (*TexmlRecordingTranscription, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TexmlRecordingTranscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeXMLRESTCommandsAPIService.GetTeXMLRecordingTranscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/texml/Accounts/{account_sid}/Transcriptions/{recording_transcription_sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"account_sid"+"}", url.PathEscape(parameterValueToString(r.accountSid, "accountSid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"recording_transcription_sid"+"}", url.PathEscape(parameterValueToString(r.recordingTranscriptionSid, "recordingTranscriptionSid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTeXMLRecordingTranscriptionsRequest struct {
	ctx context.Context
	ApiService *TeXMLRESTCommandsAPIService
	accountSid string
	pageToken *string
	pageSize *int32
}

// Used to request the next page of results.
func (r ApiGetTeXMLRecordingTranscriptionsRequest) PageToken(pageToken string) ApiGetTeXMLRecordingTranscriptionsRequest {
	r.pageToken = &pageToken
	return r
}

// The size of the page.
func (r ApiGetTeXMLRecordingTranscriptionsRequest) PageSize(pageSize int32) ApiGetTeXMLRecordingTranscriptionsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetTeXMLRecordingTranscriptionsRequest) Execute() (*ListRecordingTranscriptionsResponse, *http.Response, error) {
	return r.ApiService.GetTeXMLRecordingTranscriptionsExecute(r)
}

/*
GetTeXMLRecordingTranscriptions List recording transcriptions

Returns multiple recording transcription resources for an account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The id of the account the resource belongs to.
 @return ApiGetTeXMLRecordingTranscriptionsRequest
*/
func (a *TeXMLRESTCommandsAPIService) GetTeXMLRecordingTranscriptions(ctx context.Context, accountSid string) ApiGetTeXMLRecordingTranscriptionsRequest {
	return ApiGetTeXMLRecordingTranscriptionsRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ListRecordingTranscriptionsResponse
func (a *TeXMLRESTCommandsAPIService) GetTeXMLRecordingTranscriptionsExecute(r ApiGetTeXMLRecordingTranscriptionsRequest) (*ListRecordingTranscriptionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListRecordingTranscriptionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeXMLRESTCommandsAPIService.GetTeXMLRecordingTranscriptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/texml/Accounts/{account_sid}/Transcriptions.json"
	localVarPath = strings.Replace(localVarPath, "{"+"account_sid"+"}", url.PathEscape(parameterValueToString(r.accountSid, "accountSid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PageToken", r.pageToken, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTexmlCallRequest struct {
	ctx context.Context
	ApiService *TeXMLRESTCommandsAPIService
	callSid string
	accountSid string
}

func (r ApiGetTexmlCallRequest) Execute() (*CallResource, *http.Response, error) {
	return r.ApiService.GetTexmlCallExecute(r)
}

/*
GetTexmlCall Fetch a call

Returns an individual call identified by its CallSid. This endpoint is eventually consistent.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callSid The CallSid that identifies the call to update.
 @param accountSid The id of the account the resource belongs to.
 @return ApiGetTexmlCallRequest
*/
func (a *TeXMLRESTCommandsAPIService) GetTexmlCall(ctx context.Context, callSid string, accountSid string) ApiGetTexmlCallRequest {
	return ApiGetTexmlCallRequest{
		ApiService: a,
		ctx: ctx,
		callSid: callSid,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return CallResource
func (a *TeXMLRESTCommandsAPIService) GetTexmlCallExecute(r ApiGetTexmlCallRequest) (*CallResource, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeXMLRESTCommandsAPIService.GetTexmlCall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/texml/Accounts/{account_sid}/Calls/{call_sid}"
	localVarPath = strings.Replace(localVarPath, "{"+"call_sid"+"}", url.PathEscape(parameterValueToString(r.callSid, "callSid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"account_sid"+"}", url.PathEscape(parameterValueToString(r.accountSid, "accountSid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTexmlCallsRequest struct {
	ctx context.Context
	ApiService *TeXMLRESTCommandsAPIService
	accountSid string
	page *int32
	pageSize *int32
	pageToken *string
	to *string
	from *string
	status *string
	startTime *string
	startTimeGt *string
	startTimeLt *string
	endTime *string
	endTimeGt *string
	endTimeLt *string
}

// The number of the page to be displayed, zero-indexed, should be used in conjuction with PageToken.
func (r ApiGetTexmlCallsRequest) Page(page int32) ApiGetTexmlCallsRequest {
	r.page = &page
	return r
}

// The size of the page.
func (r ApiGetTexmlCallsRequest) PageSize(pageSize int32) ApiGetTexmlCallsRequest {
	r.pageSize = &pageSize
	return r
}

// Used to request the next page of results.
func (r ApiGetTexmlCallsRequest) PageToken(pageToken string) ApiGetTexmlCallsRequest {
	r.pageToken = &pageToken
	return r
}

// Filters calls by the to number.
func (r ApiGetTexmlCallsRequest) To(to string) ApiGetTexmlCallsRequest {
	r.to = &to
	return r
}

// Filters calls by the from number.
func (r ApiGetTexmlCallsRequest) From(from string) ApiGetTexmlCallsRequest {
	r.from = &from
	return r
}

// Filters calls by status.
func (r ApiGetTexmlCallsRequest) Status(status string) ApiGetTexmlCallsRequest {
	r.status = &status
	return r
}

// Filters calls by their start date. Expected format is YYYY-MM-DD.
func (r ApiGetTexmlCallsRequest) StartTime(startTime string) ApiGetTexmlCallsRequest {
	r.startTime = &startTime
	return r
}

// Filters calls by their start date (after). Expected format is YYYY-MM-DD
func (r ApiGetTexmlCallsRequest) StartTimeGt(startTimeGt string) ApiGetTexmlCallsRequest {
	r.startTimeGt = &startTimeGt
	return r
}

// Filters calls by their start date (before). Expected format is YYYY-MM-DD
func (r ApiGetTexmlCallsRequest) StartTimeLt(startTimeLt string) ApiGetTexmlCallsRequest {
	r.startTimeLt = &startTimeLt
	return r
}

// Filters calls by their end date. Expected format is YYYY-MM-DD
func (r ApiGetTexmlCallsRequest) EndTime(endTime string) ApiGetTexmlCallsRequest {
	r.endTime = &endTime
	return r
}

// Filters calls by their end date (after). Expected format is YYYY-MM-DD
func (r ApiGetTexmlCallsRequest) EndTimeGt(endTimeGt string) ApiGetTexmlCallsRequest {
	r.endTimeGt = &endTimeGt
	return r
}

// Filters calls by their end date (before). Expected format is YYYY-MM-DD
func (r ApiGetTexmlCallsRequest) EndTimeLt(endTimeLt string) ApiGetTexmlCallsRequest {
	r.endTimeLt = &endTimeLt
	return r
}

func (r ApiGetTexmlCallsRequest) Execute() (*CallResourceIndex, *http.Response, error) {
	return r.ApiService.GetTexmlCallsExecute(r)
}

/*
GetTexmlCalls Fetch multiple call resources

Returns multiple call resouces for an account. This endpoint is eventually consistent.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The id of the account the resource belongs to.
 @return ApiGetTexmlCallsRequest
*/
func (a *TeXMLRESTCommandsAPIService) GetTexmlCalls(ctx context.Context, accountSid string) ApiGetTexmlCallsRequest {
	return ApiGetTexmlCallsRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return CallResourceIndex
func (a *TeXMLRESTCommandsAPIService) GetTexmlCallsExecute(r ApiGetTexmlCallsRequest) (*CallResourceIndex, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallResourceIndex
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeXMLRESTCommandsAPIService.GetTexmlCalls")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/texml/Accounts/{account_sid}/Calls"
	localVarPath = strings.Replace(localVarPath, "{"+"account_sid"+"}", url.PathEscape(parameterValueToString(r.accountSid, "accountSid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.pageToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PageToken", r.pageToken, "form", "")
	}
	if r.to != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "To", r.to, "form", "")
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "From", r.from, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Status", r.status, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartTime", r.startTime, "form", "")
	}
	if r.startTimeGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartTime_gt", r.startTimeGt, "form", "")
	}
	if r.startTimeLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "StartTime_lt", r.startTimeLt, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EndTime", r.endTime, "form", "")
	}
	if r.endTimeGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EndTime_gt", r.endTimeGt, "form", "")
	}
	if r.endTimeLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "EndTime_lt", r.endTimeLt, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTexmlConferenceRequest struct {
	ctx context.Context
	ApiService *TeXMLRESTCommandsAPIService
	accountSid string
	conferenceSid string
}

func (r ApiGetTexmlConferenceRequest) Execute() (*ConferenceResource, *http.Response, error) {
	return r.ApiService.GetTexmlConferenceExecute(r)
}

/*
GetTexmlConference Fetch a conference resource

Returns a conference resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The id of the account the resource belongs to.
 @param conferenceSid The ConferenceSid that uniquely identifies a conference.
 @return ApiGetTexmlConferenceRequest
*/
func (a *TeXMLRESTCommandsAPIService) GetTexmlConference(ctx context.Context, accountSid string, conferenceSid string) ApiGetTexmlConferenceRequest {
	return ApiGetTexmlConferenceRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		conferenceSid: conferenceSid,
	}
}

// Execute executes the request
//  @return ConferenceResource
func (a *TeXMLRESTCommandsAPIService) GetTexmlConferenceExecute(r ApiGetTexmlConferenceRequest) (*ConferenceResource, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConferenceResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeXMLRESTCommandsAPIService.GetTexmlConference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/texml/Accounts/{account_sid}/Conferences/{conference_sid}"
	localVarPath = strings.Replace(localVarPath, "{"+"account_sid"+"}", url.PathEscape(parameterValueToString(r.accountSid, "accountSid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conference_sid"+"}", url.PathEscape(parameterValueToString(r.conferenceSid, "conferenceSid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTexmlConferenceParticipantRequest struct {
	ctx context.Context
	ApiService *TeXMLRESTCommandsAPIService
	accountSid string
	conferenceSid string
	callSid string
}

func (r ApiGetTexmlConferenceParticipantRequest) Execute() (*ParticipantResource, *http.Response, error) {
	return r.ApiService.GetTexmlConferenceParticipantExecute(r)
}

/*
GetTexmlConferenceParticipant Get conference participant resource

Gets conference participant resource

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The id of the account the resource belongs to.
 @param conferenceSid The ConferenceSid that uniquely identifies a conference.
 @param callSid The CallSid that identifies the call to update.
 @return ApiGetTexmlConferenceParticipantRequest
*/
func (a *TeXMLRESTCommandsAPIService) GetTexmlConferenceParticipant(ctx context.Context, accountSid string, conferenceSid string, callSid string) ApiGetTexmlConferenceParticipantRequest {
	return ApiGetTexmlConferenceParticipantRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		conferenceSid: conferenceSid,
		callSid: callSid,
	}
}

// Execute executes the request
//  @return ParticipantResource
func (a *TeXMLRESTCommandsAPIService) GetTexmlConferenceParticipantExecute(r ApiGetTexmlConferenceParticipantRequest) (*ParticipantResource, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ParticipantResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeXMLRESTCommandsAPIService.GetTexmlConferenceParticipant")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/texml/Accounts/{account_sid}/Conferences/{conference_sid}/Participants/{call_sid}"
	localVarPath = strings.Replace(localVarPath, "{"+"account_sid"+"}", url.PathEscape(parameterValueToString(r.accountSid, "accountSid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conference_sid"+"}", url.PathEscape(parameterValueToString(r.conferenceSid, "conferenceSid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_sid"+"}", url.PathEscape(parameterValueToString(r.callSid, "callSid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTexmlConferenceParticipantsRequest struct {
	ctx context.Context
	ApiService *TeXMLRESTCommandsAPIService
	accountSid string
	conferenceSid string
}

func (r ApiGetTexmlConferenceParticipantsRequest) Execute() (*ParticipantResourceIndex, *http.Response, error) {
	return r.ApiService.GetTexmlConferenceParticipantsExecute(r)
}

/*
GetTexmlConferenceParticipants List conference participants

Lists conference participants

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The id of the account the resource belongs to.
 @param conferenceSid The ConferenceSid that uniquely identifies a conference.
 @return ApiGetTexmlConferenceParticipantsRequest
*/
func (a *TeXMLRESTCommandsAPIService) GetTexmlConferenceParticipants(ctx context.Context, accountSid string, conferenceSid string) ApiGetTexmlConferenceParticipantsRequest {
	return ApiGetTexmlConferenceParticipantsRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		conferenceSid: conferenceSid,
	}
}

// Execute executes the request
//  @return ParticipantResourceIndex
func (a *TeXMLRESTCommandsAPIService) GetTexmlConferenceParticipantsExecute(r ApiGetTexmlConferenceParticipantsRequest) (*ParticipantResourceIndex, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ParticipantResourceIndex
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeXMLRESTCommandsAPIService.GetTexmlConferenceParticipants")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/texml/Accounts/{account_sid}/Conferences/{conference_sid}/Participants"
	localVarPath = strings.Replace(localVarPath, "{"+"account_sid"+"}", url.PathEscape(parameterValueToString(r.accountSid, "accountSid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conference_sid"+"}", url.PathEscape(parameterValueToString(r.conferenceSid, "conferenceSid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTexmlConferenceRecordingsRequest struct {
	ctx context.Context
	ApiService *TeXMLRESTCommandsAPIService
	accountSid string
	conferenceSid string
}

func (r ApiGetTexmlConferenceRecordingsRequest) Execute() (*ConferenceRecordingResourceIndex, *http.Response, error) {
	return r.ApiService.GetTexmlConferenceRecordingsExecute(r)
}

/*
GetTexmlConferenceRecordings List conference recordings

Lists conference recordings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The id of the account the resource belongs to.
 @param conferenceSid The ConferenceSid that uniquely identifies a conference.
 @return ApiGetTexmlConferenceRecordingsRequest
*/
func (a *TeXMLRESTCommandsAPIService) GetTexmlConferenceRecordings(ctx context.Context, accountSid string, conferenceSid string) ApiGetTexmlConferenceRecordingsRequest {
	return ApiGetTexmlConferenceRecordingsRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		conferenceSid: conferenceSid,
	}
}

// Execute executes the request
//  @return ConferenceRecordingResourceIndex
func (a *TeXMLRESTCommandsAPIService) GetTexmlConferenceRecordingsExecute(r ApiGetTexmlConferenceRecordingsRequest) (*ConferenceRecordingResourceIndex, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConferenceRecordingResourceIndex
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeXMLRESTCommandsAPIService.GetTexmlConferenceRecordings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/texml/Accounts/{account_sid}/Conferences/{conference_sid}/Recordings"
	localVarPath = strings.Replace(localVarPath, "{"+"account_sid"+"}", url.PathEscape(parameterValueToString(r.accountSid, "accountSid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conference_sid"+"}", url.PathEscape(parameterValueToString(r.conferenceSid, "conferenceSid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTexmlConferencesRequest struct {
	ctx context.Context
	ApiService *TeXMLRESTCommandsAPIService
	accountSid string
	page *int32
	pageSize *int32
	pageToken *string
	friendlyName *string
	status *string
	dateCreated *string
	dateUpdated *string
}

// The number of the page to be displayed, zero-indexed, should be used in conjuction with PageToken.
func (r ApiGetTexmlConferencesRequest) Page(page int32) ApiGetTexmlConferencesRequest {
	r.page = &page
	return r
}

// The size of the page.
func (r ApiGetTexmlConferencesRequest) PageSize(pageSize int32) ApiGetTexmlConferencesRequest {
	r.pageSize = &pageSize
	return r
}

// Used to request the next page of results.
func (r ApiGetTexmlConferencesRequest) PageToken(pageToken string) ApiGetTexmlConferencesRequest {
	r.pageToken = &pageToken
	return r
}

// Filters conferences by their friendly name.
func (r ApiGetTexmlConferencesRequest) FriendlyName(friendlyName string) ApiGetTexmlConferencesRequest {
	r.friendlyName = &friendlyName
	return r
}

// Filters conferences by status.
func (r ApiGetTexmlConferencesRequest) Status(status string) ApiGetTexmlConferencesRequest {
	r.status = &status
	return r
}

// Filters conferences by the creation date. Expected format is YYYY-MM-DD. Also accepts inequality operators, e.g. DateCreated&gt;&#x3D;2023-05-22.
func (r ApiGetTexmlConferencesRequest) DateCreated(dateCreated string) ApiGetTexmlConferencesRequest {
	r.dateCreated = &dateCreated
	return r
}

// Filters conferences by the time they were last updated. Expected format is YYYY-MM-DD. Also accepts inequality operators, e.g. DateUpdated&gt;&#x3D;2023-05-22.
func (r ApiGetTexmlConferencesRequest) DateUpdated(dateUpdated string) ApiGetTexmlConferencesRequest {
	r.dateUpdated = &dateUpdated
	return r
}

func (r ApiGetTexmlConferencesRequest) Execute() (*ConferenceResourceIndex, *http.Response, error) {
	return r.ApiService.GetTexmlConferencesExecute(r)
}

/*
GetTexmlConferences List conference resources

Lists conference resources.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The id of the account the resource belongs to.
 @return ApiGetTexmlConferencesRequest
*/
func (a *TeXMLRESTCommandsAPIService) GetTexmlConferences(ctx context.Context, accountSid string) ApiGetTexmlConferencesRequest {
	return ApiGetTexmlConferencesRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ConferenceResourceIndex
func (a *TeXMLRESTCommandsAPIService) GetTexmlConferencesExecute(r ApiGetTexmlConferencesRequest) (*ConferenceResourceIndex, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConferenceResourceIndex
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeXMLRESTCommandsAPIService.GetTexmlConferences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/texml/Accounts/{account_sid}/Conferences"
	localVarPath = strings.Replace(localVarPath, "{"+"account_sid"+"}", url.PathEscape(parameterValueToString(r.accountSid, "accountSid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.pageToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PageToken", r.pageToken, "form", "")
	}
	if r.friendlyName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "FriendlyName", r.friendlyName, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Status", r.status, "form", "")
	}
	if r.dateCreated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "DateCreated", r.dateCreated, "form", "")
	}
	if r.dateUpdated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "DateUpdated", r.dateUpdated, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInitiateTexmlCallRequest struct {
	ctx context.Context
	ApiService *TeXMLRESTCommandsAPIService
	accountSid string
	initiateCallRequest *InitiateCallRequest
}

// Iniatiate Call request object
func (r ApiInitiateTexmlCallRequest) InitiateCallRequest(initiateCallRequest InitiateCallRequest) ApiInitiateTexmlCallRequest {
	r.initiateCallRequest = &initiateCallRequest
	return r
}

func (r ApiInitiateTexmlCallRequest) Execute() (*InitiateCallResult, *http.Response, error) {
	return r.ApiService.InitiateTexmlCallExecute(r)
}

/*
InitiateTexmlCall Initiate an outbound call

Initiate an outbound TeXML call. Telnyx will request TeXML from the XML Request URL configured for the connection in the Mission Control Portal.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The id of the account the resource belongs to.
 @return ApiInitiateTexmlCallRequest
*/
func (a *TeXMLRESTCommandsAPIService) InitiateTexmlCall(ctx context.Context, accountSid string) ApiInitiateTexmlCallRequest {
	return ApiInitiateTexmlCallRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return InitiateCallResult
func (a *TeXMLRESTCommandsAPIService) InitiateTexmlCallExecute(r ApiInitiateTexmlCallRequest) (*InitiateCallResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InitiateCallResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeXMLRESTCommandsAPIService.InitiateTexmlCall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/texml/Accounts/{account_sid}/Calls"
	localVarPath = strings.Replace(localVarPath, "{"+"account_sid"+"}", url.PathEscape(parameterValueToString(r.accountSid, "accountSid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.initiateCallRequest == nil {
		return localVarReturnValue, nil, reportError("initiateCallRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.initiateCallRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartTeXMLCallRecordingRequest struct {
	ctx context.Context
	ApiService *TeXMLRESTCommandsAPIService
	accountSid string
	callSid string
	playBeep *bool
	recordingStatusCallbackEvent *string
	recordingStatusCallback *string
	recordingStatusCallbackMethod *TexmlStatusCallbackMethod
	recordingChannels *TexmlRecordingChannels
	recordingTrack *RecordingTrack
}

// Whether to play a beep when recording is started.
func (r ApiStartTeXMLCallRecordingRequest) PlayBeep(playBeep bool) ApiStartTeXMLCallRecordingRequest {
	r.playBeep = &playBeep
	return r
}

// The changes to the recording&#39;s state that should generate a call to &#x60;RecoridngStatusCallback&#x60;. Can be: &#x60;in-progress&#x60;, &#x60;completed&#x60; and &#x60;absent&#x60;. Separate multiple values with a space. Defaults to &#x60;completed&#x60;.
func (r ApiStartTeXMLCallRecordingRequest) RecordingStatusCallbackEvent(recordingStatusCallbackEvent string) ApiStartTeXMLCallRecordingRequest {
	r.recordingStatusCallbackEvent = &recordingStatusCallbackEvent
	return r
}

// Url where status callbacks will be sent.
func (r ApiStartTeXMLCallRecordingRequest) RecordingStatusCallback(recordingStatusCallback string) ApiStartTeXMLCallRecordingRequest {
	r.recordingStatusCallback = &recordingStatusCallback
	return r
}

func (r ApiStartTeXMLCallRecordingRequest) RecordingStatusCallbackMethod(recordingStatusCallbackMethod TexmlStatusCallbackMethod) ApiStartTeXMLCallRecordingRequest {
	r.recordingStatusCallbackMethod = &recordingStatusCallbackMethod
	return r
}

func (r ApiStartTeXMLCallRecordingRequest) RecordingChannels(recordingChannels TexmlRecordingChannels) ApiStartTeXMLCallRecordingRequest {
	r.recordingChannels = &recordingChannels
	return r
}

func (r ApiStartTeXMLCallRecordingRequest) RecordingTrack(recordingTrack RecordingTrack) ApiStartTeXMLCallRecordingRequest {
	r.recordingTrack = &recordingTrack
	return r
}

func (r ApiStartTeXMLCallRecordingRequest) Execute() (*TexmlCreateCallRecordingResponseBody, *http.Response, error) {
	return r.ApiService.StartTeXMLCallRecordingExecute(r)
}

/*
StartTeXMLCallRecording Request recording for a call

Starts recording with specified parameters for call idientified by call_sid.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The id of the account the resource belongs to.
 @param callSid The CallSid that identifies the call to update.
 @return ApiStartTeXMLCallRecordingRequest
*/
func (a *TeXMLRESTCommandsAPIService) StartTeXMLCallRecording(ctx context.Context, accountSid string, callSid string) ApiStartTeXMLCallRecordingRequest {
	return ApiStartTeXMLCallRecordingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		callSid: callSid,
	}
}

// Execute executes the request
//  @return TexmlCreateCallRecordingResponseBody
func (a *TeXMLRESTCommandsAPIService) StartTeXMLCallRecordingExecute(r ApiStartTeXMLCallRecordingRequest) (*TexmlCreateCallRecordingResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TexmlCreateCallRecordingResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeXMLRESTCommandsAPIService.StartTeXMLCallRecording")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/texml/Accounts/{account_sid}/Calls/{call_sid}/Recordings.json"
	localVarPath = strings.Replace(localVarPath, "{"+"account_sid"+"}", url.PathEscape(parameterValueToString(r.accountSid, "accountSid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_sid"+"}", url.PathEscape(parameterValueToString(r.callSid, "callSid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.playBeep != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "PlayBeep", r.playBeep, "", "")
	}
	if r.recordingStatusCallbackEvent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "RecordingStatusCallbackEvent", r.recordingStatusCallbackEvent, "", "")
	}
	if r.recordingStatusCallback != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "RecordingStatusCallback", r.recordingStatusCallback, "", "")
	}
	if r.recordingStatusCallbackMethod != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "RecordingStatusCallbackMethod", r.recordingStatusCallbackMethod, "", "")
	}
	if r.recordingChannels != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "RecordingChannels", r.recordingChannels, "", "")
	}
	if r.recordingTrack != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "RecordingTrack", r.recordingTrack, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartTeXMLCallStreamingRequest struct {
	ctx context.Context
	ApiService *TeXMLRESTCommandsAPIService
	accountSid string
	callSid string
	statusCallback *string
	statusCallbackMethod *TexmlStatusCallbackMethod
	track *StreamTrack
	name *string
	bidirectionalMode *TexmlBidirectionalStreamMode
	bidirectionalCodec *TexmlBidirectionalStreamCodec
	url *string
}

// Url where status callbacks will be sent.
func (r ApiStartTeXMLCallStreamingRequest) StatusCallback(statusCallback string) ApiStartTeXMLCallStreamingRequest {
	r.statusCallback = &statusCallback
	return r
}

func (r ApiStartTeXMLCallStreamingRequest) StatusCallbackMethod(statusCallbackMethod TexmlStatusCallbackMethod) ApiStartTeXMLCallStreamingRequest {
	r.statusCallbackMethod = &statusCallbackMethod
	return r
}

func (r ApiStartTeXMLCallStreamingRequest) Track(track StreamTrack) ApiStartTeXMLCallStreamingRequest {
	r.track = &track
	return r
}

// The user specified name of Stream.
func (r ApiStartTeXMLCallStreamingRequest) Name(name string) ApiStartTeXMLCallStreamingRequest {
	r.name = &name
	return r
}

func (r ApiStartTeXMLCallStreamingRequest) BidirectionalMode(bidirectionalMode TexmlBidirectionalStreamMode) ApiStartTeXMLCallStreamingRequest {
	r.bidirectionalMode = &bidirectionalMode
	return r
}

func (r ApiStartTeXMLCallStreamingRequest) BidirectionalCodec(bidirectionalCodec TexmlBidirectionalStreamCodec) ApiStartTeXMLCallStreamingRequest {
	r.bidirectionalCodec = &bidirectionalCodec
	return r
}

// The destination WebSocket address where the stream is going to be delivered.
func (r ApiStartTeXMLCallStreamingRequest) Url(url string) ApiStartTeXMLCallStreamingRequest {
	r.url = &url
	return r
}

func (r ApiStartTeXMLCallStreamingRequest) Execute() (*TexmlCreateCallStreamingResponseBody, *http.Response, error) {
	return r.ApiService.StartTeXMLCallStreamingExecute(r)
}

/*
StartTeXMLCallStreaming Start streaming media from a call.

Starts streaming media from a call to a specific WebSocket address.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The id of the account the resource belongs to.
 @param callSid The CallSid that identifies the call to update.
 @return ApiStartTeXMLCallStreamingRequest
*/
func (a *TeXMLRESTCommandsAPIService) StartTeXMLCallStreaming(ctx context.Context, accountSid string, callSid string) ApiStartTeXMLCallStreamingRequest {
	return ApiStartTeXMLCallStreamingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		callSid: callSid,
	}
}

// Execute executes the request
//  @return TexmlCreateCallStreamingResponseBody
func (a *TeXMLRESTCommandsAPIService) StartTeXMLCallStreamingExecute(r ApiStartTeXMLCallStreamingRequest) (*TexmlCreateCallStreamingResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TexmlCreateCallStreamingResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeXMLRESTCommandsAPIService.StartTeXMLCallStreaming")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/texml/Accounts/{account_sid}/Calls/{call_sid}/Streams.json"
	localVarPath = strings.Replace(localVarPath, "{"+"account_sid"+"}", url.PathEscape(parameterValueToString(r.accountSid, "accountSid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_sid"+"}", url.PathEscape(parameterValueToString(r.callSid, "callSid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.statusCallback != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "StatusCallback", r.statusCallback, "", "")
	}
	if r.statusCallbackMethod != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "StatusCallbackMethod", r.statusCallbackMethod, "", "")
	}
	if r.track != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "Track", r.track, "", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "Name", r.name, "", "")
	}
	if r.bidirectionalMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "BidirectionalMode", r.bidirectionalMode, "", "")
	}
	if r.bidirectionalCodec != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "BidirectionalCodec", r.bidirectionalCodec, "", "")
	}
	if r.url != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "Url", r.url, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartTeXMLSiprecSessionRequest struct {
	ctx context.Context
	ApiService *TeXMLRESTCommandsAPIService
	accountSid string
	callSid string
	connectorName *string
	name *string
	track *string
	includeMetadataCustomHeaders *bool
	secure *bool
	sessionTimeoutSecs *int32
	sipTransport *string
	statusCallback *string
	statusCallbackMethod *string
}

// The name of the connector to use for the SIPREC session.
func (r ApiStartTeXMLSiprecSessionRequest) ConnectorName(connectorName string) ApiStartTeXMLSiprecSessionRequest {
	r.connectorName = &connectorName
	return r
}

// Name of the SIPREC session. May be used to stop the SIPREC session from TeXML instruction.
func (r ApiStartTeXMLSiprecSessionRequest) Name(name string) ApiStartTeXMLSiprecSessionRequest {
	r.name = &name
	return r
}

// The track to be used for siprec session. Can be &#x60;both_tracks&#x60;, &#x60;inbound_track&#x60; or &#x60;outbound_track&#x60;. Defaults to &#x60;both_tracks&#x60;.
func (r ApiStartTeXMLSiprecSessionRequest) Track(track string) ApiStartTeXMLSiprecSessionRequest {
	r.track = &track
	return r
}

// When set, custom parameters will be added as metadata (recording.session.ExtensionParameters). Otherwise, they’ll be added to sip headers.
func (r ApiStartTeXMLSiprecSessionRequest) IncludeMetadataCustomHeaders(includeMetadataCustomHeaders bool) ApiStartTeXMLSiprecSessionRequest {
	r.includeMetadataCustomHeaders = &includeMetadataCustomHeaders
	return r
}

// Controls whether to encrypt media sent to your SRS using SRTP and TLS. When set you need to configure SRS port in your connector to 5061.
func (r ApiStartTeXMLSiprecSessionRequest) Secure(secure bool) ApiStartTeXMLSiprecSessionRequest {
	r.secure = &secure
	return r
}

// Sets &#x60;Session-Expires&#x60; header to the INVITE. A reinvite is sent every half the value set. Usefull for session keep alive. Minimum value is 90, set to 0 to disable.
func (r ApiStartTeXMLSiprecSessionRequest) SessionTimeoutSecs(sessionTimeoutSecs int32) ApiStartTeXMLSiprecSessionRequest {
	r.sessionTimeoutSecs = &sessionTimeoutSecs
	return r
}

// Specifies SIP transport protocol.
func (r ApiStartTeXMLSiprecSessionRequest) SipTransport(sipTransport string) ApiStartTeXMLSiprecSessionRequest {
	r.sipTransport = &sipTransport
	return r
}

// URL destination for Telnyx to send status callback events to for the siprec session.
func (r ApiStartTeXMLSiprecSessionRequest) StatusCallback(statusCallback string) ApiStartTeXMLSiprecSessionRequest {
	r.statusCallback = &statusCallback
	return r
}

// HTTP request type used for &#x60;StatusCallback&#x60;.
func (r ApiStartTeXMLSiprecSessionRequest) StatusCallbackMethod(statusCallbackMethod string) ApiStartTeXMLSiprecSessionRequest {
	r.statusCallbackMethod = &statusCallbackMethod
	return r
}

func (r ApiStartTeXMLSiprecSessionRequest) Execute() (*TexmlCreateSiprecSessionResponseBody, *http.Response, error) {
	return r.ApiService.StartTeXMLSiprecSessionExecute(r)
}

/*
StartTeXMLSiprecSession Request siprec session for a call

Starts siprec session with specified parameters for call idientified by call_sid.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The id of the account the resource belongs to.
 @param callSid The CallSid that identifies the call to update.
 @return ApiStartTeXMLSiprecSessionRequest
*/
func (a *TeXMLRESTCommandsAPIService) StartTeXMLSiprecSession(ctx context.Context, accountSid string, callSid string) ApiStartTeXMLSiprecSessionRequest {
	return ApiStartTeXMLSiprecSessionRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		callSid: callSid,
	}
}

// Execute executes the request
//  @return TexmlCreateSiprecSessionResponseBody
func (a *TeXMLRESTCommandsAPIService) StartTeXMLSiprecSessionExecute(r ApiStartTeXMLSiprecSessionRequest) (*TexmlCreateSiprecSessionResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TexmlCreateSiprecSessionResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeXMLRESTCommandsAPIService.StartTeXMLSiprecSession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/texml/Accounts/{account_sid}/Calls/{call_sid}/Siprec.json"
	localVarPath = strings.Replace(localVarPath, "{"+"account_sid"+"}", url.PathEscape(parameterValueToString(r.accountSid, "accountSid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_sid"+"}", url.PathEscape(parameterValueToString(r.callSid, "callSid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.connectorName != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "ConnectorName", r.connectorName, "", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "Name", r.name, "", "")
	}
	if r.track != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "Track", r.track, "", "")
	}
	if r.includeMetadataCustomHeaders != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "IncludeMetadataCustomHeaders", r.includeMetadataCustomHeaders, "", "")
	}
	if r.secure != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "Secure", r.secure, "", "")
	}
	if r.sessionTimeoutSecs != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "SessionTimeoutSecs", r.sessionTimeoutSecs, "", "")
	}
	if r.sipTransport != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "SipTransport", r.sipTransport, "", "")
	}
	if r.statusCallback != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "StatusCallback", r.statusCallback, "", "")
	}
	if r.statusCallbackMethod != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "StatusCallbackMethod", r.statusCallbackMethod, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTeXMLCallRecordingRequest struct {
	ctx context.Context
	ApiService *TeXMLRESTCommandsAPIService
	accountSid string
	callSid string
	recordingSid string
	status *string
}

func (r ApiUpdateTeXMLCallRecordingRequest) Status(status string) ApiUpdateTeXMLCallRecordingRequest {
	r.status = &status
	return r
}

func (r ApiUpdateTeXMLCallRecordingRequest) Execute() (*TexmlCreateCallRecordingResponseBody, *http.Response, error) {
	return r.ApiService.UpdateTeXMLCallRecordingExecute(r)
}

/*
UpdateTeXMLCallRecording Update recording on a call

Updates recording resource for particular call.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The id of the account the resource belongs to.
 @param callSid The CallSid that identifies the call to update.
 @param recordingSid Uniquely identifies the recording by id.
 @return ApiUpdateTeXMLCallRecordingRequest
*/
func (a *TeXMLRESTCommandsAPIService) UpdateTeXMLCallRecording(ctx context.Context, accountSid string, callSid string, recordingSid string) ApiUpdateTeXMLCallRecordingRequest {
	return ApiUpdateTeXMLCallRecordingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		callSid: callSid,
		recordingSid: recordingSid,
	}
}

// Execute executes the request
//  @return TexmlCreateCallRecordingResponseBody
func (a *TeXMLRESTCommandsAPIService) UpdateTeXMLCallRecordingExecute(r ApiUpdateTeXMLCallRecordingRequest) (*TexmlCreateCallRecordingResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TexmlCreateCallRecordingResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeXMLRESTCommandsAPIService.UpdateTeXMLCallRecording")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/texml/Accounts/{account_sid}/Calls/{call_sid}/Recordings/{recording_sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"account_sid"+"}", url.PathEscape(parameterValueToString(r.accountSid, "accountSid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_sid"+"}", url.PathEscape(parameterValueToString(r.callSid, "callSid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"recording_sid"+"}", url.PathEscape(parameterValueToString(r.recordingSid, "recordingSid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "Status", r.status, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTeXMLCallStreamingRequest struct {
	ctx context.Context
	ApiService *TeXMLRESTCommandsAPIService
	accountSid string
	callSid string
	streamingSid string
	status *StreamStatus
}

func (r ApiUpdateTeXMLCallStreamingRequest) Status(status StreamStatus) ApiUpdateTeXMLCallStreamingRequest {
	r.status = &status
	return r
}

func (r ApiUpdateTeXMLCallStreamingRequest) Execute() (*TexmlUpdateCallStreamingResponseBody, *http.Response, error) {
	return r.ApiService.UpdateTeXMLCallStreamingExecute(r)
}

/*
UpdateTeXMLCallStreaming Update streaming on a call

Updates streaming resource for particular call.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The id of the account the resource belongs to.
 @param callSid The CallSid that identifies the call to update.
 @param streamingSid Uniquely identifies the streaming by id.
 @return ApiUpdateTeXMLCallStreamingRequest
*/
func (a *TeXMLRESTCommandsAPIService) UpdateTeXMLCallStreaming(ctx context.Context, accountSid string, callSid string, streamingSid string) ApiUpdateTeXMLCallStreamingRequest {
	return ApiUpdateTeXMLCallStreamingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		callSid: callSid,
		streamingSid: streamingSid,
	}
}

// Execute executes the request
//  @return TexmlUpdateCallStreamingResponseBody
func (a *TeXMLRESTCommandsAPIService) UpdateTeXMLCallStreamingExecute(r ApiUpdateTeXMLCallStreamingRequest) (*TexmlUpdateCallStreamingResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TexmlUpdateCallStreamingResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeXMLRESTCommandsAPIService.UpdateTeXMLCallStreaming")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/texml/Accounts/{account_sid}/Calls/{call_sid}/Streams/{streaming_sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"account_sid"+"}", url.PathEscape(parameterValueToString(r.accountSid, "accountSid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_sid"+"}", url.PathEscape(parameterValueToString(r.callSid, "callSid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"streaming_sid"+"}", url.PathEscape(parameterValueToString(r.streamingSid, "streamingSid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "Status", r.status, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTeXMLSiprecSessionRequest struct {
	ctx context.Context
	ApiService *TeXMLRESTCommandsAPIService
	accountSid string
	callSid string
	siprecSid string
	status *string
}

// The new status of the resource. Specifying &#x60;stopped&#x60; will end the siprec session.
func (r ApiUpdateTeXMLSiprecSessionRequest) Status(status string) ApiUpdateTeXMLSiprecSessionRequest {
	r.status = &status
	return r
}

func (r ApiUpdateTeXMLSiprecSessionRequest) Execute() (*TexmlUpdateSiprecSessionResponseBody, *http.Response, error) {
	return r.ApiService.UpdateTeXMLSiprecSessionExecute(r)
}

/*
UpdateTeXMLSiprecSession Updates siprec session for a call

Updates siprec session identified by siprec_sid.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The id of the account the resource belongs to.
 @param callSid The CallSid that identifies the call to update.
 @param siprecSid The SiprecSid that uniquely identifies the Sip Recording.
 @return ApiUpdateTeXMLSiprecSessionRequest
*/
func (a *TeXMLRESTCommandsAPIService) UpdateTeXMLSiprecSession(ctx context.Context, accountSid string, callSid string, siprecSid string) ApiUpdateTeXMLSiprecSessionRequest {
	return ApiUpdateTeXMLSiprecSessionRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		callSid: callSid,
		siprecSid: siprecSid,
	}
}

// Execute executes the request
//  @return TexmlUpdateSiprecSessionResponseBody
func (a *TeXMLRESTCommandsAPIService) UpdateTeXMLSiprecSessionExecute(r ApiUpdateTeXMLSiprecSessionRequest) (*TexmlUpdateSiprecSessionResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TexmlUpdateSiprecSessionResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeXMLRESTCommandsAPIService.UpdateTeXMLSiprecSession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/texml/Accounts/{account_sid}/Calls/{call_sid}/Siprec/{siprec_sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"account_sid"+"}", url.PathEscape(parameterValueToString(r.accountSid, "accountSid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_sid"+"}", url.PathEscape(parameterValueToString(r.callSid, "callSid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siprec_sid"+"}", url.PathEscape(parameterValueToString(r.siprecSid, "siprecSid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "Status", r.status, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTexmlCallRequest struct {
	ctx context.Context
	ApiService *TeXMLRESTCommandsAPIService
	callSid string
	accountSid string
	status *string
	url *string
	method *string
	fallbackUrl *string
	fallbackMethod *string
	statusCallback *string
	statusCallbackMethod *string
	texml *string
}

// The value to set the call status to. Setting the status to completed ends the call.
func (r ApiUpdateTexmlCallRequest) Status(status string) ApiUpdateTexmlCallRequest {
	r.status = &status
	return r
}

// The URL where TeXML will make a request to retrieve a new set of TeXML instructions to continue the call flow.
func (r ApiUpdateTexmlCallRequest) Url(url string) ApiUpdateTexmlCallRequest {
	r.url = &url
	return r
}

// HTTP request type used for &#x60;Url&#x60;.
func (r ApiUpdateTexmlCallRequest) Method(method string) ApiUpdateTexmlCallRequest {
	r.method = &method
	return r
}

// A failover URL for which Telnyx will retrieve the TeXML call instructions if the Url is not responding.
func (r ApiUpdateTexmlCallRequest) FallbackUrl(fallbackUrl string) ApiUpdateTexmlCallRequest {
	r.fallbackUrl = &fallbackUrl
	return r
}

// HTTP request type used for &#x60;FallbackUrl&#x60;.
func (r ApiUpdateTexmlCallRequest) FallbackMethod(fallbackMethod string) ApiUpdateTexmlCallRequest {
	r.fallbackMethod = &fallbackMethod
	return r
}

// URL destination for Telnyx to send status callback events to for the call.
func (r ApiUpdateTexmlCallRequest) StatusCallback(statusCallback string) ApiUpdateTexmlCallRequest {
	r.statusCallback = &statusCallback
	return r
}

// HTTP request type used for &#x60;StatusCallback&#x60;.
func (r ApiUpdateTexmlCallRequest) StatusCallbackMethod(statusCallbackMethod string) ApiUpdateTexmlCallRequest {
	r.statusCallbackMethod = &statusCallbackMethod
	return r
}

// TeXML to replace the current one with.
func (r ApiUpdateTexmlCallRequest) Texml(texml string) ApiUpdateTexmlCallRequest {
	r.texml = &texml
	return r
}

func (r ApiUpdateTexmlCallRequest) Execute() (*CallResource, *http.Response, error) {
	return r.ApiService.UpdateTexmlCallExecute(r)
}

/*
UpdateTexmlCall Update call

Update TeXML call. Please note that the keys present in the payload MUST BE formatted in CamelCase as specified in the example.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callSid The CallSid that identifies the call to update.
 @param accountSid The id of the account the resource belongs to.
 @return ApiUpdateTexmlCallRequest
*/
func (a *TeXMLRESTCommandsAPIService) UpdateTexmlCall(ctx context.Context, callSid string, accountSid string) ApiUpdateTexmlCallRequest {
	return ApiUpdateTexmlCallRequest{
		ApiService: a,
		ctx: ctx,
		callSid: callSid,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return CallResource
func (a *TeXMLRESTCommandsAPIService) UpdateTexmlCallExecute(r ApiUpdateTexmlCallRequest) (*CallResource, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeXMLRESTCommandsAPIService.UpdateTexmlCall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/texml/Accounts/{account_sid}/Calls/{call_sid}"
	localVarPath = strings.Replace(localVarPath, "{"+"call_sid"+"}", url.PathEscape(parameterValueToString(r.callSid, "callSid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"account_sid"+"}", url.PathEscape(parameterValueToString(r.accountSid, "accountSid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "Status", r.status, "", "")
	}
	if r.url != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "Url", r.url, "", "")
	}
	if r.method != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "Method", r.method, "", "")
	}
	if r.fallbackUrl != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "FallbackUrl", r.fallbackUrl, "", "")
	}
	if r.fallbackMethod != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "FallbackMethod", r.fallbackMethod, "", "")
	}
	if r.statusCallback != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "StatusCallback", r.statusCallback, "", "")
	}
	if r.statusCallbackMethod != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "StatusCallbackMethod", r.statusCallbackMethod, "", "")
	}
	if r.texml != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "Texml", r.texml, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTexmlConferenceRequest struct {
	ctx context.Context
	ApiService *TeXMLRESTCommandsAPIService
	accountSid string
	conferenceSid string
	status *string
	announceUrl *string
	announceMethod *string
}

// The new status of the resource. Specifying &#x60;completed&#x60; will end the conference and hang up all participants.
func (r ApiUpdateTexmlConferenceRequest) Status(status string) ApiUpdateTexmlConferenceRequest {
	r.status = &status
	return r
}

// The URL we should call to announce something into the conference. The URL may return an MP3 file, a WAV file, or a TwiML document that contains &#x60;&lt;Play&gt;&#x60;, &#x60;&lt;Say&gt;&#x60;, &#x60;&lt;Pause&gt;&#x60;, or &#x60;&lt;Redirect&gt;&#x60; verbs.
func (r ApiUpdateTexmlConferenceRequest) AnnounceUrl(announceUrl string) ApiUpdateTexmlConferenceRequest {
	r.announceUrl = &announceUrl
	return r
}

// The HTTP method used to call the &#x60;AnnounceUrl&#x60;. Defaults to &#x60;POST&#x60;.
func (r ApiUpdateTexmlConferenceRequest) AnnounceMethod(announceMethod string) ApiUpdateTexmlConferenceRequest {
	r.announceMethod = &announceMethod
	return r
}

func (r ApiUpdateTexmlConferenceRequest) Execute() (*ConferenceResource, *http.Response, error) {
	return r.ApiService.UpdateTexmlConferenceExecute(r)
}

/*
UpdateTexmlConference Update a conference resource

Updates a conference resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The id of the account the resource belongs to.
 @param conferenceSid The ConferenceSid that uniquely identifies a conference.
 @return ApiUpdateTexmlConferenceRequest
*/
func (a *TeXMLRESTCommandsAPIService) UpdateTexmlConference(ctx context.Context, accountSid string, conferenceSid string) ApiUpdateTexmlConferenceRequest {
	return ApiUpdateTexmlConferenceRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		conferenceSid: conferenceSid,
	}
}

// Execute executes the request
//  @return ConferenceResource
func (a *TeXMLRESTCommandsAPIService) UpdateTexmlConferenceExecute(r ApiUpdateTexmlConferenceRequest) (*ConferenceResource, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConferenceResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeXMLRESTCommandsAPIService.UpdateTexmlConference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/texml/Accounts/{account_sid}/Conferences/{conference_sid}"
	localVarPath = strings.Replace(localVarPath, "{"+"account_sid"+"}", url.PathEscape(parameterValueToString(r.accountSid, "accountSid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conference_sid"+"}", url.PathEscape(parameterValueToString(r.conferenceSid, "conferenceSid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "Status", r.status, "", "")
	}
	if r.announceUrl != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "AnnounceUrl", r.announceUrl, "", "")
	}
	if r.announceMethod != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "AnnounceMethod", r.announceMethod, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTexmlConferenceParticipantRequest struct {
	ctx context.Context
	ApiService *TeXMLRESTCommandsAPIService
	accountSid string
	conferenceSid string
	callSid string
	muted *bool
	hold *bool
	holdUrl *string
	holdMethod *string
	announceUrl *string
	announceMethod *string
	waitUrl *string
	beepOnExit *bool
	endConferenceOnExit *bool
	coaching *bool
	callSidToCoach *string
}

// Whether the participant should be muted.
func (r ApiUpdateTexmlConferenceParticipantRequest) Muted(muted bool) ApiUpdateTexmlConferenceParticipantRequest {
	r.muted = &muted
	return r
}

// Whether the participant should be on hold.
func (r ApiUpdateTexmlConferenceParticipantRequest) Hold(hold bool) ApiUpdateTexmlConferenceParticipantRequest {
	r.hold = &hold
	return r
}

// The URL to be called using the &#x60;HoldMethod&#x60; for music that plays when the participant is on hold. The URL may return an MP3 file, a WAV file, or a TwiML document that contains &#x60;&lt;Play&gt;&#x60;, &#x60;&lt;Say&gt;&#x60;, &#x60;&lt;Pause&gt;&#x60;, or &#x60;&lt;Redirect&gt;&#x60; verbs.
func (r ApiUpdateTexmlConferenceParticipantRequest) HoldUrl(holdUrl string) ApiUpdateTexmlConferenceParticipantRequest {
	r.holdUrl = &holdUrl
	return r
}

// The HTTP method to use when calling the &#x60;HoldUrl&#x60;.
func (r ApiUpdateTexmlConferenceParticipantRequest) HoldMethod(holdMethod string) ApiUpdateTexmlConferenceParticipantRequest {
	r.holdMethod = &holdMethod
	return r
}

// The URL to call to announce something to the participant. The URL may return an MP3 fileo a WAV file, or a TwiML document that contains &#x60;&lt;Play&gt;&#x60;, &#x60;&lt;Say&gt;&#x60;, &#x60;&lt;Pause&gt;&#x60;, or &#x60;&lt;Redirect&gt;&#x60; verbs.
func (r ApiUpdateTexmlConferenceParticipantRequest) AnnounceUrl(announceUrl string) ApiUpdateTexmlConferenceParticipantRequest {
	r.announceUrl = &announceUrl
	return r
}

// The HTTP method used to call the &#x60;AnnounceUrl&#x60;. Defaults to &#x60;POST&#x60;.
func (r ApiUpdateTexmlConferenceParticipantRequest) AnnounceMethod(announceMethod string) ApiUpdateTexmlConferenceParticipantRequest {
	r.announceMethod = &announceMethod
	return r
}

// The URL to call for an audio file to play while the participant is waiting for the conference to start.
func (r ApiUpdateTexmlConferenceParticipantRequest) WaitUrl(waitUrl string) ApiUpdateTexmlConferenceParticipantRequest {
	r.waitUrl = &waitUrl
	return r
}

// Whether to play a notification beep to the conference when the participant exits.
func (r ApiUpdateTexmlConferenceParticipantRequest) BeepOnExit(beepOnExit bool) ApiUpdateTexmlConferenceParticipantRequest {
	r.beepOnExit = &beepOnExit
	return r
}

// Whether to end the conference when the participant leaves.
func (r ApiUpdateTexmlConferenceParticipantRequest) EndConferenceOnExit(endConferenceOnExit bool) ApiUpdateTexmlConferenceParticipantRequest {
	r.endConferenceOnExit = &endConferenceOnExit
	return r
}

// Whether the participant is coaching another call. When &#x60;true&#x60;, &#x60;CallSidToCoach&#x60; has to be given.
func (r ApiUpdateTexmlConferenceParticipantRequest) Coaching(coaching bool) ApiUpdateTexmlConferenceParticipantRequest {
	r.coaching = &coaching
	return r
}

// The SID of the participant who is being coached. The participant being coached is the only participant who can hear the participant who is coaching.
func (r ApiUpdateTexmlConferenceParticipantRequest) CallSidToCoach(callSidToCoach string) ApiUpdateTexmlConferenceParticipantRequest {
	r.callSidToCoach = &callSidToCoach
	return r
}

func (r ApiUpdateTexmlConferenceParticipantRequest) Execute() (*ParticipantResource, *http.Response, error) {
	return r.ApiService.UpdateTexmlConferenceParticipantExecute(r)
}

/*
UpdateTexmlConferenceParticipant Update a conference participant

Updates a conference participant

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The id of the account the resource belongs to.
 @param conferenceSid The ConferenceSid that uniquely identifies a conference.
 @param callSid The CallSid that identifies the call to update.
 @return ApiUpdateTexmlConferenceParticipantRequest
*/
func (a *TeXMLRESTCommandsAPIService) UpdateTexmlConferenceParticipant(ctx context.Context, accountSid string, conferenceSid string, callSid string) ApiUpdateTexmlConferenceParticipantRequest {
	return ApiUpdateTexmlConferenceParticipantRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		conferenceSid: conferenceSid,
		callSid: callSid,
	}
}

// Execute executes the request
//  @return ParticipantResource
func (a *TeXMLRESTCommandsAPIService) UpdateTexmlConferenceParticipantExecute(r ApiUpdateTexmlConferenceParticipantRequest) (*ParticipantResource, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ParticipantResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeXMLRESTCommandsAPIService.UpdateTexmlConferenceParticipant")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/texml/Accounts/{account_sid}/Conferences/{conference_sid}/Participants/{call_sid}"
	localVarPath = strings.Replace(localVarPath, "{"+"account_sid"+"}", url.PathEscape(parameterValueToString(r.accountSid, "accountSid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conference_sid"+"}", url.PathEscape(parameterValueToString(r.conferenceSid, "conferenceSid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_sid"+"}", url.PathEscape(parameterValueToString(r.callSid, "callSid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.muted != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "Muted", r.muted, "", "")
	}
	if r.hold != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "Hold", r.hold, "", "")
	}
	if r.holdUrl != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "HoldUrl", r.holdUrl, "", "")
	}
	if r.holdMethod != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "HoldMethod", r.holdMethod, "", "")
	}
	if r.announceUrl != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "AnnounceUrl", r.announceUrl, "", "")
	}
	if r.announceMethod != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "AnnounceMethod", r.announceMethod, "", "")
	}
	if r.waitUrl != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "WaitUrl", r.waitUrl, "", "")
	}
	if r.beepOnExit != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "BeepOnExit", r.beepOnExit, "", "")
	}
	if r.endConferenceOnExit != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "EndConferenceOnExit", r.endConferenceOnExit, "", "")
	}
	if r.coaching != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "Coaching", r.coaching, "", "")
	}
	if r.callSidToCoach != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "CallSidToCoach", r.callSidToCoach, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResourceNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
